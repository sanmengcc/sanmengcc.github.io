<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Here will be a new beginning</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.huhdcc.top/"/>
  <updated>2021-11-15T10:41:03.115Z</updated>
  <id>https://blog.huhdcc.top/</id>
  
  <author>
    <name>sanmeng</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>水印PDFdemo搭建流程(Gradle)</title>
    <link href="https://blog.huhdcc.top/2021/11/15/51167/hub/"/>
    <id>https://blog.huhdcc.top/2021/11/15/51167/hub/</id>
    <published>2021-11-15T03:28:21.000Z</published>
    <updated>2021-11-15T10:41:03.115Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/image/hexo/image-20211115112836340.png" alt="image-20211115112836340"></p><p>&emsp;&emsp;此文章需要安装<strong>Gradle</strong>环境、<strong>Gradle</strong>与<strong>Maven</strong>类似、用法上大同小异。</p><h2 id="构建项目"><a href="#构建项目" class="headerlink" title="构建项目"></a>构建项目</h2><h3 id="新建项目"><a href="#新建项目" class="headerlink" title="新建项目"></a>新建项目</h3><p><img src="/image/hexo/image-20211115113040774.png" alt="image-20211115113040774"></p><p><img src="/image/hexo/image-20211115113125232.png" alt="image-20211115113125232"></p><p><img src="/image/hexo/image-20211115113401861.png" alt="image-20211115113401861"></p><h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><p><img src="/image/hexo/image-20211115113815894.png" alt="image-20211115113815894"></p><h3 id="添加SpringBoot依赖"><a href="#添加SpringBoot依赖" class="headerlink" title="添加SpringBoot依赖"></a>添加SpringBoot依赖</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">implementation</span> <span class="string">'org.springframework.boot:spring-boot-starter-web:2.5.6'</span></span><br></pre></td></tr></table></figure><p><img src="/image/hexo/image-20211115114644873.png" alt="image-20211115114644873"></p><h3 id="使用阿里云国内maven库"><a href="#使用阿里云国内maven库" class="headerlink" title="使用阿里云国内maven库"></a>使用阿里云国内maven库</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">repositories</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="string">//mavenCentral()</span></span><br><span class="line">    <span class="string">maven&#123;</span></span><br><span class="line">        <span class="string">url</span> <span class="string">'https://maven.aliyun.com/nexus/content/repositories/central/'</span></span><br><span class="line">    <span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p><img src="/image/hexo/image-20211115115501793.png" alt="image-20211115115501793"></p><h3 id="刷新依赖"><a href="#刷新依赖" class="headerlink" title="刷新依赖"></a>刷新依赖</h3><p><img src="/image/hexo/image-20211115114750223.png" alt="image-20211115114750223"></p><p>&emsp;&emsp;安静等待依赖刷新完成……</p><h3 id="新建SpringBoot启动类"><a href="#新建SpringBoot启动类" class="headerlink" title="新建SpringBoot启动类"></a>新建SpringBoot启动类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Application<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">        System.out.println(<span class="string">"SpringBoot启动成功"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/image/hexo/image-20211115115729814.png" alt="image-20211115115729814"></p><h3 id="启动Application"><a href="#启动Application" class="headerlink" title="启动Application"></a>启动Application</h3><p>&emsp;&emsp; 执行Application的main方法便可启动SpringBoot.观察控制台是否输出成功信息。</p><p><img src="/image/hexo/image-20211115115913215.png" alt="image-20211115115913215"></p><p>&emsp;&emsp;从控制台的信息中可以查看到Tomcat启动的端口<strong>8080</strong>,以及启动成功的日志信息。</p><h3 id="使用SpringBoot测试Web访问是否成功"><a href="#使用SpringBoot测试Web访问是否成功" class="headerlink" title="使用SpringBoot测试Web访问是否成功"></a>使用SpringBoot测试Web访问是否成功</h3><p>&emsp;&emsp;  新增一个控制器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestApi</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"我是第一个SpringBoot应用"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/image/hexo/image-20211115120226657.png" alt="image-20211115120226657"></p><p>&emsp;&emsp;重新启动Application。在浏览器进行访问<strong><a href="http://127.0.0.1:8080/hello" target="_blank" rel="noopener">http://127.0.0.1:8080/hello</a></strong></p><p><img src="/image/hexo/image-20211115120342891.png" alt="image-20211115120342891"></p><p>&emsp;&emsp;第一章节SpringBoot项目搭建完成。</p><h2 id="水印PDF项目"><a href="#水印PDF项目" class="headerlink" title="水印PDF项目"></a>水印PDF项目</h2><h3 id="流程拆解"><a href="#流程拆解" class="headerlink" title="流程拆解"></a>流程拆解</h3><p><img src="/image/hexo/image-20211115143844303.png" alt="image-20211115143844303"></p><h3 id="代码拆解"><a href="#代码拆解" class="headerlink" title="代码拆解"></a>代码拆解</h3><p><img src="/image/hexo/image-20211115145242952.png" alt="image-20211115145242952"></p><h3 id="编写控制器"><a href="#编写控制器" class="headerlink" title="编写控制器"></a>编写控制器</h3><p><img src="/image/hexo/image-20211115151721036.png" alt="image-20211115151721036"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.pdfwatermark;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PostMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.multipart.MultipartFile;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PdfWatermarkApi</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 文件上传控制器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> filenames 批量上传的文件集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostMapping</span>(value = <span class="string">"/pdf/watermark/upload"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">upload</span><span class="params">(MultipartFile[] filenames)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (MultipartFile multipartFile : filenames) &#123;</span><br><span class="line">            <span class="comment">//打印数据</span></span><br><span class="line">            System.out.println(multipartFile.getOriginalFilename() + <span class="string">" FileSize:"</span> + multipartFile.getSize());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"这是等待生成的下载地址"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;<strong>PostMapping:</strong>指定POST请求方式。</p><p>&emsp;&emsp;<strong>MultipartFile[] filenames:</strong>接受web提交的多个文件。</p><p>&emsp;&emsp;<strong>/pdf/watermark/upload:</strong>指定web请求的url。</p><h3 id="使用POSTMAN测试文件上传"><a href="#使用POSTMAN测试文件上传" class="headerlink" title="使用POSTMAN测试文件上传"></a>使用POSTMAN测试文件上传</h3><p>&emsp;&emsp;需要先安装好软件<strong>POSTMAN</strong>。</p><p><img src="/image/hexo/image-20211115152031813.png" alt="image-20211115152031813"></p><p>&emsp;&emsp;选择File类型。</p><p><img src="/image/hexo/image-20211115152102198.png" alt="image-20211115152102198"></p><p>&emsp;&emsp;执行send、查看IDEA控制台。</p><p><img src="/image/hexo/image-20211115152147538.png" alt="image-20211115152147538"></p><p>&emsp;&emsp;正常输出、表示我们从web层获取到了上传的文件内容。我们接着编写下一步的代码。</p><h3 id="编写PDF拆分图片代码"><a href="#编写PDF拆分图片代码" class="headerlink" title="编写PDF拆分图片代码"></a>编写PDF拆分图片代码</h3><h4 id="新建实体对象FileDTO"><a href="#新建实体对象FileDTO" class="headerlink" title="新建实体对象FileDTO"></a>新建实体对象FileDTO</h4><p>&emsp;&emsp;主要用户保存文件和文件的序号的关系。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileDTO</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 文件序号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer index;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 文件路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String path;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIndex</span><span class="params">(Integer index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.index = index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPath</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> path;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPath</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.path = path;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="新增常量定义PdfWatermarkConstants"><a href="#新增常量定义PdfWatermarkConstants" class="headerlink" title="新增常量定义PdfWatermarkConstants"></a>新增常量定义PdfWatermarkConstants</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PdfWatermarkConstants</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 基础路径</span></span><br><span class="line"><span class="comment">     * 当前项目的根目录</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String BASE = <span class="string">"data/res/"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * pdf转化成为图片</span></span><br><span class="line"><span class="comment">     * 图片的存储的未知</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String PDF_2_IMAGE = BASE + <span class="string">"pdf2image/"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="添加Gradle相关PDF依赖支持"><a href="#添加Gradle相关PDF依赖支持" class="headerlink" title="添加Gradle相关PDF依赖支持"></a>添加Gradle相关PDF依赖支持</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">'com.itextpdf:itextpdf:5.5.13'</span></span><br><span class="line">implementation <span class="string">'com.itextpdf:itext-asian:5.2.0'</span></span><br><span class="line">  </span><br><span class="line">implementation <span class="string">'org.apache.pdfbox:pdfbox:2.0.4'</span></span><br><span class="line">implementation <span class="string">'org.apache.pdfbox:pdfbox-tools:2.0.4'</span></span><br><span class="line"></span><br><span class="line">implementation <span class="string">'commons-io:commons-io:2.7'</span></span><br></pre></td></tr></table></figure><h4 id="新增PDF处理图片Pdf2Image"><a href="#新增PDF处理图片Pdf2Image" class="headerlink" title="新增PDF处理图片Pdf2Image"></a>新增PDF处理图片Pdf2Image</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.pdfwatermark;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.pdfbox.pdmodel.PDDocument;</span><br><span class="line"><span class="keyword">import</span> org.apache.pdfbox.rendering.ImageType;</span><br><span class="line"><span class="keyword">import</span> org.apache.pdfbox.rendering.PDFRenderer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.imageio.ImageIO;</span><br><span class="line"><span class="keyword">import</span> java.awt.image.BufferedImage;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pdf2Image</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将File PDF文件转化为每一张图片</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> file PDF文件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回每一张图片的实体对象集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;FileDTO&gt; <span class="title">generate</span><span class="params">(File file)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Long now = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//读取PDF</span></span><br><span class="line">            PDDocument document = PDDocument.load(file);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//加载PDF对象</span></span><br><span class="line">            PDFRenderer pdfRenderer = <span class="keyword">new</span> PDFRenderer(document);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//存储的PDF每一张图片的路径以及索引</span></span><br><span class="line">            List&lt;FileDTO&gt; dataList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> page = <span class="number">0</span>;page&lt;document.getNumberOfPages();page++)&#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//读取PDF每一页的图片</span></span><br><span class="line">                BufferedImage img = pdfRenderer.renderImageWithDPI(page, <span class="number">300</span>, ImageType.RGB);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//生成图片的本地路径</span></span><br><span class="line">                String pathname = PdfWatermarkConstants.PDF_2_IMAGE + now + <span class="string">"/"</span> + file.getName() + page + <span class="string">".png"</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//创建本地文件</span></span><br><span class="line">                File imageFile = <span class="keyword">new</span> File(pathname);</span><br><span class="line">                <span class="comment">//创建文件夹</span></span><br><span class="line">                imageFile.mkdirs();</span><br><span class="line">                <span class="comment">//创建文件</span></span><br><span class="line">                imageFile.createNewFile();</span><br><span class="line"></span><br><span class="line">                FileDTO dto = <span class="keyword">new</span> FileDTO();</span><br><span class="line">                dataList.add(dto);</span><br><span class="line"></span><br><span class="line">                dto.setIndex(page);</span><br><span class="line">                dto.setPath(pathname);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//生成PNG格式的图片</span></span><br><span class="line">                ImageIO.write(img, <span class="string">"png"</span>, imageFile);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//关闭Doc流</span></span><br><span class="line">            document.close();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> dataList;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="修改控制器调用PDF转换Image"><a href="#修改控制器调用PDF转换Image" class="headerlink" title="修改控制器调用PDF转换Image"></a>修改控制器调用PDF转换Image</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.pdfwatermark;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.io.FileUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PostMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.multipart.MultipartFile;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PdfWatermarkApi</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 文件上传控制器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> filenames 批量上传的文件集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostMapping</span>(value = <span class="string">"/pdf/watermark/upload"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">upload</span><span class="params">(MultipartFile[] filenames)</span> </span>&#123;</span><br><span class="line">        Long now = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (MultipartFile multipartFile : filenames) &#123;</span><br><span class="line">            <span class="comment">//打印数据</span></span><br><span class="line">            System.out.println(multipartFile.getOriginalFilename() + <span class="string">" FileSize:"</span> + multipartFile.getSize());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//指定本地的PDF文件路径以及名称</span></span><br><span class="line">                String pathname = PdfWatermarkConstants.BASE + now + <span class="string">"/"</span> + multipartFile.getOriginalFilename();</span><br><span class="line">                <span class="comment">//创建本地的PDF</span></span><br><span class="line">                File pdfFile = <span class="keyword">new</span> File(pathname);</span><br><span class="line">                <span class="comment">//将网络流 MultipartFile 转化为本地 PDF文件</span></span><br><span class="line">                FileUtils.copyInputStreamToFile(multipartFile.getInputStream(), pdfFile);</span><br><span class="line">                <span class="comment">//PDF转化为图片</span></span><br><span class="line">                List&lt;FileDTO&gt; imageDTOs = Pdf2Image.generate(pdfFile);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//打印日志输出语句</span></span><br><span class="line">                <span class="keyword">for</span> (FileDTO fileDTO : imageDTOs) &#123;</span><br><span class="line">                    System.out.println(pdfFile.getName() + <span class="string">" -&gt; PDF转化image："</span> + fileDTO.getIndex() + <span class="string">" 文件路径："</span> + fileDTO.getPath());</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"这是等待生成的下载地址"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="项目结构-1"><a href="#项目结构-1" class="headerlink" title="项目结构"></a>项目结构</h4><p><img src="/image/hexo/image-20211115163513148.png" alt="image-20211115163513148"></p><h4 id="测试转化效果"><a href="#测试转化效果" class="headerlink" title="测试转化效果"></a>测试转化效果</h4><p><img src="/image/hexo/image-20211115163542395.png" alt="image-20211115163542395"></p><h3 id="编写图片水印图片代码"><a href="#编写图片水印图片代码" class="headerlink" title="编写图片水印图片代码"></a>编写图片水印图片代码</h3><h4 id="增加ImageWatemark"><a href="#增加ImageWatemark" class="headerlink" title="增加ImageWatemark"></a>增加ImageWatemark</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.pdfwatermark;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.imageio.ImageIO;</span><br><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.image.BufferedImage;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImageWatemark</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 图片增加图片水印</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> iconPath 水印的地址 http</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> srcImgPath 原本的图片地址 File</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> degree 旋转角度</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">markImage</span><span class="params">(String iconPath, String srcImgPath, Integer degree)</span> </span>&#123;</span><br><span class="line">        OutputStream os = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//读取原图片文件</span></span><br><span class="line">            Image srcImg = ImageIO.read(<span class="keyword">new</span> File(srcImgPath));</span><br><span class="line"></span><br><span class="line">            <span class="comment">//加载图片</span></span><br><span class="line">            BufferedImage buffImg = <span class="keyword">new</span> BufferedImage(srcImg.getWidth(<span class="keyword">null</span>), srcImg.getHeight(<span class="keyword">null</span>),</span><br><span class="line">                    BufferedImage.TYPE_INT_RGB);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//得到画笔对象</span></span><br><span class="line">            Graphics2D g = buffImg.createGraphics();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//设置对线段的锯齿状边缘处理</span></span><br><span class="line">            g.setRenderingHint(RenderingHints.KEY_INTERPOLATION, RenderingHints.VALUE_INTERPOLATION_BILINEAR);</span><br><span class="line">            g.drawImage(srcImg.getScaledInstance(srcImg.getWidth(<span class="keyword">null</span>),</span><br><span class="line">                            srcImg.getHeight(<span class="keyword">null</span>),</span><br><span class="line">                            Image.SCALE_SMOOTH),</span><br><span class="line">                            <span class="number">0</span>,</span><br><span class="line">                            <span class="number">0</span>,</span><br><span class="line">                    <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != degree) &#123;</span><br><span class="line">                <span class="comment">//设置水印旋转</span></span><br><span class="line">                g.rotate(Math.toRadians(degree), (<span class="keyword">double</span>) buffImg.getWidth() / <span class="number">2</span>, (<span class="keyword">double</span>) buffImg.getHeight() / <span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//水印图象</span></span><br><span class="line">            ImageIcon imgIcon = <span class="keyword">new</span> ImageIcon(<span class="keyword">new</span> URL(iconPath));</span><br><span class="line"></span><br><span class="line">            <span class="comment">//得到Image对象</span></span><br><span class="line">            Image img = imgIcon.getImage();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//设置透明度</span></span><br><span class="line">            <span class="keyword">float</span> alpha = <span class="number">0.5f</span>;</span><br><span class="line">            g.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_ATOP, alpha));</span><br><span class="line"></span><br><span class="line">            <span class="comment">//设置水印图片坐标</span></span><br><span class="line">            g.drawImage(img, <span class="number">150</span>, <span class="number">300</span>, <span class="keyword">null</span>);</span><br><span class="line">            g.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER));</span><br><span class="line">            g.dispose();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//生成新的图片</span></span><br><span class="line"></span><br><span class="line">            String targerPath = srcImgPath + <span class="string">"_image_mark.png"</span>;</span><br><span class="line">            os = <span class="keyword">new</span> FileOutputStream(targerPath);</span><br><span class="line">            ImageIO.write(buffImg, <span class="string">"png"</span>, os);</span><br><span class="line">            <span class="keyword">return</span> targerPath;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> != os)</span><br><span class="line">                    os.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="修改控制器、测试图片水印"><a href="#修改控制器、测试图片水印" class="headerlink" title="修改控制器、测试图片水印"></a>修改控制器、测试图片水印</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">package com.example.pdfwatermark;</span><br><span class="line"></span><br><span class="line">import org.apache.commons.io.FileUtils;</span><br><span class="line">import org.springframework.web.bind.annotation.PostMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line">import org.springframework.web.multipart.MultipartFile;</span><br><span class="line"></span><br><span class="line">import java.io.File;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">public class PdfWatermarkApi &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 文件上传控制器</span><br><span class="line">     * @param filenames 批量上传的文件集合</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @PostMapping(value &#x3D; &quot;&#x2F;pdf&#x2F;watermark&#x2F;upload&quot;)</span><br><span class="line">    public String upload(MultipartFile[] filenames) &#123;</span><br><span class="line">        Long now &#x3D; System.currentTimeMillis();</span><br><span class="line">        for (MultipartFile multipartFile : filenames) &#123;</span><br><span class="line">            &#x2F;&#x2F;打印数据</span><br><span class="line">            System.out.println(multipartFile.getOriginalFilename() + &quot; FileSize:&quot; + multipartFile.getSize());</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                &#x2F;&#x2F;指定本地的PDF文件路径以及名称</span><br><span class="line">                String pathname &#x3D; PdfWatermarkConstants.BASE + now + &quot;&#x2F;&quot; + multipartFile.getOriginalFilename();</span><br><span class="line">                &#x2F;&#x2F;创建本地的PDF</span><br><span class="line">                File pdfFile &#x3D; new File(pathname);</span><br><span class="line">                &#x2F;&#x2F;将网络流 MultipartFile 转化为本地 PDF文件</span><br><span class="line">                FileUtils.copyInputStreamToFile(multipartFile.getInputStream(), pdfFile);</span><br><span class="line">                &#x2F;&#x2F;PDF转化为图片</span><br><span class="line">                List&lt;FileDTO&gt; imageDTOs &#x3D; Pdf2Image.generate(pdfFile);</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F;图片水印后的图片</span><br><span class="line">                List&lt;FileDTO&gt; imageMarkDTOs &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F;打印日志输出语句</span><br><span class="line">                for (FileDTO fileDTO : imageDTOs) &#123;</span><br><span class="line">                    System.out.println(pdfFile.getName() + &quot; -&gt; PDF转化image：&quot; + fileDTO.getIndex() + &quot; 文件路径：&quot; + fileDTO.getPath());</span><br><span class="line"></span><br><span class="line">                    &#x2F;&#x2F;图片水印</span><br><span class="line">                    String markImage &#x3D; ImageWatemark.markImage(&quot;https:&#x2F;&#x2F;www.wwei.cn&#x2F;yasuotu&#x2F;images&#x2F;logo.png&quot;, fileDTO.getPath(), null);</span><br><span class="line"></span><br><span class="line">                    &#x2F;&#x2F;添加到图片水印后的图片集合</span><br><span class="line">                    FileDTO newFileDTO &#x3D; new FileDTO();</span><br><span class="line">                    newFileDTO.setPath(markImage);</span><br><span class="line">                    newFileDTO.setIndex(fileDTO.getIndex());</span><br><span class="line">                    imageMarkDTOs.add(newFileDTO);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F;打印日志输出语句</span><br><span class="line">                for (FileDTO fileDTO : imageMarkDTOs) &#123;</span><br><span class="line">                    System.out.println(pdfFile.getName() + &quot; -&gt; Image添加图片水印：&quot; + fileDTO.getIndex() + &quot; 文件路径：&quot; + fileDTO.getPath());</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        return &quot;这是等待生成的下载地址&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/image/hexo/image-20211115165830311.png" alt="image-20211115165830311"></p><h3 id="编写图片水印文字代码"><a href="#编写图片水印文字代码" class="headerlink" title="编写图片水印文字代码"></a>编写图片水印文字代码</h3><h4 id="修改ImageWatemark-添加图片水印文字方法"><a href="#修改ImageWatemark-添加图片水印文字方法" class="headerlink" title="修改ImageWatemark,添加图片水印文字方法"></a>修改ImageWatemark,添加图片水印文字方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.pdfwatermark;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.imageio.ImageIO;</span><br><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.image.BufferedImage;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImageWatemark</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 图片增加图片水印</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> iconPath 水印的地址 http</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> srcImgPath 原本的图片地址 File</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> degree 旋转角度</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">markImage</span><span class="params">(String iconPath, String srcImgPath, Integer degree)</span> </span>&#123;</span><br><span class="line">        OutputStream os = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//读取原图片文件</span></span><br><span class="line">            Image srcImg = ImageIO.read(<span class="keyword">new</span> File(srcImgPath));</span><br><span class="line"></span><br><span class="line">            <span class="comment">//加载图片</span></span><br><span class="line">            BufferedImage buffImg = <span class="keyword">new</span> BufferedImage(srcImg.getWidth(<span class="keyword">null</span>), srcImg.getHeight(<span class="keyword">null</span>),</span><br><span class="line">                    BufferedImage.TYPE_INT_RGB);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//得到画笔对象</span></span><br><span class="line">            Graphics2D g = buffImg.createGraphics();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//设置对线段的锯齿状边缘处理</span></span><br><span class="line">            g.setRenderingHint(RenderingHints.KEY_INTERPOLATION, RenderingHints.VALUE_INTERPOLATION_BILINEAR);</span><br><span class="line">            g.drawImage(srcImg.getScaledInstance(srcImg.getWidth(<span class="keyword">null</span>),</span><br><span class="line">                            srcImg.getHeight(<span class="keyword">null</span>),</span><br><span class="line">                            Image.SCALE_SMOOTH),</span><br><span class="line">                            <span class="number">0</span>,</span><br><span class="line">                            <span class="number">0</span>,</span><br><span class="line">                    <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != degree) &#123;</span><br><span class="line">                <span class="comment">//设置水印旋转</span></span><br><span class="line">                g.rotate(Math.toRadians(degree), (<span class="keyword">double</span>) buffImg.getWidth() / <span class="number">2</span>, (<span class="keyword">double</span>) buffImg.getHeight() / <span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//水印图象</span></span><br><span class="line">            ImageIcon imgIcon = <span class="keyword">new</span> ImageIcon(<span class="keyword">new</span> URL(iconPath));</span><br><span class="line"></span><br><span class="line">            <span class="comment">//得到Image对象</span></span><br><span class="line">            Image img = imgIcon.getImage();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//设置透明度</span></span><br><span class="line">            <span class="keyword">float</span> alpha = <span class="number">0.5f</span>;</span><br><span class="line">            g.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_ATOP, alpha));</span><br><span class="line"></span><br><span class="line">            <span class="comment">//设置水印图片坐标</span></span><br><span class="line">            g.drawImage(img, <span class="number">150</span>, <span class="number">300</span>, <span class="keyword">null</span>);</span><br><span class="line">            g.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER));</span><br><span class="line">            g.dispose();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//生成新的图片</span></span><br><span class="line"></span><br><span class="line">            String targerPath = srcImgPath + <span class="string">"_image_mark.png"</span>;</span><br><span class="line">            os = <span class="keyword">new</span> FileOutputStream(targerPath);</span><br><span class="line">            ImageIO.write(buffImg, <span class="string">"png"</span>, os);</span><br><span class="line">            <span class="keyword">return</span> targerPath;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> != os)</span><br><span class="line">                    os.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 图片添加文字水印</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> srcImgPath 原图片地址 File</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> markContentColor 水印文字颜色</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> waterMarkContent 水印文字</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">mark</span><span class="params">(String srcImgPath,Color markContentColor, String waterMarkContent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//读取原图片信息</span></span><br><span class="line">            File srcImgFile = <span class="keyword">new</span> File(srcImgPath);</span><br><span class="line">            Image srcImg = ImageIO.read(srcImgFile);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//读取原图片高度、宽度</span></span><br><span class="line">            <span class="keyword">int</span> srcImgWidth = srcImg.getWidth(<span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">int</span> srcImgHeight = srcImg.getHeight(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//设置图片水印</span></span><br><span class="line">            BufferedImage bufImg = <span class="keyword">new</span> BufferedImage(srcImgWidth, srcImgHeight, BufferedImage.TYPE_INT_RGB);</span><br><span class="line">            Graphics2D g = bufImg.createGraphics();</span><br><span class="line">            g.drawImage(srcImg, <span class="number">0</span>, <span class="number">0</span>, srcImgWidth, srcImgHeight, <span class="keyword">null</span>);</span><br><span class="line">            Font font = <span class="keyword">new</span> Font(<span class="string">"宋体"</span>, Font.PLAIN, <span class="number">20</span>);</span><br><span class="line">            g.setColor(markContentColor);</span><br><span class="line"></span><br><span class="line">            g.setFont(font);</span><br><span class="line">            <span class="keyword">int</span> x = srcImgWidth - getWatermarkLength(waterMarkContent, g) - <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">int</span> y = srcImgHeight - <span class="number">3</span>;</span><br><span class="line">            g.drawString(waterMarkContent, x, y);</span><br><span class="line">            g.dispose();</span><br><span class="line">            <span class="comment">// 输出图片</span></span><br><span class="line">            String outImgPath = srcImgPath + <span class="string">"_txt_water.png"</span>;</span><br><span class="line">            FileOutputStream outImgStream = <span class="keyword">new</span> FileOutputStream(outImgPath);</span><br><span class="line">            ImageIO.write(bufImg, <span class="string">"jpg"</span>, outImgStream);</span><br><span class="line">            outImgStream.flush();</span><br><span class="line">            outImgStream.close();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> outImgPath;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取水印文字的长度</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> waterMarkContent</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> g</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getWatermarkLength</span><span class="params">(String waterMarkContent, Graphics2D g)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> g.getFontMetrics(g.getFont()).charsWidth(waterMarkContent.toCharArray(), <span class="number">0</span>, waterMarkContent.length());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="修改控制器、测试图片文字水印"><a href="#修改控制器、测试图片文字水印" class="headerlink" title="修改控制器、测试图片文字水印"></a>修改控制器、测试图片文字水印</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.pdfwatermark;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.io.FileUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PostMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.multipart.MultipartFile;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PdfWatermarkApi</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 文件上传控制器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> filenames 批量上传的文件集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostMapping</span>(value = <span class="string">"/pdf/watermark/upload"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">upload</span><span class="params">(MultipartFile[] filenames)</span> </span>&#123;</span><br><span class="line">        Long now = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (MultipartFile multipartFile : filenames) &#123;</span><br><span class="line">            <span class="comment">//打印数据</span></span><br><span class="line">            System.out.println(multipartFile.getOriginalFilename() + <span class="string">" FileSize:"</span> + multipartFile.getSize());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//指定本地的PDF文件路径以及名称</span></span><br><span class="line">                String pathname = PdfWatermarkConstants.BASE + now + <span class="string">"/"</span> + multipartFile.getOriginalFilename();</span><br><span class="line">                <span class="comment">//创建本地的PDF</span></span><br><span class="line">                File pdfFile = <span class="keyword">new</span> File(pathname);</span><br><span class="line">                <span class="comment">//将网络流 MultipartFile 转化为本地 PDF文件</span></span><br><span class="line">                FileUtils.copyInputStreamToFile(multipartFile.getInputStream(), pdfFile);</span><br><span class="line">                <span class="comment">//PDF转化为图片</span></span><br><span class="line">                List&lt;FileDTO&gt; imageDTOs = Pdf2Image.generate(pdfFile);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//图片水印后的图片</span></span><br><span class="line">                List&lt;FileDTO&gt; imageMarkDTOs = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">                <span class="comment">//打印日志输出语句</span></span><br><span class="line">                <span class="keyword">for</span> (FileDTO fileDTO : imageDTOs) &#123;</span><br><span class="line">                    System.out.println(pdfFile.getName() + <span class="string">" -&gt; PDF转化image："</span> + fileDTO.getIndex() + <span class="string">" 文件路径："</span> + fileDTO.getPath());</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//图片水印</span></span><br><span class="line">                    String markImage = ImageWatemark.markImage(<span class="string">"https://www.wwei.cn/yasuotu/images/logo.png"</span>, fileDTO.getPath(), <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//添加到图片水印后的图片集合</span></span><br><span class="line">                    FileDTO newFileDTO = <span class="keyword">new</span> FileDTO();</span><br><span class="line">                    newFileDTO.setPath(markImage);</span><br><span class="line">                    newFileDTO.setIndex(fileDTO.getIndex());</span><br><span class="line">                    imageMarkDTOs.add(newFileDTO);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//图片文字水印后的图片集合</span></span><br><span class="line">                List&lt;FileDTO&gt; imageTxtMarkDTOs = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">                <span class="comment">//打印日志输出语句</span></span><br><span class="line">                <span class="keyword">for</span> (FileDTO fileDTO : imageMarkDTOs) &#123;</span><br><span class="line">                    System.out.println(pdfFile.getName() + <span class="string">" -&gt; Image添加图片水印："</span> + fileDTO.getIndex() + <span class="string">" 文件路径："</span> + fileDTO.getPath());</span><br><span class="line"></span><br><span class="line">                    String txtMark = ImageWatemark.mark(fileDTO.getPath(), Color.BLUE, <span class="string">"水印文字"</span>);</span><br><span class="line">                    <span class="comment">//添加到图片水印后的图片集合</span></span><br><span class="line">                    FileDTO newFileDTO = <span class="keyword">new</span> FileDTO();</span><br><span class="line">                    newFileDTO.setPath(txtMark);</span><br><span class="line">                    newFileDTO.setIndex(fileDTO.getIndex());</span><br><span class="line">                    imageTxtMarkDTOs.add(newFileDTO);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//打印日志输出语句</span></span><br><span class="line">                <span class="keyword">for</span> (FileDTO fileDTO : imageTxtMarkDTOs) &#123;</span><br><span class="line">                    System.out.println(pdfFile.getName() + <span class="string">" -&gt; Image添加文字水印："</span> + fileDTO.getIndex() + <span class="string">" 文件路径："</span> + fileDTO.getPath());</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"这是等待生成的下载地址"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/image/hexo/image-20211115170219859.png" alt="image-20211115170219859"></p><h3 id="编写图片合并PDF代码"><a href="#编写图片合并PDF代码" class="headerlink" title="编写图片合并PDF代码"></a>编写图片合并PDF代码</h3><h4 id="新增Image2Pdf"><a href="#新增Image2Pdf" class="headerlink" title="新增Image2Pdf"></a>新增Image2Pdf</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.pdfwatermark;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.itextpdf.text.Document;</span><br><span class="line"><span class="keyword">import</span> com.itextpdf.text.Image;</span><br><span class="line"><span class="keyword">import</span> com.itextpdf.text.Rectangle;</span><br><span class="line"><span class="keyword">import</span> com.itextpdf.text.pdf.PdfWriter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.imageio.ImageIO;</span><br><span class="line"><span class="keyword">import</span> java.awt.image.BufferedImage;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Image2Pdf</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将图片集合合并成为PDF</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dataList</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> baseFileName</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">image2Pdf</span><span class="params">(List&lt;FileDTO&gt; dataList, String baseFileName)</span> </span>&#123;</span><br><span class="line">        String pdfPath = PdfWatermarkConstants.BASE_PDF + System.currentTimeMillis() + <span class="string">"/"</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建文件夹</span></span><br><span class="line">            <span class="keyword">new</span> File(pdfPath).mkdirs();</span><br><span class="line">            <span class="comment">//创建文件</span></span><br><span class="line">            pdfPath = pdfPath + baseFileName;</span><br><span class="line">            File file = <span class="keyword">new</span> File(pdfPath);</span><br><span class="line">            file.createNewFile();</span><br><span class="line">            FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(pdfPath);</span><br><span class="line">            <span class="comment">// 创建文档</span></span><br><span class="line">            Document doc = <span class="keyword">new</span> Document(<span class="keyword">null</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="comment">// 写入PDF文档</span></span><br><span class="line">            PdfWriter.getInstance(doc, fos);</span><br><span class="line">            <span class="comment">// 读取图片流</span></span><br><span class="line">            BufferedImage img = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 实例化图片</span></span><br><span class="line">            Image image = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 循环获取图片文件夹内的图片</span></span><br><span class="line">            <span class="keyword">for</span> (FileDTO fileDTO : dataList) &#123;</span><br><span class="line">                <span class="comment">//读取图片流</span></span><br><span class="line">                img = ImageIO.read(<span class="keyword">new</span> File(fileDTO.getPath()));</span><br><span class="line">                <span class="comment">//根据图片大小设置文档大小</span></span><br><span class="line">                doc.setPageSize(<span class="keyword">new</span> Rectangle(img.getWidth(), img.getHeight()));</span><br><span class="line">                <span class="comment">//实例化图片</span></span><br><span class="line">                image = Image.getInstance(fileDTO.getPath());</span><br><span class="line">                <span class="comment">//添加图片到文档</span></span><br><span class="line">                doc.open();</span><br><span class="line">                doc.add(image);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 关闭文档</span></span><br><span class="line">            doc.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> pdfPath;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="修改控制器、测试图片合并"><a href="#修改控制器、测试图片合并" class="headerlink" title="修改控制器、测试图片合并"></a>修改控制器、测试图片合并</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.pdfwatermark;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.io.FileUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PostMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.multipart.MultipartFile;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PdfWatermarkApi</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 文件上传控制器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> filenames 批量上传的文件集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostMapping</span>(value = <span class="string">"/pdf/watermark/upload"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">upload</span><span class="params">(MultipartFile[] filenames)</span> </span>&#123;</span><br><span class="line">        Long now = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (MultipartFile multipartFile : filenames) &#123;</span><br><span class="line">            <span class="comment">//打印数据</span></span><br><span class="line">            System.out.println(multipartFile.getOriginalFilename() + <span class="string">" FileSize:"</span> + multipartFile.getSize());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//指定本地的PDF文件路径以及名称</span></span><br><span class="line">                String pathname = PdfWatermarkConstants.BASE + now + <span class="string">"/"</span> + multipartFile.getOriginalFilename();</span><br><span class="line">                <span class="comment">//创建本地的PDF</span></span><br><span class="line">                File pdfFile = <span class="keyword">new</span> File(pathname);</span><br><span class="line">                <span class="comment">//将网络流 MultipartFile 转化为本地 PDF文件</span></span><br><span class="line">                FileUtils.copyInputStreamToFile(multipartFile.getInputStream(), pdfFile);</span><br><span class="line">                <span class="comment">//PDF转化为图片</span></span><br><span class="line">                List&lt;FileDTO&gt; imageDTOs = Pdf2Image.generate(pdfFile);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//图片水印后的图片</span></span><br><span class="line">                List&lt;FileDTO&gt; imageMarkDTOs = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">                <span class="comment">//打印日志输出语句</span></span><br><span class="line">                <span class="keyword">for</span> (FileDTO fileDTO : imageDTOs) &#123;</span><br><span class="line">                    System.out.println(pdfFile.getName() + <span class="string">" -&gt; PDF转化image："</span> + fileDTO.getIndex() + <span class="string">" 文件路径："</span> + fileDTO.getPath());</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//图片水印</span></span><br><span class="line">                    String markImage = ImageWatemark.markImage(<span class="string">"https://www.wwei.cn/yasuotu/images/logo.png"</span>, fileDTO.getPath(), <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//添加到图片水印后的图片集合</span></span><br><span class="line">                    FileDTO newFileDTO = <span class="keyword">new</span> FileDTO();</span><br><span class="line">                    newFileDTO.setPath(markImage);</span><br><span class="line">                    newFileDTO.setIndex(fileDTO.getIndex());</span><br><span class="line">                    imageMarkDTOs.add(newFileDTO);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//图片文字水印后的图片集合</span></span><br><span class="line">                List&lt;FileDTO&gt; imageTxtMarkDTOs = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">                <span class="comment">//打印日志输出语句</span></span><br><span class="line">                <span class="keyword">for</span> (FileDTO fileDTO : imageMarkDTOs) &#123;</span><br><span class="line">                    System.out.println(pdfFile.getName() + <span class="string">" -&gt; Image添加图片水印："</span> + fileDTO.getIndex() + <span class="string">" 文件路径："</span> + fileDTO.getPath());</span><br><span class="line"></span><br><span class="line">                    String txtMark = ImageWatemark.mark(fileDTO.getPath(), Color.BLUE, <span class="string">"水印文字"</span>);</span><br><span class="line">                    <span class="comment">//添加到图片水印后的图片集合</span></span><br><span class="line">                    FileDTO newFileDTO = <span class="keyword">new</span> FileDTO();</span><br><span class="line">                    newFileDTO.setPath(txtMark);</span><br><span class="line">                    newFileDTO.setIndex(fileDTO.getIndex());</span><br><span class="line">                    imageTxtMarkDTOs.add(newFileDTO);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//打印日志输出语句</span></span><br><span class="line">                <span class="keyword">for</span> (FileDTO fileDTO : imageTxtMarkDTOs) &#123;</span><br><span class="line">                    System.out.println(pdfFile.getName() + <span class="string">" -&gt; Image添加文字水印："</span> + fileDTO.getIndex() + <span class="string">" 文件路径："</span> + fileDTO.getPath());</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//将图片再次合并成为PDF</span></span><br><span class="line">                String image2Pdf = Image2Pdf.image2Pdf(imageTxtMarkDTOs, multipartFile.getOriginalFilename());</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">"水印后的原始PDF文件："</span> + image2Pdf);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"这是等待生成的下载地址"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/image/hexo/image-20211115173518934.png" alt="image-20211115173518934"></p><h3 id="编写PDF加密代码"><a href="#编写PDF加密代码" class="headerlink" title="编写PDF加密代码"></a>编写PDF加密代码</h3><h4 id="新增PdfEncrypt"><a href="#新增PdfEncrypt" class="headerlink" title="新增PdfEncrypt"></a>新增PdfEncrypt</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.pdfwatermark;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.itextpdf.text.pdf.PdfReader;</span><br><span class="line"><span class="keyword">import</span> com.itextpdf.text.pdf.PdfStamper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PdfEncrypt</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 新增pdf密码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> src</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> password</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">addAttachment</span><span class="params">(String src,String password)</span> </span>&#123;</span><br><span class="line">        String dest = src + <span class="string">"encrypt.pdf"</span>;</span><br><span class="line">        <span class="comment">//pdf权限，值为"PdfWriter.ALLOW_PRINTING"</span></span><br><span class="line">        <span class="keyword">int</span> permission = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            PdfReader reader = <span class="keyword">new</span> PdfReader(src);</span><br><span class="line">            PdfStamper stamper = <span class="keyword">new</span> PdfStamper(reader, <span class="keyword">new</span> FileOutputStream(dest));</span><br><span class="line">            <span class="comment">//设置密码文件打开密码文件编辑密码</span></span><br><span class="line">            <span class="comment">//final byte userPassword[], final byte ownerPassword[]</span></span><br><span class="line">            stamper.setEncryption(password.getBytes(),password.getBytes(), permission, <span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">//关闭流</span></span><br><span class="line">            stamper.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="修改控制器、测试PDF加密"><a href="#修改控制器、测试PDF加密" class="headerlink" title="修改控制器、测试PDF加密"></a>修改控制器、测试PDF加密</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.pdfwatermark;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.io.FileUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PostMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.multipart.MultipartFile;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PdfWatermarkApi</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 文件上传控制器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> filenames 批量上传的文件集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostMapping</span>(value = <span class="string">"/pdf/watermark/upload"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">upload</span><span class="params">(MultipartFile[] filenames)</span> </span>&#123;</span><br><span class="line">        Long now = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//最终的PDF集合</span></span><br><span class="line">        List&lt;FileDTO&gt; pdfDTOs = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (MultipartFile multipartFile : filenames) &#123;</span><br><span class="line">            <span class="comment">//打印数据</span></span><br><span class="line">            System.out.println(multipartFile.getOriginalFilename() + <span class="string">" FileSize:"</span> + multipartFile.getSize());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//指定本地的PDF文件路径以及名称</span></span><br><span class="line">                String pathname = PdfWatermarkConstants.BASE + now + <span class="string">"/"</span> + multipartFile.getOriginalFilename();</span><br><span class="line">                <span class="comment">//创建本地的PDF</span></span><br><span class="line">                File pdfFile = <span class="keyword">new</span> File(pathname);</span><br><span class="line">                <span class="comment">//将网络流 MultipartFile 转化为本地 PDF文件</span></span><br><span class="line">                FileUtils.copyInputStreamToFile(multipartFile.getInputStream(), pdfFile);</span><br><span class="line">                <span class="comment">//PDF转化为图片</span></span><br><span class="line">                List&lt;FileDTO&gt; imageDTOs = Pdf2Image.generate(pdfFile);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//图片水印后的图片</span></span><br><span class="line">                List&lt;FileDTO&gt; imageMarkDTOs = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">                <span class="comment">//打印日志输出语句</span></span><br><span class="line">                <span class="keyword">for</span> (FileDTO fileDTO : imageDTOs) &#123;</span><br><span class="line">                    System.out.println(pdfFile.getName() + <span class="string">" -&gt; PDF转化image："</span> + fileDTO.getIndex() + <span class="string">" 文件路径："</span> + fileDTO.getPath());</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//图片水印</span></span><br><span class="line">                    String markImage = ImageWatemark.markImage(<span class="string">"https://www.wwei.cn/yasuotu/images/logo.png"</span>, fileDTO.getPath(), <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//添加到图片水印后的图片集合</span></span><br><span class="line">                    FileDTO newFileDTO = <span class="keyword">new</span> FileDTO();</span><br><span class="line">                    newFileDTO.setPath(markImage);</span><br><span class="line">                    newFileDTO.setIndex(fileDTO.getIndex());</span><br><span class="line">                    imageMarkDTOs.add(newFileDTO);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//图片文字水印后的图片集合</span></span><br><span class="line">                List&lt;FileDTO&gt; imageTxtMarkDTOs = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">                <span class="comment">//打印日志输出语句</span></span><br><span class="line">                <span class="keyword">for</span> (FileDTO fileDTO : imageMarkDTOs) &#123;</span><br><span class="line">                    System.out.println(pdfFile.getName() + <span class="string">" -&gt; Image添加图片水印："</span> + fileDTO.getIndex() + <span class="string">" 文件路径："</span> + fileDTO.getPath());</span><br><span class="line"></span><br><span class="line">                    String txtMark = ImageWatemark.mark(fileDTO.getPath(), Color.BLUE, <span class="string">"水印文字"</span>);</span><br><span class="line">                    <span class="comment">//添加到图片水印后的图片集合</span></span><br><span class="line">                    FileDTO newFileDTO = <span class="keyword">new</span> FileDTO();</span><br><span class="line">                    newFileDTO.setPath(txtMark);</span><br><span class="line">                    newFileDTO.setIndex(fileDTO.getIndex());</span><br><span class="line">                    imageTxtMarkDTOs.add(newFileDTO);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//打印日志输出语句</span></span><br><span class="line">                <span class="keyword">for</span> (FileDTO fileDTO : imageTxtMarkDTOs) &#123;</span><br><span class="line">                    System.out.println(pdfFile.getName() + <span class="string">" -&gt; Image添加文字水印："</span> + fileDTO.getIndex() + <span class="string">" 文件路径："</span> + fileDTO.getPath());</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//将图片再次合并成为PDF</span></span><br><span class="line">                String image2Pdf = Image2Pdf.image2Pdf(imageTxtMarkDTOs, multipartFile.getOriginalFilename());</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">"水印后的原始PDF文件："</span> + image2Pdf);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//加密PDF</span></span><br><span class="line">                String encryptPath = PdfEncrypt.addAttachment(image2Pdf, <span class="string">"123456"</span>);</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">"PDF 加密后的文件："</span> + encryptPath);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"这是等待生成的下载地址"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/image/hexo/image-20211115182925599.png" alt="image-20211115182925599"></p><h3 id="编写多个PDF进行ZIP压缩代码"><a href="#编写多个PDF进行ZIP压缩代码" class="headerlink" title="编写多个PDF进行ZIP压缩代码"></a>编写多个PDF进行ZIP压缩代码</h3><h4 id="新增Zip"><a href="#新增Zip" class="headerlink" title="新增Zip"></a>新增Zip</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.pdfwatermark;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.zip.ZipEntry;</span><br><span class="line"><span class="keyword">import</span> java.util.zip.ZipOutputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Zip</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * pdf压缩为Zip</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fileDTOS</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">pdf2Zip</span><span class="params">(List&lt;FileDTO&gt; fileDTOS)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//设置zip的路径</span></span><br><span class="line">        String zipName = PdfWatermarkConstants.ZIP_PDF + System.currentTimeMillis();</span><br><span class="line">        ZipOutputStream zipos = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">new</span> File(zipName).mkdirs();</span><br><span class="line"></span><br><span class="line">            zipName = zipName + <span class="string">"/"</span> + System.currentTimeMillis() + <span class="string">".zip"</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">new</span> File(zipName).createNewFile();</span><br><span class="line"></span><br><span class="line">            zipos = <span class="keyword">new</span> ZipOutputStream(<span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(zipName)));</span><br><span class="line">            <span class="comment">//设置压缩方法</span></span><br><span class="line">            zipos.setMethod(ZipOutputStream.DEFLATED);</span><br><span class="line">            DataOutputStream os = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//循环将文件写入压缩流</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fileDTOS.size(); i++) &#123;</span><br><span class="line">                FileDTO fileDTO = fileDTOS.get(i);</span><br><span class="line">                String filename = fileDTO.getPath().substring(fileDTO.getPath().lastIndexOf(<span class="string">"/"</span>) + <span class="number">1</span>);</span><br><span class="line">                InputStream inputStream = <span class="keyword">new</span> FileInputStream(fileDTO.getPath());</span><br><span class="line">                <span class="comment">//添加ZipEntry，并ZipEntry中写入文件流</span></span><br><span class="line">                zipos.putNextEntry(<span class="keyword">new</span> ZipEntry(filename));</span><br><span class="line">                os = <span class="keyword">new</span> DataOutputStream(zipos);</span><br><span class="line">                <span class="keyword">byte</span>[] buff = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">10</span>];</span><br><span class="line">                <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">//循环读写</span></span><br><span class="line">                <span class="keyword">while</span> ((len = inputStream.read(buff)) &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">                    os.write(buff, <span class="number">0</span>, len);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//关闭此文件流</span></span><br><span class="line">                inputStream.close();</span><br><span class="line">                <span class="comment">//关闭当前ZIP项，并将流放置到写入的位置。下一个条目。</span></span><br><span class="line">                zipos.closeEntry();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//释放资源</span></span><br><span class="line">            os.flush();</span><br><span class="line">            os.close();</span><br><span class="line">            zipos.close();</span><br><span class="line">            zipos.close();</span><br><span class="line">            <span class="keyword">return</span> zipName;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="修改控制器、测试压缩PDF"><a href="#修改控制器、测试压缩PDF" class="headerlink" title="修改控制器、测试压缩PDF"></a>修改控制器、测试压缩PDF</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.pdfwatermark;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.io.FileUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PostMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.multipart.MultipartFile;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PdfWatermarkApi</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 文件上传控制器</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> filenames 批量上传的文件集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostMapping</span>(value = <span class="string">"/pdf/watermark/upload"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">upload</span><span class="params">(MultipartFile[] filenames)</span> </span>&#123;</span><br><span class="line">        Long now = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//最终的PDF集合</span></span><br><span class="line">        List&lt;FileDTO&gt; pdfDTOs = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (MultipartFile multipartFile : filenames) &#123;</span><br><span class="line">            <span class="comment">//打印数据</span></span><br><span class="line">            System.out.println(multipartFile.getOriginalFilename() + <span class="string">" FileSize:"</span> + multipartFile.getSize());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//指定本地的PDF文件路径以及名称</span></span><br><span class="line">                String pathname = PdfWatermarkConstants.BASE + now + <span class="string">"/"</span> + multipartFile.getOriginalFilename();</span><br><span class="line">                <span class="comment">//创建本地的PDF</span></span><br><span class="line">                File pdfFile = <span class="keyword">new</span> File(pathname);</span><br><span class="line">                <span class="comment">//将网络流 MultipartFile 转化为本地 PDF文件</span></span><br><span class="line">                FileUtils.copyInputStreamToFile(multipartFile.getInputStream(), pdfFile);</span><br><span class="line">                <span class="comment">//PDF转化为图片</span></span><br><span class="line">                List&lt;FileDTO&gt; imageDTOs = Pdf2Image.generate(pdfFile);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//图片水印后的图片</span></span><br><span class="line">                List&lt;FileDTO&gt; imageMarkDTOs = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">                <span class="comment">//打印日志输出语句</span></span><br><span class="line">                <span class="keyword">for</span> (FileDTO fileDTO : imageDTOs) &#123;</span><br><span class="line">                    System.out.println(pdfFile.getName() + <span class="string">" -&gt; PDF转化image："</span> + fileDTO.getIndex() + <span class="string">" 文件路径："</span> + fileDTO.getPath());</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//图片水印</span></span><br><span class="line">                    String markImage = ImageWatemark.markImage(<span class="string">"https://www.wwei.cn/yasuotu/images/logo.png"</span>, fileDTO.getPath(), <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//添加到图片水印后的图片集合</span></span><br><span class="line">                    FileDTO newFileDTO = <span class="keyword">new</span> FileDTO();</span><br><span class="line">                    newFileDTO.setPath(markImage);</span><br><span class="line">                    newFileDTO.setIndex(fileDTO.getIndex());</span><br><span class="line">                    imageMarkDTOs.add(newFileDTO);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//图片文字水印后的图片集合</span></span><br><span class="line">                List&lt;FileDTO&gt; imageTxtMarkDTOs = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">                <span class="comment">//打印日志输出语句</span></span><br><span class="line">                <span class="keyword">for</span> (FileDTO fileDTO : imageMarkDTOs) &#123;</span><br><span class="line">                    System.out.println(pdfFile.getName() + <span class="string">" -&gt; Image添加图片水印："</span> + fileDTO.getIndex() + <span class="string">" 文件路径："</span> + fileDTO.getPath());</span><br><span class="line"></span><br><span class="line">                    String txtMark = ImageWatemark.mark(fileDTO.getPath(), Color.BLUE, <span class="string">"水印文字"</span>);</span><br><span class="line">                    <span class="comment">//添加到图片水印后的图片集合</span></span><br><span class="line">                    FileDTO newFileDTO = <span class="keyword">new</span> FileDTO();</span><br><span class="line">                    newFileDTO.setPath(txtMark);</span><br><span class="line">                    newFileDTO.setIndex(fileDTO.getIndex());</span><br><span class="line">                    imageTxtMarkDTOs.add(newFileDTO);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//打印日志输出语句</span></span><br><span class="line">                <span class="keyword">for</span> (FileDTO fileDTO : imageTxtMarkDTOs) &#123;</span><br><span class="line">                    System.out.println(pdfFile.getName() + <span class="string">" -&gt; Image添加文字水印："</span> + fileDTO.getIndex() + <span class="string">" 文件路径："</span> + fileDTO.getPath());</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//将图片再次合并成为PDF</span></span><br><span class="line">                String image2Pdf = Image2Pdf.image2Pdf(imageTxtMarkDTOs, multipartFile.getOriginalFilename());</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">"水印后的原始PDF文件："</span> + image2Pdf);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//加密PDF</span></span><br><span class="line">                String encryptPath = PdfEncrypt.addAttachment(image2Pdf, <span class="string">"123456"</span>);</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">"PDF 加密后的文件："</span> + encryptPath);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="comment">//添加水印后的PDF</span></span><br><span class="line">                FileDTO pdfDTO = <span class="keyword">new</span> FileDTO();</span><br><span class="line">                pdfDTO.setPath(encryptPath);</span><br><span class="line">                pdfDTOs.add(pdfDTO);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//进行PDF 压缩</span></span><br><span class="line">        String pdf2Zip = Zip.pdf2Zip(pdfDTOs);</span><br><span class="line">        System.out.println(<span class="string">"PDF 经过ZIP压缩后的地址:"</span> + pdf2Zip);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"这是等待生成的下载地址"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/image/hexo/image-20211115183218283.png" alt="image-20211115183218283"></p><h3 id="编写前端页面提供下载功能"><a href="#编写前端页面提供下载功能" class="headerlink" title="编写前端页面提供下载功能"></a>编写前端页面提供下载功能</h3><h3 id="优化与建议"><a href="#优化与建议" class="headerlink" title="优化与建议"></a>优化与建议</h3><p>&emsp;&emsp;1.由于不断的进行图片、PDF间的转化、导致转化效率低下。</p><p>&emsp;&emsp;2.PDF如果有编辑密码那么这里还可以进行一个免密的处理。</p><p>&emsp;&emsp;3.图片分辨率过于大情况、导致产生的压缩包或者PDF过大。可以采用压缩生成后的图片进而压缩PDF。</p><p>&emsp;&emsp;4.由于所有的操作都是在本地完成、可以将最后的ZIP上传到文件服务中心,例如MINIO。</p><p>&emsp;&emsp;5.很多参数都是在代码里面写死的、那么我们可以再次抽取这些变量作为可配置的参数。</p><p>&emsp;&emsp;6.V2的版本中我们再次对V1的功能以及代码进行一个演进。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/image/hexo/image-20211115112836340.png&quot; alt=&quot;image-20211115112836340&quot;&gt;&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;此文章需要安装&lt;strong&gt;Gradle&lt;/strong&gt;环境、&lt;st
      
    
    </summary>
    
    
      <category term="java" scheme="https://blog.huhdcc.top/categories/java/"/>
    
      <category term="gradle" scheme="https://blog.huhdcc.top/categories/java/gradle/"/>
    
      <category term="SpringBoot" scheme="https://blog.huhdcc.top/categories/java/gradle/SpringBoot/"/>
    
    
      <category term="java" scheme="https://blog.huhdcc.top/tags/java/"/>
    
      <category term="gradle" scheme="https://blog.huhdcc.top/tags/gradle/"/>
    
      <category term="SpringBoot" scheme="https://blog.huhdcc.top/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>Elasticsearch、Kibana安装-Linux下docker单机环境版</title>
    <link href="https://blog.huhdcc.top/2021/10/25/15217/hub/"/>
    <id>https://blog.huhdcc.top/2021/10/25/15217/hub/</id>
    <published>2021-10-25T09:24:09.000Z</published>
    <updated>2021-10-25T09:24:44.485Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/image/hexo/image-20211025140334110.png" alt="image-20211025140334110"></p><h2 id="相关准备"><a href="#相关准备" class="headerlink" title="相关准备"></a>相关准备</h2><h5 id="1-centos7服务器"><a href="#1-centos7服务器" class="headerlink" title="1.centos7服务器"></a>1.centos7服务器</h5><h5 id="2-docker环境"><a href="#2-docker环境" class="headerlink" title="2.docker环境"></a>2.docker环境</h5><h3 id="安装elasticsearch"><a href="#安装elasticsearch" class="headerlink" title="安装elasticsearch"></a>安装elasticsearch</h3><h4 id="创建映射的配置文件"><a href="#创建映射的配置文件" class="headerlink" title="创建映射的配置文件"></a>创建映射的配置文件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /data/soft/elasticsearch/config</span><br><span class="line">mkdir -p /data/soft/elasticsearch/data</span><br><span class="line">mkdir -p /data/soft/elasticsearch/plugins</span><br><span class="line"></span><br><span class="line">vi /data/soft/elasticsearch/config/elasticsearch.yml</span><br><span class="line">vi /data/soft/elasticsearch/config/jvm.options</span><br></pre></td></tr></table></figure><h4 id="docker-pull"><a href="#docker-pull" class="headerlink" title="docker pull"></a>docker pull</h4><p><strong>需要注意的是、我们此处采用了挂载容器文件的方式。这样更加方便的修改配置文件。</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name elasticsearch  -p 9200:9200  -p 9300:9300 --net=host  -v /data/soft/elasticsearch/config/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml -v /data/soft/elasticsearch/config/jvm.options:/usr/share/elasticsearch/config/jvm.options  -v /data/soft/elasticsearch/data:/usr/share/elasticsearch/data -v /data/soft/elasticsearch/plugins:/usr/share/elasticsearch/plugins -e "discovery.type=single-node"  -e ES_JAVA_OPTS="-Xms1024m -Xmx2048m" elasticsearch:7.14.2</span><br></pre></td></tr></table></figure><h4 id="验证elasticsearch是否安装成功"><a href="#验证elasticsearch是否安装成功" class="headerlink" title="验证elasticsearch是否安装成功"></a>验证elasticsearch是否安装成功</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://localhost:9200</span><br></pre></td></tr></table></figure><p><img src="/image/hexo/image-20211025164514489.png" alt="image-20211025164514489"></p><h4 id="开启elasticsearch远程访问"><a href="#开启elasticsearch远程访问" class="headerlink" title="开启elasticsearch远程访问"></a>开启elasticsearch远程访问</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd /data/soft/elasticsearch/config</span><br><span class="line">vi elasticsearch.yml</span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加内容 http.host: 0.0.0.0 保存</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启docker容器</span></span><br><span class="line">docker restart elasticsearch</span><br></pre></td></tr></table></figure><p><img src="/image/hexo/image-20211025165119535.png" alt="image-20211025165119535"></p><h3 id="安装Kibana"><a href="#安装Kibana" class="headerlink" title="安装Kibana"></a>安装Kibana</h3><h4 id="创建映射的配置文件-1"><a href="#创建映射的配置文件-1" class="headerlink" title="创建映射的配置文件"></a>创建映射的配置文件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /data/soft/elasticsearch/kibana </span><br><span class="line">vi /data/soft/elasticsearch/kibana/kibana.yml</span><br></pre></td></tr></table></figure><h4 id="添加内容"><a href="#添加内容" class="headerlink" title="添加内容"></a>添加内容</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server.name: kibana</span><br><span class="line">server.host: "0"</span><br><span class="line">elasticsearch.hosts: [ "http://192.168.9.124:9200" ]</span><br><span class="line">xpack.monitoring.ui.container.elasticsearch.enabled: true</span><br><span class="line"><span class="meta">#</span><span class="bash"> elasticsearch.hosts根据自己实际IP处理</span></span><br></pre></td></tr></table></figure><h4 id="docker-pull-1"><a href="#docker-pull-1" class="headerlink" title="docker pull"></a>docker pull</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name kibana -p 5601:5601 --net&#x3D;host -v &#x2F;data&#x2F;soft&#x2F;elasticsearch&#x2F;kibana&#x2F;kibana.yml:&#x2F;usr&#x2F;share&#x2F;kibana&#x2F;config&#x2F;kibana.yml kibana:7.14.2</span><br></pre></td></tr></table></figure><h4 id="验证kibana是否安装成功"><a href="#验证kibana是否安装成功" class="headerlink" title="验证kibana是否安装成功"></a>验证kibana是否安装成功</h4><p><img src="/image/hexo/image-20211025172029076.png" alt="image-20211025172029076"></p><h3 id="Elasticsearch-amp-amp-Kibana-安装结束"><a href="#Elasticsearch-amp-amp-Kibana-安装结束" class="headerlink" title="Elasticsearch &amp;&amp; Kibana 安装结束"></a>Elasticsearch &amp;&amp; Kibana 安装结束</h3><p><strong>不熟悉docker的情况下:注意docker中的参数:–net=host、可以进一步的了解。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/image/hexo/image-20211025140334110.png&quot; alt=&quot;image-20211025140334110&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;相关准备&quot;&gt;&lt;a href=&quot;#相关准备&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://blog.huhdcc.top/categories/Linux/"/>
    
      <category term="Docker" scheme="https://blog.huhdcc.top/categories/Linux/Docker/"/>
    
      <category term="Elasticsearch" scheme="https://blog.huhdcc.top/categories/Linux/Docker/Elasticsearch/"/>
    
    
      <category term="Linux" scheme="https://blog.huhdcc.top/tags/Linux/"/>
    
      <category term="Docker" scheme="https://blog.huhdcc.top/tags/Docker/"/>
    
      <category term="Elasticsearch" scheme="https://blog.huhdcc.top/tags/Elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>Elasticsearch-Head、IK分词器安装-Linux下docker单机环境版</title>
    <link href="https://blog.huhdcc.top/2021/10/25/15217/hub/"/>
    <id>https://blog.huhdcc.top/2021/10/25/15217/hub/</id>
    <published>2021-10-25T09:24:09.000Z</published>
    <updated>2021-10-26T09:42:21.792Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/image/hexo/image-20211025140334110.png" alt="image-20211025140334110"></p><h3 id="安装elasticsearch-head"><a href="#安装elasticsearch-head" class="headerlink" title="安装elasticsearch-head"></a>安装elasticsearch-head</h3><h4 id="docker-run"><a href="#docker-run" class="headerlink" title="docker run"></a>docker run</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name elasticsearch-head -p 9100:9100 mobz/elasticsearch-head:5</span><br></pre></td></tr></table></figure><h4 id="验证elasticsearch-head是否安装成功"><a href="#验证elasticsearch-head是否安装成功" class="headerlink" title="验证elasticsearch-head是否安装成功"></a>验证elasticsearch-head是否安装成功</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.9.124:9100 # 根据自己实际ip进行访问</span><br></pre></td></tr></table></figure><p><img src="/image/hexo/image-20211026170249011.png" alt="image-20211026170249011"></p><h4 id="尝试连接Elasticsearch"><a href="#尝试连接Elasticsearch" class="headerlink" title="尝试连接Elasticsearch"></a>尝试连接Elasticsearch</h4><p><img src="/image/hexo/image-20211026170440161.png" alt="image-20211026170440161"></p><h4 id="解决集群健康值：未连接"><a href="#解决集群健康值：未连接" class="headerlink" title="解决集群健康值：未连接"></a>解决集群健康值：未连接</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 修改elasticsearch配置文件</span></span><br><span class="line">vi /data/soft/elasticsearch/config/elasticsearch.yml</span><br><span class="line"><span class="meta">#</span><span class="bash"> 追加内容</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http.cors.enabled: true</span><br><span class="line">http.cors.allow-origin: "*"</span><br><span class="line">http.cors.allow-methods: OPTIONS, HEAD, GET, POST, PUT, DELETE</span><br><span class="line">http.cors.allow-headers: "X-Requested-With, Content-Type, Content-Length, X-User"</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 重启docker elasticseaerch容器</span></span><br><span class="line">docker restart elasticsearch</span><br></pre></td></tr></table></figure><h4 id="连接成功"><a href="#连接成功" class="headerlink" title="连接成功"></a>连接成功</h4><p><img src="/image/hexo/image-20211026171323490.png" alt="image-20211026171323490"></p><h4 id="开启elasticsearch远程访问"><a href="#开启elasticsearch远程访问" class="headerlink" title="开启elasticsearch远程访问"></a>开启elasticsearch远程访问</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd /data/soft/elasticsearch/config</span><br><span class="line">vi elasticsearch.yml</span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加内容 http.host: 0.0.0.0 保存</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启docker容器</span></span><br><span class="line">docker restart elasticsearch</span><br></pre></td></tr></table></figure><p><img src="/image/hexo/image-20211025165119535.png" alt="image-20211025165119535"></p><h3 id="安装中文IK分词器"><a href="#安装中文IK分词器" class="headerlink" title="安装中文IK分词器"></a>安装中文IK分词器</h3><h4 id="查询对应的版本"><a href="#查询对应的版本" class="headerlink" title="查询对应的版本"></a>查询对应的版本</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/medcl/elasticsearch-analysis-ik/releases</span><br><span class="line"><span class="meta">#</span><span class="bash">本文采用7.14.2版本</span></span><br></pre></td></tr></table></figure><p><img src="/image/hexo/image-20211026171759731.png" alt="image-20211026171759731"></p><h4 id="下载IK分词器安装包"><a href="#下载IK分词器安装包" class="headerlink" title="下载IK分词器安装包"></a>下载IK分词器安装包</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 创建目录</span></span></span><br><span class="line">mkdir /data/soft/elasticsearch/plugins/ik</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 进入目录</span></span></span><br><span class="line">cd /data/soft/elasticsearch/plugins/ik</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 下载</span></span></span><br><span class="line">wget https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.14.2/elasticsearch-analysis-ik-7.14.2.zip</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 解压</span></span></span><br><span class="line">unzip elasticsearch-analysis-ik-7.14.2.zip</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 删除压缩包</span></span></span><br><span class="line">rm -rf elasticsearch-analysis-ik-7.14.2.zip</span><br></pre></td></tr></table></figure><p><strong>由于安装Elasticsearch的时候我们将plugins目录从容器内部挂载到了宿主机、所以我们不需要进入容器内部。</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 重启elasticsearch</span></span></span><br><span class="line">docker restart elasticsearch</span><br></pre></td></tr></table></figure><h4 id="使用postman添加数据"><a href="#使用postman添加数据" class="headerlink" title="使用postman添加数据"></a>使用postman添加数据</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># api</span></span></span><br><span class="line">http://192.168.9.124:9200/blog1/_analyze</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># json</span></span></span><br><span class="line">&#123;</span><br><span class="line">   "text":"sanmengcc yyds","tokenizer": "ik_max_word"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/image/hexo/image-20211026174139109.png" alt="image-20211026174139109"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/image/hexo/image-20211025140334110.png&quot; alt=&quot;image-20211025140334110&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;安装elasticsearch-head&quot;&gt;&lt;a href=&quot;#安装elasticse
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://blog.huhdcc.top/categories/Linux/"/>
    
      <category term="Docker" scheme="https://blog.huhdcc.top/categories/Linux/Docker/"/>
    
      <category term="Elasticsearch" scheme="https://blog.huhdcc.top/categories/Linux/Docker/Elasticsearch/"/>
    
    
      <category term="Linux" scheme="https://blog.huhdcc.top/tags/Linux/"/>
    
      <category term="Docker" scheme="https://blog.huhdcc.top/tags/Docker/"/>
    
      <category term="Elasticsearch" scheme="https://blog.huhdcc.top/tags/Elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>平时常见所需的SQL积累(MySQL)</title>
    <link href="https://blog.huhdcc.top/2021/10/22/63396/hub/"/>
    <id>https://blog.huhdcc.top/2021/10/22/63396/hub/</id>
    <published>2021-10-22T05:39:21.000Z</published>
    <updated>2021-10-22T06:35:18.822Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/image/hexo/image-20211022133817250.png" alt="image-20211022133817250"></p><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><h4 id="1-多字段去除重复保留ID最小的一条"><a href="#1-多字段去除重复保留ID最小的一条" class="headerlink" title="1.多字段去除重复保留ID最小的一条"></a>1.多字段去除重复保留ID最小的一条</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM table_name_a</span><br><span class="line">WHERE (field_a, field_b) IN (</span><br><span class="line">SELECT field_a, field_b</span><br><span class="line">FROM (</span><br><span class="line">SELECT field_a, field_b</span><br><span class="line">FROM table_name_A</span><br><span class="line">GROUP BY field_a, field_b</span><br><span class="line">HAVING COUNT(*) &gt; 1</span><br><span class="line">) tableA</span><br><span class="line">)</span><br><span class="line">AND id NOT IN (</span><br><span class="line">SELECT id</span><br><span class="line">FROM (</span><br><span class="line">SELECT MIN(id) AS id</span><br><span class="line">FROM table_name_A</span><br><span class="line">GROUP BY field_a, field_b</span><br><span class="line">HAVING COUNT(*) &gt; 1</span><br><span class="line">) tableB</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><h2 id="插入-创建"><a href="#插入-创建" class="headerlink" title="插入/创建"></a>插入/创建</h2><h3 id="1-根据查询的结果集插入到新表"><a href="#1-根据查询的结果集插入到新表" class="headerlink" title="1.根据查询的结果集插入到新表"></a>1.根据查询的结果集插入到新表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO table_name_b (field_a, field_b)</span><br><span class="line">SELECT field_a, field_b</span><br><span class="line">FROM table_name_a</span><br></pre></td></tr></table></figure><h3 id="2-创建备份表-表结构"><a href="#2-创建备份表-表结构" class="headerlink" title="2.创建备份表(表结构)"></a>2.创建备份表(表结构)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE new_table_name LIKE old_table_name;</span><br></pre></td></tr></table></figure><h3 id="3-创建备份表-表结构-数据"><a href="#3-创建备份表-表结构-数据" class="headerlink" title="3.创建备份表(表结构+数据)"></a>3.创建备份表(表结构+数据)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE new_table_name </span><br><span class="line">SELECT [field_a,field_b... | *] FROM old_table_name;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/image/hexo/image-20211022133817250.png&quot; alt=&quot;image-20211022133817250&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;删除&quot;&gt;&lt;a href=&quot;#删除&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
    
      <category term="工具" scheme="https://blog.huhdcc.top/categories/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="MySQL" scheme="https://blog.huhdcc.top/categories/%E5%B7%A5%E5%85%B7/MySQL/"/>
    
      <category term="数据库" scheme="https://blog.huhdcc.top/categories/%E5%B7%A5%E5%85%B7/MySQL/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="MySQL" scheme="https://blog.huhdcc.top/tags/MySQL/"/>
    
      <category term="数据库" scheme="https://blog.huhdcc.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>支付系列-01-技术选型</title>
    <link href="https://blog.huhdcc.top/2021/07/15/52943/hub/"/>
    <id>https://blog.huhdcc.top/2021/07/15/52943/hub/</id>
    <published>2021-07-15T06:57:52.000Z</published>
    <updated>2021-07-15T08:02:21.608Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/image/hexo/image-20210715145717436.png" alt="image-20210715145717436"></p><h3 id="支付体系来源"><a href="#支付体系来源" class="headerlink" title="支付体系来源"></a>支付体系来源</h3><p>&emsp;&emsp;目的是接入支付宝、微信支付，完成业务内的支付。同时也并不是为了单一的支付功能而接入支付体系，由于saas平台，同时也是属于多租户、多机构、多应用概念的平台，自然也逃避不了支付中心的独立。搭建一个独立的支付中心、同时为多个机构、多个租户提供支付服务。提供聚合的支付方式，简单化平台内部用户与机构支付手续流程。</p><p>&emsp;&emsp;由平台提供统一的支付账号、也支持各商家、机构自己可以申请自己的支付、可以很简单的完成自己内部的支付配置。并且平台内的对接并不需要如同第三方的支付一样需要一写手续费。更加方便的一个支付中心也就应运而生。</p><h3 id="支付开通的商家"><a href="#支付开通的商家" class="headerlink" title="支付开通的商家"></a>支付开通的商家</h3><p>&emsp;&emsp;1:支付宝</p><p>&emsp;&emsp;2.微信</p><p>&emsp;&emsp;暂时只考虑仅接入两个使用广泛的商家、以后如果增加支付的商家只需要按部就班的对接即可。很方便的一个叠加。</p><h3 id="支付设计"><a href="#支付设计" class="headerlink" title="支付设计"></a>支付设计</h3><p>&emsp;&emsp;1.商户</p><p>&emsp;&emsp;机构、应用、用户、租户等都可当作一个商户,例如一个租户下所有的支付都归属于这个租户，还可以租户下的机构也可以自己独立的进行支付、与租户的利益并无关系。商户的概念可以很灵活的处理任意一个层级的支付利益关系。</p><p><img src="/image/hexo/image-20210715151935248.png" alt="image-20210715151935248"></p><p>&emsp;&emsp;2.支付渠道</p><p>&emsp;&emsp;每一个商户都应该有一个支付渠道的配置、例如支付宝、微信都可以算作一个渠道、某些商户只需要其中一个渠道即可。这样平台也可以更细粒度的控制支付。</p><p><img src="/image/hexo/image-20210715151952294.png" alt="image-20210715151952294"></p><p>3.支付订单与子订单</p><p>&emsp;&emsp;任何一笔支付请求都应该对应一笔订单。那么一笔订单可能涉及了多个商家的订单，例如退款的时候应该只是退款某一笔订单、或者全部订单。那么也就会产生了子订单的一个关系，否则无法进行多个商家间的自定义退款。此问题的产生也就是一次支付、多次退款产生出来的。</p><p><img src="/image/hexo/image-20210715151921871.png" alt="image-20210715151921871"></p><p>4.支付通知</p><p>&emsp;&emsp;任何一笔订单在支付完成以后、第三方支付商家会执行一次支付成功的回调通知，由于是支付中心级别的，那么我们的支付通知肯定是要进行一个存储，然后对己方的系统服务进行一个自己实现的通知广播。那么实际上第三方商家的回调我们只需要接收一次即可。</p><p><img src="/image/hexo/image-20210715152514288.png" alt="image-20210715152514288"></p><p>5.支付退款</p><p>&emsp;&emsp;一笔订单可能经过多次退款，那么支付退款和支付订单之间应该一对多的关系。</p><p><img src="/image/hexo/image-20210715152612932.png" alt="image-20210715152612932"></p><p>&emsp;&emsp;这样我们一个简易的支付中心的设计就完成了,既然是简易那么很多细节的功能我并没有设计进去、仅仅是满足V1.0版本的需要，并且需要快速开发。那么后续的细节问题我们在下个版本再去逐步实现。</p><h3 id="对接方式"><a href="#对接方式" class="headerlink" title="对接方式"></a>对接方式</h3><p>&emsp;&emsp;1.对内提供服务间的rpc统一调用接口</p><p>&emsp;&emsp;2.对外提供第三方间的http统一调用接口（此版本不做实现）</p><p>&emsp;&emsp;3.平台内的系统需要对接支付接口、并且暴露出自己系统的http的接口。具体的支付业务各不相同、那么具体的业务实现由各自系统去进行实现。并且还需提供标准的统一回调接口，由支付中心进行下发支付成功的支付。</p><p>&emsp;&emsp;4.系统需要自己实现补偿机制。</p><h3 id="支付中心接口标准-rpc"><a href="#支付中心接口标准-rpc" class="headerlink" title="支付中心接口标准-rpc"></a>支付中心接口标准-rpc</h3><p>&emsp;&emsp;1.统一支付下单接口</p><p>&emsp;&emsp;2.通知支付订单查询结果接口</p><p>&emsp;&emsp;3.支付回调接口</p><p>&emsp;&emsp;4.支付回调二阶段提交接口</p><p>&emsp;&emsp;5.统一支付退款接口</p><p>&emsp;&emsp;以上五个接口即可满足系统接入支付中心。支付中心需要针对rpc的接口调用实现加密、鉴权、幂等。</p><h3 id="系统接口标准-http"><a href="#系统接口标准-http" class="headerlink" title="系统接口标准-http"></a>系统接口标准-http</h3><p>&emsp;&emsp;1.提供标准的支付、退款、查询等接口</p><p>&emsp;&emsp;2.支付、退款等涉及金额操作的接口、需要对接口进行幂等、日志记录等严格的控制、审查。</p><h3 id="对接的支付方式"><a href="#对接的支付方式" class="headerlink" title="对接的支付方式"></a>对接的支付方式</h3><p>&emsp;&emsp;小程序支付、二维码支付、app支付、H5支付。</p><h3 id="支付中心设计"><a href="#支付中心设计" class="headerlink" title="支付中心设计"></a>支付中心设计</h3><p>&emsp;&emsp;1.调用时、应当采用策略模版方式。由模板方法制定规则、对每一种接口进行规则定义。统一的校验、以及各自的校验。策略应该采用holder模式、使用注解的方式把每一种支付的方式注册到holder中。实现动态的一个调用、统一的入口。（这里以支付为例、实际上每一种对接的接口都应该按此标准进行实现）</p><p>&emsp;&emsp;2.针对重要的方法、需要对请求参数，响应参数进行一个原封不动的一个记录。日志记录由于需要另一个日志服务进行处理、因此此处不对其进行一个详细的描述。</p><p>&emsp;&emsp;3.针对每一笔订单都需要进行校验、还需要处理支付方式的转变。可能支付订单生成的过程中由支付宝转变为了微信支付，此时编码需要注意订单支付渠道的转变。</p><p>&emsp;&emsp;4.支付通知由于第三方会进行多次推送、我们需要保存任意一次推送即可。然后我们内部再使用死信队列的方式针对内部系统进行二次通知的效果、同时内部系统收到支付通过的时候，也需要将处理的结果进行一个二阶段提交、否则支付中心也将再次进行一个补偿机制的推送。</p><p>&emsp;&emsp;5.整体的流程大致没有什么问题、毕竟作为一个简易的支付中心已经能够满足基本的需求。接下来将从头到尾的不断解析支付中心的演变之路。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/image/hexo/image-20210715145717436.png&quot; alt=&quot;image-20210715145717436&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;支付体系来源&quot;&gt;&lt;a href=&quot;#支付体系来源&quot; class=&quot;headerlink
      
    
    </summary>
    
    
      <category term="JAVA" scheme="https://blog.huhdcc.top/categories/JAVA/"/>
    
      <category term="支付" scheme="https://blog.huhdcc.top/categories/JAVA/%E6%94%AF%E4%BB%98/"/>
    
    
      <category term="JAVA" scheme="https://blog.huhdcc.top/tags/JAVA/"/>
    
      <category term="设计模式" scheme="https://blog.huhdcc.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="支付" scheme="https://blog.huhdcc.top/tags/%E6%94%AF%E4%BB%98/"/>
    
  </entry>
  
  <entry>
    <title>SSR更新以及YouTube下载服务</title>
    <link href="https://blog.huhdcc.top/2021/07/12/27227/hub/"/>
    <id>https://blog.huhdcc.top/2021/07/12/27227/hub/</id>
    <published>2021-07-12T03:16:09.000Z</published>
    <updated>2021-07-13T04:07:09.393Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/image/hexo/image-20210712111556924.png" alt="image-20210712111556924"></p><h2 id="SSR节点更新"><a href="#SSR节点更新" class="headerlink" title="SSR节点更新"></a>SSR节点更新</h2><p>【2021-07-13】</p><p>香港阿里云节点：ssr://NDcuMjQyLjEwOS4yMjg6MTAwMDM6YXV0aF9zaGExX3Y0OmFlcy0xMjgtY3RyOnBsYWluOllXUnRhVzQ</p><h2 id="YouTube下载服务"><a href="#YouTube下载服务" class="headerlink" title="YouTube下载服务"></a>YouTube下载服务</h2><p>&emsp;&emsp;<a href="http://47.242.109.228:8080/youtubeDown.html" target="_blank" rel="noopener">http://47.242.109.228:8080/youtubeDown.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/image/hexo/image-20210712111556924.png&quot; alt=&quot;image-20210712111556924&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;SSR节点更新&quot;&gt;&lt;a href=&quot;#SSR节点更新&quot; class=&quot;headerli
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://blog.huhdcc.top/categories/Linux/"/>
    
      <category term="Shell" scheme="https://blog.huhdcc.top/categories/Linux/Shell/"/>
    
    
      <category term="工具" scheme="https://blog.huhdcc.top/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="Linux" scheme="https://blog.huhdcc.top/tags/Linux/"/>
    
      <category term="Shell" scheme="https://blog.huhdcc.top/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>hadoop集群模式搭建-基础版</title>
    <link href="https://blog.huhdcc.top/2021/03/31/15217/hub/"/>
    <id>https://blog.huhdcc.top/2021/03/31/15217/hub/</id>
    <published>2021-03-31T12:33:09.000Z</published>
    <updated>2021-04-01T00:37:19.539Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/image/hexo/image-20210331203322676.png" alt="image-20210331203322676"></p><p>&emsp;&emsp;本篇内容需要有<strong>Linux</strong>以及基本的<strong>Java</strong>的基础知识。</p><h2 id="相关准备"><a href="#相关准备" class="headerlink" title="相关准备"></a>相关准备</h2><h3 id="服务器准备"><a href="#服务器准备" class="headerlink" title="服务器准备"></a>服务器准备</h3><p>&emsp;&emsp;这里使用<strong>WINDOWS</strong>的电脑,使用VM开启三台<strong>Centos7</strong>的服务器。我们使用<strong>Xshell</strong>进行链接，链接之前请确保虚拟机的网络正常。</p><p><img src="/../image/hexo/image-20210331204205335.png" alt="image-20210331204205335"></p><p>&emsp;&emsp;大多数的虚拟机镜像并不完整，请一定要检查相关的指令依赖是否拥有，如果还没有下载则先安装好相关的依赖环境后再执行以下的操作步骤。</p><p><img src="/../image/hexo/image-20210331211656008.png" alt="image-20210331211656008"></p><h3 id="节点属性"><a href="#节点属性" class="headerlink" title="节点属性"></a>节点属性</h3><p>&emsp;&emsp;节点之间的关系。</p><table><thead><tr><th>主机名称</th><th>IP</th><th>节点</th></tr></thead><tbody><tr><td>centos1.com</td><td>192.168.25.128</td><td>Master</td></tr><tr><td>centos2.com</td><td>192.168.9.52</td><td>Slave</td></tr><tr><td>centos3.com</td><td>192.168.9.51</td><td>Slave</td></tr></tbody></table><h3 id="JDK的安装以及hosts文件的配置"><a href="#JDK的安装以及hosts文件的配置" class="headerlink" title="JDK的安装以及hosts文件的配置"></a>JDK的安装以及hosts文件的配置</h3><p>&emsp;&emsp;本文需要一定的<strong>Java</strong>基础、所以此处忽略掉<strong>JDK</strong>的安装，针对<strong>JDK</strong>我采用的依旧是1.8的版本。然后修改三台节点上的<strong>hosts</strong>配置。并且修改主机名称为上面列表的名称。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">192.168.25.128  centos1.com</span><br><span class="line">192.168.9.52centos2.com</span><br><span class="line">192.168.9.51centos3.com</span><br></pre></td></tr></table></figure><h3 id="SSH处理"><a href="#SSH处理" class="headerlink" title="SSH处理"></a>SSH处理</h3><p>&emsp;&emsp;先在<strong>Master</strong>的节点服务器生成<strong>SSH</strong>的私钥与公钥。特别说明此处需要配置三台服务器的主机名称(我们拷贝是通过服务器主机名称进行操作的)。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /root/.ssh/</span><br><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;拷贝到其他两个<strong>Slave</strong>节点。执行以下脚本会提示输入服务器密码。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh-copy-id centos2.com</span><br><span class="line">ssh-copy-id centos3.com</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;测试<strong>Master</strong>服务器连接<strong>Slave</strong>服务器。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh centos2.com</span><br><span class="line">ssh centos3.com</span><br></pre></td></tr></table></figure><p><img src="/../image/hexo/image-20210331224531817.png" alt="image-20210331224531817"></p><h3 id="下载hadoop"><a href="#下载hadoop" class="headerlink" title="下载hadoop"></a>下载hadoop</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://archive.apache.org/dist/hadoop/core/hadoop-2.7.2/</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们这里使用2.7.2的版本进行搭建。我们在将最后的安装包上传到<strong>/data</strong>目录。这里可以使用<strong>Xftp</strong>工具进行上传，我采用<strong>rz</strong>命令进行上传。</p><p><img src="/../image/hexo/image-20210331230113624.png" alt="image-20210331230113624"></p><h2 id="hadoop的安装"><a href="#hadoop的安装" class="headerlink" title="hadoop的安装"></a>hadoop的安装</h2><h3 id="Master节点"><a href="#Master节点" class="headerlink" title="Master节点"></a>Master节点</h3><h4 id="删除doc"><a href="#删除doc" class="headerlink" title="删除doc"></a>删除doc</h4><p>&emsp;&emsp;此处为你安装<strong>hadoop</strong>的位置。我的为<strong>/data/hadoop-2.7.2</strong>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf /data/hadoop-2.7.2/share/doc/*</span><br></pre></td></tr></table></figure><h4 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/profile</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在尾部加上环境变量。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export HADOOP_HOME=/data/hadoop-2.7.2</span><br><span class="line">export PATH=$PATH:$HADOOP_HOME/bin</span><br></pre></td></tr></table></figure><h4 id="刷新环境变量"><a href="#刷新环境变量" class="headerlink" title="刷新环境变量"></a>刷新环境变量</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure><h4 id="修改hadoop配置"><a href="#修改hadoop配置" class="headerlink" title="修改hadoop配置"></a>修改hadoop配置</h4><p>&emsp;&emsp;进入配置目录。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /data/hadoop-2.7.2/etc/hadoop</span><br></pre></td></tr></table></figure><h5 id="修改hadoop-env-sh"><a href="#修改hadoop-env-sh" class="headerlink" title="修改hadoop-env.sh"></a>修改hadoop-env.sh</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 修改JAVA_HOME 这个为你的JDK安装目录</span></span><br><span class="line"></span><br><span class="line">export JAVA_HOME = /data/jdk1.8.0_221</span><br></pre></td></tr></table></figure><h5 id="修改core-site-xml"><a href="#修改core-site-xml" class="headerlink" title="修改core-site.xml"></a>修改core-site.xml</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi core-site.xml</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 修改configuration节点 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 指定HDFSnamenode通信地址 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>fs.defaultFS<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://centos1.com:9000<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 指定hadoop存储路径 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hadoop.tmp.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 根据自己的安装hadoop的路径配置 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>/data/hadoop-2.7.2/etc/hadoop/tmp<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="修改hdfs-site-xml"><a href="#修改hdfs-site-xml" class="headerlink" title="修改hdfs-site.xml"></a>修改hdfs-site.xml</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi hdfs-site.xml</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 修改configuration节点 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 设置namenode的http通讯地址 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.http-address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>centos1.com:50070<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 设置secondarynamenode的http通讯地址 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.secondary.http-address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>centos2.com:50090<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 设置namenode存放路径 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.name.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>/data/hadoop-2.7.2/etc/hadoop/name<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 设置hdfs副本数量 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.replication<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>2<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 设置datanode存放路径 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.datanode.data.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">value</span>&gt;</span>/data/hadoop-2.7.2/etc/hadoop/data<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="修改mapred-site-xml"><a href="#修改mapred-site-xml" class="headerlink" title="修改mapred-site.xml"></a>修改mapred-site.xml</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mv mapred-site.xml.template mapred-site.xml</span><br><span class="line">vi mapred-site.xml</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 修改configuration节点 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.framework.name<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>yarn<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="修改yarn-site-xml"><a href="#修改yarn-site-xml" class="headerlink" title="修改yarn-site.xml"></a>修改yarn-site.xml</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi yarn-site.xml</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 修改configuration节点 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 设置 resourcemanager --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.hostname<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>centos1.com<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- reducer方式mapreduce_shuffle --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.aux-services<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>mapreduce_shuffle<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.aux-services.mapreduce.shuffle.class<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">value</span>&gt;</span>org.apache.hadoop.mapred.ShuffleHandler<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="修改slaves"><a href="#修改slaves" class="headerlink" title="修改slaves"></a>修改slaves</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi slaves</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 修改为以下内容</span></span><br><span class="line">centos1.com</span><br><span class="line">centos2.com</span><br></pre></td></tr></table></figure><h5 id="新建masters文件"><a href="#新建masters文件" class="headerlink" title="新建masters文件"></a>新建masters文件</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">touch masters</span><br><span class="line">vi masters</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 新增为以下内容</span></span><br><span class="line">centos1.com</span><br></pre></td></tr></table></figure><h5 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir data name tmp</span><br></pre></td></tr></table></figure><h3 id="Slaves节点"><a href="#Slaves节点" class="headerlink" title="Slaves节点"></a>Slaves节点</h3><h4 id="拷贝环境变量"><a href="#拷贝环境变量" class="headerlink" title="拷贝环境变量"></a>拷贝环境变量</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scp /etc/profile root@centos2.com:/etc/</span><br><span class="line">scp /etc/profile root@centos3.com:/etc/</span><br></pre></td></tr></table></figure><h2 id="拷贝hadoop"><a href="#拷贝hadoop" class="headerlink" title="拷贝hadoop"></a>拷贝hadoop</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scp -r /data/hadoop-2.7.2 root@centos2.com:/data/</span><br><span class="line">scp -r /data/hadoop-2.7.2 root@centos3.com:/data/</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;分别在两个<strong>Slaves</strong>节点服务器进行刷新环境配置操作。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><h3 id="初始化namenode"><a href="#初始化namenode" class="headerlink" title="初始化namenode"></a>初始化namenode</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/hdfs namenode -format</span><br></pre></td></tr></table></figure><h3 id="启动hadoop"><a href="#启动hadoop" class="headerlink" title="启动hadoop"></a>启动hadoop</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh /data/hadoop-2.7.2/sbin/start-all.sh</span><br></pre></td></tr></table></figure><h3 id="停止hadoop"><a href="#停止hadoop" class="headerlink" title="停止hadoop"></a>停止hadoop</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh /data/hadoop-2.7.2/sbin/stop-add.sh</span><br></pre></td></tr></table></figure><h3 id="检查master"><a href="#检查master" class="headerlink" title="检查master"></a>检查master</h3><p><img src="/image/hexo/image-20210401011033746.png" alt="image-20210401011033746"></p><h3 id="检查slaves"><a href="#检查slaves" class="headerlink" title="检查slaves"></a>检查slaves</h3><p><img src="/image/hexo/image-20210401011056586.png" alt="image-20210401011056586"></p><h3 id="检查hdfs"><a href="#检查hdfs" class="headerlink" title="检查hdfs"></a>检查hdfs</h3><p><img src="/image/hexo/image-20210401011127700.png" alt="image-20210401011127700"></p><h3 id="检查yarn"><a href="#检查yarn" class="headerlink" title="检查yarn"></a>检查yarn</h3><p><img src="/image/hexo/image-20210401011207620.png" alt="image-20210401011207620"></p><h2 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h2><p>&emsp;&emsp;到此为止<strong>hadoop</strong>的基础集群版环境已经搭建完成。</p><p>&emsp;&emsp;虚拟机安装的centos系统存在各种依赖问题、请尽量使用完整一点的镜像进行搭建。在最后浏览器测试的时候需要注意centos的系统的防火墙的开放。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/image/hexo/image-20210331203322676.png&quot; alt=&quot;image-20210331203322676&quot;&gt;&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;本篇内容需要有&lt;strong&gt;Linux&lt;/strong&gt;以及基本的&lt;s
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://blog.huhdcc.top/categories/Linux/"/>
    
      <category term="Java" scheme="https://blog.huhdcc.top/categories/Linux/Java/"/>
    
      <category term="Hadoop" scheme="https://blog.huhdcc.top/categories/Linux/Java/Hadoop/"/>
    
    
      <category term="Linux" scheme="https://blog.huhdcc.top/tags/Linux/"/>
    
      <category term="Java" scheme="https://blog.huhdcc.top/tags/Java/"/>
    
      <category term="Hadoop" scheme="https://blog.huhdcc.top/tags/Hadoop/"/>
    
  </entry>
  
  <entry>
    <title>SSR教程以及锐速安装(阿里云应用服务器)</title>
    <link href="https://blog.huhdcc.top/2021/03/30/27227/hub/"/>
    <id>https://blog.huhdcc.top/2021/03/30/27227/hub/</id>
    <published>2021-03-30T15:27:09.000Z</published>
    <updated>2021-03-31T06:30:08.934Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/image/hexo/image-20210330233108125.png" alt="image-20210330233108125"></p><p>&emsp;&emsp;本篇内容需要有<strong>Linux</strong>以及基本的<strong>Shell</strong>的基础知识。</p><h2 id="服务器的购买"><a href="#服务器的购买" class="headerlink" title="服务器的购买"></a>服务器的购买</h2><p>&emsp;&emsp;由于国内的防火墙原因、导致我们无法连上国外的网站,例如<strong>谷歌</strong>等。所以我们的服务的选用均为境外的服务器。这个有多种途径可以购买,我们采用最简单的<strong>阿里云</strong>平台进行购买。</p><h3 id="注册并完成相关认证进行购买"><a href="#注册并完成相关认证进行购买" class="headerlink" title="注册并完成相关认证进行购买"></a>注册并完成相关认证进行购买</h3><p>&emsp;&emsp;1.这里提供<a href="https://www.aliyun.com" target="_blank" rel="noopener">官方网站</a>的地址,可以使用支付宝等完成认证。</p><p>&emsp;&emsp;2.可以选择<a href="https://common-buy.aliyun.com/?spm=5176.10173289.101.1.4e802e77nohSdk&commodityCode=swas&regionId=cn-hongkong" target="_blank" rel="noopener">轻量应用型服务器</a>,选择合适的配置进行购买、这里需要选择境外的节点。例如：香港。</p><p><img src="/image/hexo/image-20210330233921224.png" alt="image-20210330233921224"></p><p>&emsp;&emsp;3.这里我选择了新加坡的节点,镜像需要选择Centos7.3,如果对这方面比较熟悉的可以自行选择。</p><h2 id="服务器的链接与配置"><a href="#服务器的链接与配置" class="headerlink" title="服务器的链接与配置"></a>服务器的链接与配置</h2><h3 id="链接服务器"><a href="#链接服务器" class="headerlink" title="链接服务器"></a>链接服务器</h3><p>&emsp;&emsp;1.当购买完成以后我们可以进入控制台看到如下界面。并且我们可以进入详情查看服务器的具体信息。</p><p><img src="/image/hexo/image-20210330234318779.png" alt="image-20210330234318779"></p><p>&emsp;&emsp;2.我们可以从详情里面看到服务器的<strong>IP</strong>、<strong>CPU</strong>等相关信息。我们链接服务器需要<strong>IP</strong>、<strong>端口</strong>、<strong>账号密码</strong>。由于我们购买服务器的时候没有设置密码、所以我们先将服务器的密码重置一下。</p><p><img src="/image/hexo/image-20210330234526455.png" alt="image-20210330234526455"></p><p>&emsp;&emsp;3.这样我们得到了服务器的基本参数,其中端口默认为<strong>22</strong>,账号默认为<strong>root</strong>。</p><h4 id="准备链接服务器的工具"><a href="#准备链接服务器的工具" class="headerlink" title="准备链接服务器的工具"></a>准备链接服务器的工具</h4><p>&emsp;&emsp;1.链接服务器的工具比较多,这里我们采用<strong>Xshell</strong>进行链接。</p><p>&emsp;&emsp;2.<a href="https://xshell.en.softonic.com" target="_blank" rel="noopener">官方网站</a></p><p>&emsp;&emsp;3.我们打开软件新建一个会话、输入相关的参数。</p><p><img src="/image/hexo/image-20210330234957526.png" alt="image-20210330234957526"></p><p><img src="/image/hexo/image-20210330235021668.png" alt="image-20210330235021668"></p><p>&emsp;&emsp;4.输入账号、为了方便我们选择记住用户名。</p><p><img src="/image/hexo/image-20210330235115009.png" alt="image-20210330235115009"></p><p>&emsp;&emsp;5.输入密码、同时我们也选择记住密码。</p><p><img src="/image/hexo/image-20210330235153648.png" alt="image-20210330235153648"></p><h2 id="搭建服务端SSR"><a href="#搭建服务端SSR" class="headerlink" title="搭建服务端SSR"></a>搭建服务端SSR</h2><h3 id="新建ssr文件夹"><a href="#新建ssr文件夹" class="headerlink" title="新建ssr文件夹"></a>新建ssr文件夹</h3><p><img src="/image/hexo/image-20210331084752975.png" alt="image-20210331084752975"></p><h3 id="下载、授权、执行脚本"><a href="#下载、授权、执行脚本" class="headerlink" title="下载、授权、执行脚本"></a>下载、授权、执行脚本</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -N –no-check-certificate https://raw.githubusercontent.com/ToyoDAdoubi/doubi/master/ssr.sh</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x ssr.sh</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash ssr.sh</span><br></pre></td></tr></table></figure><p><img src="/image/hexo/image-20210331085314722.png" alt="image-20210331085314722"></p><p>&emsp;&emsp;这里我们不进行任何的个性化设置、使用默认参数进行搭建。所以接下来我们可以开始一路回车。</p><p><img src="/image/hexo/image-20210331085425642.png" alt="image-20210331085425642"></p><p> &emsp;&emsp;我们仅需要静静的等待安装完成即可。完成安装我们可以得到如下的信息。我们复制这个SSR的链接导入的影梭里面进行链接。</p><p><img src="/image/hexo/image-20210331085520597.png" alt="image-20210331085520597"></p><h3 id="设置服务器防火墙"><a href="#设置服务器防火墙" class="headerlink" title="设置服务器防火墙"></a>设置服务器防火墙</h3><p><img src="/image/hexo/image-20210331085943927.png" alt="image-20210331085943927"></p><p>&emsp;&emsp;在阿里云服务器控制台进行防火墙的开放。</p><p><img src="/image/hexo/image-20210331085812025.png" alt="image-20210331085812025"></p><p>&emsp;&emsp;至此SSR搭建完毕。</p><h2 id="锐速的安装"><a href="#锐速的安装" class="headerlink" title="锐速的安装"></a>锐速的安装</h2><p>&emsp;&emsp;执行脚本、同样一路回车即可，当内核更换完成后服务器会自行重启。我们重新再次链接。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget --no-check-certificate -O rskernel.sh https://raw.githubusercontent.com/uxh/awesome-linux-tools/master/rskernel_2.sh &amp;&amp; bash rskernel.sh</span><br></pre></td></tr></table></figure><p><img src="/image/hexo/image-20210331090425997.png" alt="image-20210331090425997"></p><p>&emsp;&emsp;我们继续执行脚本,并且一路回车。静静等待安装完成。出现以下图片则安装完毕。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install net-tools -y &amp;&amp; wget --no-check-certificate -O appex.sh https://raw.githubusercontent.com/uxh/serverSpeeder_Install/master/appex.sh &amp;&amp; bash appex.sh install</span><br></pre></td></tr></table></figure><p><img src="/image/hexo/image-20210331090637491.png" alt="image-20210331090637491"></p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>&emsp;&emsp;SSR也存在封掉IP的风险，如果一旦封掉那么我们可以阿里云的费用模块进行退款，然后重新购买服务器进行搭建。科学上网、且行且珍惜。</p><p>&emsp;&emsp;以防脚本失效这里备份一下上面用到的<a href="https://sanmeng.lanzous.com/iCDxVnhv55g" target="_blank" rel="noopener">所有脚本</a>。以及<a href="https://sanmeng.lanzous.com/iSwU7nhv8dc" target="_blank" rel="noopener">客户端</a>的链接软件。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/image/hexo/image-20210330233108125.png&quot; alt=&quot;image-20210330233108125&quot;&gt;&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;本篇内容需要有&lt;strong&gt;Linux&lt;/strong&gt;以及基本的&lt;s
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://blog.huhdcc.top/categories/Linux/"/>
    
      <category term="Shell" scheme="https://blog.huhdcc.top/categories/Linux/Shell/"/>
    
    
      <category term="工具" scheme="https://blog.huhdcc.top/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="Linux" scheme="https://blog.huhdcc.top/tags/Linux/"/>
    
      <category term="Shell" scheme="https://blog.huhdcc.top/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>多线程高阶-53-Phaser详解</title>
    <link href="https://blog.huhdcc.top/2020/07/25/56893/hub/"/>
    <id>https://blog.huhdcc.top/2020/07/25/56893/hub/</id>
    <published>2020-07-25T06:01:55.000Z</published>
    <updated>2020-07-25T12:02:46.581Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/image/hexo/image-20200725140252917.png" alt="image-20200725140252917"></p><p>&emsp;&emsp;<strong>Phaser</strong>是从JDK1.7引入的，更多的是对<strong>CountDownLatch</strong>和<strong>CyclicBarrier</strong>功能的增强。更加的类似一个多阶段的栅栏。它可以在初始化时设定参与线程的数量，也可以在中途注册或者注销参与者，若达到的参与数量满足栅栏的条件后会进行阶段性的升级(advance)。</p><h2 id="Phaser流程"><a href="#Phaser流程" class="headerlink" title="Phaser流程"></a>Phaser流程</h2><p><img src="/image/hexo/image-20200725151806247.png" alt="image-20200725151806247"></p><h3 id="phaser"><a href="#phaser" class="headerlink" title="phaser"></a>phaser</h3><p>&emsp;&emsp;<strong>phaser</strong>初始阶段为0，当所有的<strong>phaser</strong>参与者都到达后<strong>phaser</strong>值进行递增，最大为<code>Integer.MAX_VALUE</code>，再次归零。</p><h3 id="parties"><a href="#parties" class="headerlink" title="parties"></a>parties</h3><p>&emsp;&emsp;主要指的是执行任务的线程。可以初始化指定参与者的数量也可以中途<code>register</code>,<code>bulkRegister</code>,<code>arriveAndDeregister</code>进行注册或者注销参与者。</p><h4 id="arrive-advance"><a href="#arrive-advance" class="headerlink" title="arrive/advance"></a>arrive/advance</h4><p>&emsp;&emsp;<strong>Phaser</strong>注册完<strong>parties</strong>后，参与者的初始状态为<code>unarrived</code>，如果参与者达到(<code>arrvie</code>)当前的阶段后，状态会变成<code>arrvied</code>。当阶段的参与数满足条件后，阶段就会进阶(<code>advance</code>)。</p><h3 id="Termination"><a href="#Termination" class="headerlink" title="Termination"></a>Termination</h3><p>&emsp;&emsp;当前<strong>Phaser</strong>对象达到了终止状态。</p><h3 id="Tiering"><a href="#Tiering" class="headerlink" title="Tiering"></a>Tiering</h3><p>&emsp;&emsp;可以通过构造函数指定当前的<strong>Phaser</strong>对象的父节点，主要还是出现了大量的<strong>parties</strong>内部的操作会导致整体的性能急剧下降，通过<strong>Tiering</strong>减小同步操作所带来的性能开销。</p><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><h3 id="案例一（控制时机）"><a href="#案例一（控制时机）" class="headerlink" title="案例一（控制时机）"></a>案例一（控制时机）</h3><p>&emsp;&emsp;值得注意的是<code>arriveAndAwaitAdvance</code>方法是不响应中断的，如果某个正在执行的线程被打断也不会返回或者抛出异常信息，那么整个程序就会陷入继续等待。<code>awaitAdvanceInterruptibly</code>则可以解决该问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Phaser phaser = <span class="keyword">new</span> Phaser();</span><br><span class="line">    IntStream.rangeClosed(<span class="number">1</span>,<span class="number">10</span>)</span><br><span class="line">        .forEach(i-&gt;&#123;</span><br><span class="line">            phaser.register();</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> PhaserWorker(phaser), <span class="string">"T-"</span> + i).start();</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PhaserWorker</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Phaser phaser;</span><br><span class="line"></span><br><span class="line">    PhaserWorker(Phaser phaser) &#123;</span><br><span class="line">        <span class="keyword">this</span>.phaser = phaser;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">": 执行完任务，当前phase ="</span> + phaser.arriveAndAwaitAdvance() + <span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="案例二（开关）"><a href="#案例二（开关）" class="headerlink" title="案例二（开关）"></a>案例二（开关）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Phaser phaser = <span class="keyword">new</span> Phaser(<span class="number">1</span>);</span><br><span class="line">    IntStream.rangeClosed(<span class="number">1</span>,<span class="number">10</span>)</span><br><span class="line">        .forEach(i-&gt;&#123;</span><br><span class="line">            phaser.register();</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> SwitchWorker(phaser), <span class="string">"T-"</span> + i).start();</span><br><span class="line">        &#125;);</span><br><span class="line">    System.out.println(<span class="string">"请输入命令，打开程序开关"</span>);</span><br><span class="line">    BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">    reader.readLine();</span><br><span class="line">    phaser.arriveAndDeregister();</span><br><span class="line">    System.out.println(<span class="string">"程序开关已打开，开始执行任务......"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SwitchWorker</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Phaser phaser;</span><br><span class="line"></span><br><span class="line">    SwitchWorker(Phaser phaser) &#123;</span><br><span class="line">        <span class="keyword">this</span>.phaser = phaser;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">": 执行完任务，当前phase ="</span> + phaser.arriveAndAwaitAdvance() + <span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="案例三（控制任务执行次数）"><a href="#案例三（控制任务执行次数）" class="headerlink" title="案例三（控制任务执行次数）"></a>案例三（控制任务执行次数）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//线程任务最多执行的次数</span></span><br><span class="line">    <span class="keyword">int</span> repeats = <span class="number">5</span>;</span><br><span class="line">    Phaser phaser = <span class="keyword">new</span> Phaser()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="comment">//重写onAdvance，当最后一个参与者到达时，会触发onAdvance方法</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">onAdvance</span><span class="params">(<span class="keyword">int</span> phase, <span class="keyword">int</span> registeredParties)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"---------------PHASE["</span> + phase + <span class="string">"],Parties["</span> + registeredParties + <span class="string">"] ---------------"</span>);</span><br><span class="line">            <span class="keyword">return</span> phase + <span class="number">1</span> &gt;= repeats  || registeredParties == <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    IntStream.rangeClosed(<span class="number">1</span>,<span class="number">10</span>)</span><br><span class="line">        .forEach(i-&gt;&#123;</span><br><span class="line">            phaser.register();</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> CountWorker(phaser), <span class="string">"T-"</span> + i).start();</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CountWorker</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Phaser phaser;</span><br><span class="line"></span><br><span class="line">    CountWorker(Phaser phaser) &#123;</span><br><span class="line">        <span class="keyword">this</span>.phaser = phaser;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!phaser.isTerminated()) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">": 执行完任务，当前phase ="</span> + phaser.arriveAndAwaitAdvance() + <span class="string">""</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="案例四（任务分层）"><a href="#案例四（任务分层）" class="headerlink" title="案例四（任务分层）"></a>案例四（任务分层）</h3><p><img src="/image/hexo/image-20200725170019018.png" alt="image-20200725170019018"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>  TASKS_PER_PHASER = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> phaseToTerminate = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">final</span> Phaser phaser = <span class="keyword">new</span> Phaser() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">onAdvance</span><span class="params">(<span class="keyword">int</span> phase, <span class="keyword">int</span> registeredParties)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"onAdvance:"</span> + phase);</span><br><span class="line">            <span class="keyword">return</span> phase == phaseToTerminate || registeredParties == <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">final</span> Task tasks[] = <span class="keyword">new</span> Task[<span class="number">10</span>];</span><br><span class="line">    build(tasks, <span class="number">0</span>, tasks.length, phaser);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tasks.length; i++) &#123;</span><br><span class="line">        System.out.println(<span class="string">"starting thread, id: "</span> + i);</span><br><span class="line">        <span class="keyword">final</span> Thread thread = <span class="keyword">new</span> Thread(tasks[i]);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归分层，</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">(Task[] tasks, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi, Phaser ph)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果任务的数量超过每一层的phaser的阈值TASKS_PER_PHASER，则要继续分层</span></span><br><span class="line">    <span class="keyword">if</span> (hi - lo &gt; TASKS_PER_PHASER) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = lo; i &lt; hi; i += TASKS_PER_PHASER) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = Math.min(i + TASKS_PER_PHASER, hi);</span><br><span class="line">            build(tasks, i, j, <span class="keyword">new</span> Phaser(ph));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = lo; i &lt; hi; ++i) &#123;</span><br><span class="line">            tasks[i] = <span class="keyword">new</span> Task(i, ph);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Phaser phaser;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Task</span><span class="params">(<span class="keyword">int</span> id, Phaser phaser)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.phaser = phaser;</span><br><span class="line">        <span class="keyword">this</span>.phaser.register();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!phaser.isTerminated()) &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" Thread run :"</span> + phaser.getPhase() + <span class="string">", id: "</span> + <span class="keyword">this</span>.id);</span><br><span class="line">            phaser.arriveAndAwaitAdvance();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Phaser相关API"><a href="#Phaser相关API" class="headerlink" title="Phaser相关API"></a>Phaser相关API</h2><h3 id="类声明"><a href="#类声明" class="headerlink" title="类声明"></a>类声明</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Phaser</span></span></span><br></pre></td></tr></table></figure><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//无参构造</span></span><br><span class="line">Phaser p1 = <span class="keyword">new</span> Phaser();</span><br><span class="line"></span><br><span class="line"><span class="comment">//指定parties</span></span><br><span class="line">Phaser p2 = <span class="keyword">new</span> Phaser(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//指定父Phaser</span></span><br><span class="line">Phaser p3 = <span class="keyword">new</span> Phaser(p1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//指定父Phaser同时指定当前parties</span></span><br><span class="line">Phaser p4 = <span class="keyword">new</span> Phaser(p1,<span class="number">1</span>);</span><br></pre></td></tr></table></figure><h3 id="相关属性"><a href="#相关属性" class="headerlink" title="相关属性"></a>相关属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 状态变量，用于存储当前阶段phase、参与者数parties、未完成的参与者数unarrived_count</span></span><br><span class="line"><span class="comment">//state的最高位是一个标志位，1表示Phaser的线程同步已经结束，0表示线程同步正在进行</span></span><br><span class="line"><span class="comment">//state的低32位中，低16位表示没有到达的线程数量，高16位表示Parties值</span></span><br><span class="line"><span class="comment">//state的高32位除了最高位之外的其他31位表示的Phaser的phase，可以理解为第多少次同步（从0开始计算）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> state;</span><br><span class="line"><span class="comment">// 最多可以有多少个参与者，即每个阶段最多有多少个任务</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>  MAX_PARTIES     = <span class="number">0xffff</span>;</span><br><span class="line"><span class="comment">// 最多可以有多少阶段</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>  MAX_PHASE       = Integer.MAX_VALUE;</span><br><span class="line"><span class="comment">// 参与者数量的偏移量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>  PARTIES_SHIFT   = <span class="number">16</span>;</span><br><span class="line"><span class="comment">// 当前阶段的偏移量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>  PHASE_SHIFT     = <span class="number">32</span>;</span><br><span class="line"><span class="comment">// 未完成的参与者数的掩码，低16位</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>  UNARRIVED_MASK  = <span class="number">0xffff</span>;      <span class="comment">// to mask ints</span></span><br><span class="line"><span class="comment">// 参与者数，中间16位</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> PARTIES_MASK    = <span class="number">0xffff0000L</span>; <span class="comment">// to mask longs</span></span><br><span class="line"><span class="comment">// counts的掩码，counts等于参与者数和未完成的参与者数的'|'操作</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> COUNTS_MASK     = <span class="number">0xffffffffL</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> TERMINATION_BIT = <span class="number">1L</span> &lt;&lt; <span class="number">63</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 一次一个参与者完成</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>  ONE_ARRIVAL     = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 增加减少参与者时使用</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>  ONE_PARTY       = <span class="number">1</span> &lt;&lt; PARTIES_SHIFT;</span><br><span class="line"><span class="comment">// 减少参与者时使用</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>  ONE_DEREGISTER  = ONE_ARRIVAL|ONE_PARTY;</span><br><span class="line"><span class="comment">// 没有参与者时使用</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>  EMPTY           = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h4 id="register"><a href="#register" class="headerlink" title="register"></a>register</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Phaser phaser = <span class="keyword">new</span> Phaser();</span><br><span class="line"></span><br><span class="line"><span class="comment">//register</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1.添加一个需要同步的线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">phaser.register();</span><br></pre></td></tr></table></figure><h4 id="bulkRegister"><a href="#bulkRegister" class="headerlink" title="bulkRegister"></a>bulkRegister</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//bulkRegister</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1.添加parties个需要同步的线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">phaser.bulkRegister(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><h4 id="arrive"><a href="#arrive" class="headerlink" title="arrive"></a>arrive</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//arrive</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1.等待其他线程的到达</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">phaser.arrive();</span><br></pre></td></tr></table></figure><h4 id="arriveAndDeregister"><a href="#arriveAndDeregister" class="headerlink" title="arriveAndDeregister"></a>arriveAndDeregister</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//arriveAndDeregister</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1.不等待其他线程的到达，立即返回</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">phaser.arriveAndDeregister();</span><br></pre></td></tr></table></figure><h4 id="arriveAndAwaitAdvance"><a href="#arriveAndAwaitAdvance" class="headerlink" title="arriveAndAwaitAdvance"></a>arriveAndAwaitAdvance</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//arriveAndAwaitAdvance</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1.等到下一个phase开始再返回</span></span><br><span class="line"><span class="comment"> * 2.类似doArrive方法+awaitAdvance方法的功能</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">phaser.arriveAndAwaitAdvance();</span><br></pre></td></tr></table></figure><h4 id="awaitAdvance"><a href="#awaitAdvance" class="headerlink" title="awaitAdvance"></a>awaitAdvance</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//awaitAdvance</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1.线程等待，任务线程不可中断，不处理异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">phaser.awaitAdvance(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><h4 id="awaitAdvanceInterruptibly"><a href="#awaitAdvanceInterruptibly" class="headerlink" title="awaitAdvanceInterruptibly"></a>awaitAdvanceInterruptibly</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//awaitAdvanceInterruptibly</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1.线程等待，可以中断</span></span><br><span class="line"><span class="comment"> * 2.有用超时的机制</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">phaser.awaitAdvanceInterruptibly(<span class="number">1</span>);</span><br><span class="line">phaser.awaitAdvanceInterruptibly(<span class="number">1</span>, <span class="number">1</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure><h2 id="Phaser源码解析"><a href="#Phaser源码解析" class="headerlink" title="Phaser源码解析"></a>Phaser源码解析</h2><p><img src="/image/hexo/image-20200725183216245.png" alt="image-20200725183216245"></p><h3 id="Phaser几种节点"><a href="#Phaser几种节点" class="headerlink" title="Phaser几种节点"></a>Phaser几种节点</h3><h4 id="孤立的Phaser结点"><a href="#孤立的Phaser结点" class="headerlink" title="孤立的Phaser结点"></a>孤立的Phaser结点</h4><p><img src="/image/hexo/image-20200725184044267.png" alt="image-20200725184044267"></p><h4 id="非孤立的Phaser叶子节点"><a href="#非孤立的Phaser叶子节点" class="headerlink" title="非孤立的Phaser叶子节点"></a>非孤立的Phaser叶子节点</h4><p><img src="/image/hexo/image-20200725184121902.png" alt="image-20200725184121902"></p><h3 id="内部数据结构QNode"><a href="#内部数据结构QNode" class="headerlink" title="内部数据结构QNode"></a>内部数据结构QNode</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//无锁栈、Treiber Stack栈顶指针</span></span><br><span class="line"><span class="comment">//使用Treiber Stack结构保存等待线程</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//phase奇偶切换交替使用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//偶数栈</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicReference&lt;QNode&gt; evenQ;</span><br><span class="line"></span><br><span class="line"><span class="comment">//奇数栈</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicReference&lt;QNode&gt; oddQ;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//主要保存了线程信息和Phaser对象信息</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">QNode</span> <span class="keyword">implements</span> <span class="title">ForkJoinPool</span>.<span class="title">ManagedBlocker</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Phaser phaser;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> phase;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> interruptible;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> timed;</span><br><span class="line">    <span class="keyword">boolean</span> wasInterrupted;</span><br><span class="line">    <span class="keyword">long</span> nanos;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> deadline;</span><br><span class="line">    <span class="keyword">volatile</span> Thread thread; <span class="comment">// nulled to cancel wait</span></span><br><span class="line">    QNode next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Phaser</span><span class="params">(Phaser parent, <span class="keyword">int</span> parties)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parties &gt;&gt;&gt; PARTIES_SHIFT != <span class="number">0</span>)</span><br><span class="line">        <span class="comment">//parties右移16为如果不为0：parties超出了最大的限制数量</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal number of parties"</span>);</span><br><span class="line">    <span class="comment">//定义初始值</span></span><br><span class="line">    <span class="keyword">int</span> phase = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.parent = parent;</span><br><span class="line">    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//存在父节点</span></span><br><span class="line">        <span class="comment">//当前Phaser的root节点指向父节点的root</span></span><br><span class="line">        <span class="keyword">final</span> Phaser root = parent.root;</span><br><span class="line">        <span class="keyword">this</span>.root = root;</span><br><span class="line">        <span class="comment">//共用父节点的无锁栈</span></span><br><span class="line">        <span class="keyword">this</span>.evenQ = root.evenQ;</span><br><span class="line">        <span class="keyword">this</span>.oddQ = root.oddQ;</span><br><span class="line">        <span class="comment">//向父类注册一个参与者</span></span><br><span class="line">        <span class="keyword">if</span> (parties != <span class="number">0</span>)</span><br><span class="line">            phase = parent.doRegister(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//root节点指向自身</span></span><br><span class="line">        <span class="keyword">this</span>.root = <span class="keyword">this</span>;</span><br><span class="line">        <span class="comment">//创建新的无锁栈结构</span></span><br><span class="line">        <span class="keyword">this</span>.evenQ = <span class="keyword">new</span> AtomicReference&lt;QNode&gt;();</span><br><span class="line">        <span class="keyword">this</span>.oddQ = <span class="keyword">new</span> AtomicReference&lt;QNode&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//更新同步state状态值</span></span><br><span class="line">    <span class="keyword">this</span>.state = (parties == <span class="number">0</span>) ? (<span class="keyword">long</span>)EMPTY :</span><br><span class="line">        ((<span class="keyword">long</span>)phase &lt;&lt; PHASE_SHIFT) |</span><br><span class="line">        ((<span class="keyword">long</span>)parties &lt;&lt; PARTIES_SHIFT) |</span><br><span class="line">        ((<span class="keyword">long</span>)parties);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="register-1"><a href="#register-1" class="headerlink" title="register"></a>register</h3><p>&emsp;&emsp;1.增加一个参与者：同时增加<code>parties</code>和<code>unarrived</code>两个参数，对应<code>state</code>的中16位和低16位。</p><p>&emsp;&emsp;2.第一个参与者：尝试原子性更新<code>state</code>，成功则退出。</p><p>&emsp;&emsp;3.不是第一个参与者:检测是否在执行<code>onAdvance</code>方法，等待其执行完毕（自旋+入队等待的方式），否则尝试原子更新<code>state</code>，成功则退出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注册一个参与者</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">register</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> doRegister(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">doRegister</span><span class="params">(<span class="keyword">int</span> registrations)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//计算state需要加的值</span></span><br><span class="line">    <span class="comment">//同时增加parties和unarrived</span></span><br><span class="line">    <span class="keyword">long</span> adjust = ((<span class="keyword">long</span>)registrations &lt;&lt; PARTIES_SHIFT) | registrations;</span><br><span class="line">    <span class="comment">//获取当前的父节点</span></span><br><span class="line">    <span class="keyword">final</span> Phaser parent = <span class="keyword">this</span>.parent;</span><br><span class="line">    <span class="keyword">int</span> phase;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//获取state值</span></span><br><span class="line">        <span class="keyword">long</span> s = (parent == <span class="keyword">null</span>) ? state : reconcileState();</span><br><span class="line">        <span class="comment">//state的低32位：parties和unarrived的值</span></span><br><span class="line">        <span class="keyword">int</span> counts = (<span class="keyword">int</span>)s;</span><br><span class="line">        <span class="comment">//parties值</span></span><br><span class="line">        <span class="keyword">int</span> parties = counts &gt;&gt;&gt; PARTIES_SHIFT;</span><br><span class="line">        <span class="comment">//unarrived值</span></span><br><span class="line">        <span class="keyword">int</span> unarrived = counts &amp; UNARRIVED_MASK;</span><br><span class="line">        <span class="comment">//检测是否溢出</span></span><br><span class="line">        <span class="keyword">if</span> (registrations &gt; MAX_PARTIES - parties)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(badRegister(s));</span><br><span class="line">        <span class="comment">//计算当前阶段的phase</span></span><br><span class="line">        phase = (<span class="keyword">int</span>)(s &gt;&gt;&gt; PHASE_SHIFT);</span><br><span class="line">        <span class="keyword">if</span> (phase &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//不是第一个参与者，退出循环</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (counts != EMPTY) &#123;                  <span class="comment">// not 1st registration</span></span><br><span class="line">            <span class="keyword">if</span> (parent == <span class="keyword">null</span> || reconcileState() == s) &#123;</span><br><span class="line">                <span class="keyword">if</span> (unarrived == <span class="number">0</span>)             <span class="comment">// wait out advance</span></span><br><span class="line">                    <span class="comment">//unarrived == 0 表示正在执行advance方法等待执行完毕</span></span><br><span class="line">                    root.internalAwaitAdvance(phase, <span class="keyword">null</span>);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (UNSAFE.compareAndSwapLong(<span class="keyword">this</span>, stateOffset,</span><br><span class="line">                                                   s, s + adjust))</span><br><span class="line">                    <span class="comment">//尝试CAS修改state的值，增加之前计算的adjust</span></span><br><span class="line">                    <span class="comment">//修改成功则退出循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (parent == <span class="keyword">null</span>) &#123;              <span class="comment">// 1st root registration</span></span><br><span class="line">            <span class="comment">//第一个参与者</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//计算state值</span></span><br><span class="line">            <span class="keyword">long</span> next = ((<span class="keyword">long</span>)phase &lt;&lt; PHASE_SHIFT) | adjust;</span><br><span class="line">            <span class="comment">//尝试CAS修改state的值，增加之前计算的adjust</span></span><br><span class="line">            <span class="comment">//修改成功则退出循环</span></span><br><span class="line">            <span class="keyword">if</span> (UNSAFE.compareAndSwapLong(<span class="keyword">this</span>, stateOffset, s, next))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//分层操作</span></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">               <span class="keyword">if</span> (state == s) &#123;</span><br><span class="line">                    <span class="comment">//向父类注册一个参与之</span></span><br><span class="line">                    phase = parent.doRegister(<span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">if</span> (phase &lt; <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">while</span> (!UNSAFE.compareAndSwapLong</span><br><span class="line">                           (<span class="keyword">this</span>, stateOffset, s,</span><br><span class="line">                            ((<span class="keyword">long</span>)phase &lt;&lt; PHASE_SHIFT) | adjust)) &#123;</span><br><span class="line">                        s = state;</span><br><span class="line">                        phase = (<span class="keyword">int</span>)(root.state &gt;&gt;&gt; PHASE_SHIFT);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> phase;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="internalAwaitAdvance"><a href="#internalAwaitAdvance" class="headerlink" title="internalAwaitAdvance"></a>internalAwaitAdvance</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//等待onAdvance方法执行完毕</span></span><br><span class="line"><span class="comment">//采用自旋方式</span></span><br><span class="line"><span class="comment">//自旋如果达到限制则当前线程加入队列，等待onAdvance方法执行完毕后唤醒线程</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">internalAwaitAdvance</span><span class="params">(<span class="keyword">int</span> phase, QNode node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//保证队列为空</span></span><br><span class="line">    releaseWaiters(phase-<span class="number">1</span>);          <span class="comment">// ensure old queue clean</span></span><br><span class="line">    <span class="keyword">boolean</span> queued = <span class="keyword">false</span>;           <span class="comment">// true when node is enqueued</span></span><br><span class="line">    <span class="keyword">int</span> lastUnarrived = <span class="number">0</span>;            <span class="comment">// to increase spins upon change</span></span><br><span class="line">    <span class="comment">//自旋的次数</span></span><br><span class="line">    <span class="keyword">int</span> spins = SPINS_PER_ARRIVAL;</span><br><span class="line">    <span class="keyword">long</span> s;</span><br><span class="line">    <span class="keyword">int</span> p;</span><br><span class="line">    <span class="comment">//检测当前阶段是否发生了变化</span></span><br><span class="line">    <span class="comment">//发送变化：进入下一阶段结束自旋</span></span><br><span class="line">    <span class="keyword">while</span> ((p = (<span class="keyword">int</span>)((s = state) &gt;&gt;&gt; PHASE_SHIFT)) == phase) &#123;</span><br><span class="line">        <span class="comment">//如果node为空，那么注册的时候传入为空</span></span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;    </span><br><span class="line">            <span class="comment">//计算unarrived</span></span><br><span class="line">            <span class="keyword">int</span> unarrived = (<span class="keyword">int</span>)s &amp; UNARRIVED_MASK;</span><br><span class="line">            <span class="comment">//unarrived变化则增加自旋次数</span></span><br><span class="line">            <span class="keyword">if</span> (unarrived != lastUnarrived &amp;&amp;</span><br><span class="line">                (lastUnarrived = unarrived) &lt; NCPU)</span><br><span class="line">                spins += SPINS_PER_ARRIVAL;</span><br><span class="line">            <span class="comment">//判断线程是否interrupted</span></span><br><span class="line">            <span class="keyword">boolean</span> interrupted = Thread.interrupted();</span><br><span class="line">            <span class="keyword">if</span> (interrupted || --spins &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//线程interrupted或者自旋次数达到限制</span></span><br><span class="line">                <span class="comment">//新建一个节点</span></span><br><span class="line">                node = <span class="keyword">new</span> QNode(<span class="keyword">this</span>, phase, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">                <span class="comment">//设置线程的wasInterrupted属性</span></span><br><span class="line">                node.wasInterrupted = interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (node.isReleasable()) <span class="comment">// done or aborted</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!queued) &#123; </span><br><span class="line">            <span class="comment">//节点入队</span></span><br><span class="line">            AtomicReference&lt;QNode&gt; head = (phase &amp; <span class="number">1</span>) == <span class="number">0</span> ? evenQ : oddQ;</span><br><span class="line">            QNode q = node.next = head.get();</span><br><span class="line">            <span class="keyword">if</span> ((q == <span class="keyword">null</span> || q.phase == phase) &amp;&amp;</span><br><span class="line">                (<span class="keyword">int</span>)(state &gt;&gt;&gt; PHASE_SHIFT) == phase) <span class="comment">// avoid stale enq</span></span><br><span class="line">                queued = head.compareAndSet(q, node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//当前线程进入阻塞</span></span><br><span class="line">                <span class="comment">//等待被唤醒</span></span><br><span class="line">                ForkJoinPool.managedBlock(node);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                node.wasInterrupted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//该线程由阻塞被唤醒</span></span><br><span class="line">    <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//重置节点中的线程</span></span><br><span class="line">        <span class="keyword">if</span> (node.thread != <span class="keyword">null</span>)</span><br><span class="line">            node.thread = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//判断线程的状态</span></span><br><span class="line">        <span class="keyword">if</span> (node.wasInterrupted &amp;&amp; !node.interruptible)</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        <span class="keyword">if</span> (p == phase &amp;&amp; (p = (<span class="keyword">int</span>)(state &gt;&gt;&gt; PHASE_SHIFT)) == phase)</span><br><span class="line">            <span class="keyword">return</span> abortWait(phase);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//唤醒当前节点等待的线程</span></span><br><span class="line">    releaseWaiters(phase);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="arriveAndAwaitAdvance-1"><a href="#arriveAndAwaitAdvance-1" class="headerlink" title="arriveAndAwaitAdvance"></a>arriveAndAwaitAdvance</h3><p>&emsp;&emsp;1.修改<code>state</code>中的<code>unarrived</code>的值-1</p><p>&emsp;&emsp;2.不是最后一个到达：调用<code>internalAwaitAdvance</code>进入自旋+线程入队等待的方式排队</p><p>&emsp;&emsp;3.最后一个到达：调用<code>onAdvance</code>方法，原子性修改<code>state</code>值为下一阶段的值，唤醒其他等待的线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当前线程当前的阶段执行完毕</span></span><br><span class="line"><span class="comment">//等待其他线程的当前完成当前阶段</span></span><br><span class="line"><span class="comment">//如果最后一个到达的线程，则执行onAdvance方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">arriveAndAwaitAdvance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Phaser root = <span class="keyword">this</span>.root;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//获取state</span></span><br><span class="line">        <span class="keyword">long</span> s = (root == <span class="keyword">this</span>) ? state : reconcileState();</span><br><span class="line">        <span class="comment">//计算phase</span></span><br><span class="line">        <span class="keyword">int</span> phase = (<span class="keyword">int</span>)(s &gt;&gt;&gt; PHASE_SHIFT);</span><br><span class="line">        <span class="keyword">if</span> (phase &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> phase;</span><br><span class="line">        <span class="comment">//获取unarrived和parties</span></span><br><span class="line">        <span class="keyword">int</span> counts = (<span class="keyword">int</span>)s;</span><br><span class="line">        <span class="keyword">int</span> unarrived = (counts == EMPTY) ? <span class="number">0</span> : (counts &amp; UNARRIVED_MASK);</span><br><span class="line">        <span class="keyword">if</span> (unarrived &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(badArrive(s));</span><br><span class="line">        <span class="comment">//尝试CAS修改state</span></span><br><span class="line">        <span class="keyword">if</span> (UNSAFE.compareAndSwapLong(<span class="keyword">this</span>, stateOffset, s,</span><br><span class="line">                                      s -= ONE_ARRIVAL)) &#123;</span><br><span class="line">            <span class="comment">//判断当前阶段是否最后一个线程到达</span></span><br><span class="line">            <span class="keyword">if</span> (unarrived &gt; <span class="number">1</span>)</span><br><span class="line">                <span class="comment">//不是：调用internalAwaitAdvance进入自旋+入队等待被唤醒</span></span><br><span class="line">                <span class="keyword">return</span> root.internalAwaitAdvance(phase, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (root != <span class="keyword">this</span>)</span><br><span class="line">                <span class="comment">//最后一个到达</span></span><br><span class="line">                <span class="keyword">return</span> parent.arriveAndAwaitAdvance();</span><br><span class="line">            <span class="comment">//n保留了state的中16位：parties</span></span><br><span class="line">            <span class="keyword">long</span> n = s &amp; PARTIES_MASK;</span><br><span class="line">            <span class="comment">//执行onAdvance</span></span><br><span class="line">            <span class="comment">//返回true:表示结束</span></span><br><span class="line">            <span class="keyword">int</span> nextUnarrived = (<span class="keyword">int</span>)n &gt;&gt;&gt; PARTIES_SHIFT;</span><br><span class="line">            <span class="keyword">if</span> (onAdvance(phase, nextUnarrived))</span><br><span class="line">                n |= TERMINATION_BIT;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nextUnarrived == <span class="number">0</span>)</span><br><span class="line">                n |= EMPTY;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">//n加上unarrived的值</span></span><br><span class="line">                n |= nextUnarrived;</span><br><span class="line">            <span class="comment">//下一阶段phase == 当前阶段+1</span></span><br><span class="line">            <span class="keyword">int</span> nextPhase = (phase + <span class="number">1</span>) &amp; MAX_PHASE;</span><br><span class="line">            n |= (<span class="keyword">long</span>)nextPhase &lt;&lt; PHASE_SHIFT;</span><br><span class="line">            <span class="comment">//CAS修改state</span></span><br><span class="line">            <span class="keyword">if</span> (!UNSAFE.compareAndSwapLong(<span class="keyword">this</span>, stateOffset, s, n))</span><br><span class="line">                <span class="keyword">return</span> (<span class="keyword">int</span>)(state &gt;&gt;&gt; PHASE_SHIFT);</span><br><span class="line">            <span class="comment">//唤醒其他的参与者进入下一个阶段</span></span><br><span class="line">            releaseWaiters(phase);</span><br><span class="line">            <span class="comment">//返回下一个阶段的phase值</span></span><br><span class="line">            <span class="keyword">return</span> nextPhase;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="awaitAdvance-1"><a href="#awaitAdvance-1" class="headerlink" title="awaitAdvance"></a>awaitAdvance</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">awaitAdvance</span><span class="params">(<span class="keyword">int</span> phase)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取当前的root</span></span><br><span class="line">    <span class="keyword">final</span> Phaser root = <span class="keyword">this</span>.root;</span><br><span class="line">    <span class="comment">//获取state</span></span><br><span class="line">    <span class="keyword">long</span> s = (root == <span class="keyword">this</span>) ? state : reconcileState();</span><br><span class="line">    <span class="comment">//检测传入的phase和当前的phase是否一致</span></span><br><span class="line">    <span class="keyword">int</span> p = (<span class="keyword">int</span>)(s &gt;&gt;&gt; PHASE_SHIFT);</span><br><span class="line">    <span class="keyword">if</span> (phase &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> phase;</span><br><span class="line">    <span class="keyword">if</span> (p == phase)</span><br><span class="line">        <span class="keyword">return</span> root.internalAwaitAdvance(phase, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="awaitAdvanceInterruptibly-1"><a href="#awaitAdvanceInterruptibly-1" class="headerlink" title="awaitAdvanceInterruptibly"></a>awaitAdvanceInterruptibly</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//增加中断异常</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">awaitAdvanceInterruptibly</span><span class="params">(<span class="keyword">int</span> phase)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Phaser root = <span class="keyword">this</span>.root;</span><br><span class="line">    <span class="keyword">long</span> s = (root == <span class="keyword">this</span>) ? state : reconcileState();</span><br><span class="line">    <span class="keyword">int</span> p = (<span class="keyword">int</span>)(s &gt;&gt;&gt; PHASE_SHIFT);</span><br><span class="line">    <span class="keyword">if</span> (phase &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> phase;</span><br><span class="line">    <span class="keyword">if</span> (p == phase) &#123;</span><br><span class="line">        <span class="comment">//使用QNode实现了中断异常</span></span><br><span class="line">        QNode node = <span class="keyword">new</span> QNode(<span class="keyword">this</span>, phase, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">        p = root.internalAwaitAdvance(phase, node);</span><br><span class="line">        <span class="comment">//针对中断的情况抛出中断异常</span></span><br><span class="line">        <span class="keyword">if</span> (node.wasInterrupted)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">awaitAdvanceInterruptibly</span><span class="params">(<span class="keyword">int</span> phase,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException, TimeoutException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">    <span class="keyword">final</span> Phaser root = <span class="keyword">this</span>.root;</span><br><span class="line">    <span class="keyword">long</span> s = (root == <span class="keyword">this</span>) ? state : reconcileState();</span><br><span class="line">    <span class="keyword">int</span> p = (<span class="keyword">int</span>)(s &gt;&gt;&gt; PHASE_SHIFT);</span><br><span class="line">    <span class="keyword">if</span> (phase &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> phase;</span><br><span class="line">    <span class="keyword">if</span> (p == phase) &#123;</span><br><span class="line">        <span class="comment">//通过QNode实现了线程的中断、以及超时机制</span></span><br><span class="line">        QNode node = <span class="keyword">new</span> QNode(<span class="keyword">this</span>, phase, <span class="keyword">true</span>, <span class="keyword">true</span>, nanos);</span><br><span class="line">        p = root.internalAwaitAdvance(phase, node);</span><br><span class="line">        <span class="comment">//线程中断抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (node.wasInterrupted)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        <span class="comment">//执行超时抛出异常</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p == phase)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="internalAwaitAdvance-1"><a href="#internalAwaitAdvance-1" class="headerlink" title="internalAwaitAdvance"></a>internalAwaitAdvance</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">internalAwaitAdvance</span><span class="params">(<span class="keyword">int</span> phase, QNode node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 释放上一个phase的资源</span></span><br><span class="line">    releaseWaiters(phase-<span class="number">1</span>);    </span><br><span class="line">    <span class="comment">//node是否被加入到了队列</span></span><br><span class="line">    <span class="keyword">boolean</span> queued = <span class="keyword">false</span>;   </span><br><span class="line">    <span class="comment">//记录前一个unarrived、用于增加spin</span></span><br><span class="line">    <span class="keyword">int</span> lastUnarrived = <span class="number">0</span>;            </span><br><span class="line">    <span class="keyword">int</span> spins = SPINS_PER_ARRIVAL;</span><br><span class="line">    <span class="keyword">long</span> s;</span><br><span class="line">    <span class="keyword">int</span> p;</span><br><span class="line">    <span class="comment">//进入循环操作、直到phase值发生变化</span></span><br><span class="line">    <span class="keyword">while</span> ((p = (<span class="keyword">int</span>)((s = state) &gt;&gt;&gt; PHASE_SHIFT)) == phase) &#123;</span><br><span class="line">        <span class="comment">//采用自旋、不可中断</span></span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;           </span><br><span class="line">            <span class="keyword">int</span> unarrived = (<span class="keyword">int</span>)s &amp; UNARRIVED_MASK;</span><br><span class="line">            <span class="keyword">if</span> (unarrived != lastUnarrived &amp;&amp;</span><br><span class="line">                (lastUnarrived = unarrived) &lt; NCPU)</span><br><span class="line">                spins += SPINS_PER_ARRIVAL;</span><br><span class="line">            <span class="keyword">boolean</span> interrupted = Thread.interrupted();</span><br><span class="line">            <span class="comment">//出现了中断、QNode记录中断</span></span><br><span class="line">            <span class="keyword">if</span> (interrupted || --spins &lt; <span class="number">0</span>) &#123; </span><br><span class="line">                node = <span class="keyword">new</span> QNode(<span class="keyword">this</span>, phase, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">                node.wasInterrupted = interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当前线程的node可以结束等待、退出循环</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (node.isReleasable())</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!queued) &#123;   </span><br><span class="line">            <span class="comment">//node加入队列</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//根据phase选用不同的队列</span></span><br><span class="line">            AtomicReference&lt;QNode&gt; head = (phase &amp; <span class="number">1</span>) == <span class="number">0</span> ? evenQ : oddQ;</span><br><span class="line">            QNode q = node.next = head.get();</span><br><span class="line">            <span class="comment">//符合条件加入队列</span></span><br><span class="line">            <span class="keyword">if</span> ((q == <span class="keyword">null</span> || q.phase == phase) &amp;&amp;</span><br><span class="line">                (<span class="keyword">int</span>)(state &gt;&gt;&gt; PHASE_SHIFT) == phase) <span class="comment">// avoid stale enq</span></span><br><span class="line">                queued = head.compareAndSet(q, node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//node如果已经加入了队列那么直接等待</span></span><br><span class="line">            <span class="comment">//这个主要是直到isReleasable返回true或者block方法返回true</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ForkJoinPool.managedBlock(node);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                node.wasInterrupted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重置入队的node属性</span></span><br><span class="line">    <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//释放Thread</span></span><br><span class="line">        <span class="keyword">if</span> (node.thread != <span class="keyword">null</span>)</span><br><span class="line">            node.thread = <span class="keyword">null</span>;  </span><br><span class="line">        <span class="comment">//不可中断模式下发生的中断，清除中断状态</span></span><br><span class="line">        <span class="keyword">if</span> (node.wasInterrupted &amp;&amp; !node.interruptible)</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        <span class="comment">//phase任然没有发生变化：同步过程已经终止</span></span><br><span class="line">        <span class="keyword">if</span> (p == phase &amp;&amp; (p = (<span class="keyword">int</span>)(state &gt;&gt;&gt; PHASE_SHIFT)) == phase)</span><br><span class="line">            <span class="keyword">return</span> abortWait(phase); <span class="comment">// possibly clean up on abort</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//通知所有等待的线程</span></span><br><span class="line">    releaseWaiters(phase);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="releaseWaiters"><a href="#releaseWaiters" class="headerlink" title="releaseWaiters"></a>releaseWaiters</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">releaseWaiters</span><span class="params">(<span class="keyword">int</span> phase)</span> </span>&#123;</span><br><span class="line">    QNode q; </span><br><span class="line">    Thread t; </span><br><span class="line">    AtomicReference&lt;QNode&gt; head = (phase &amp; <span class="number">1</span>) == <span class="number">0</span> ? evenQ : oddQ;</span><br><span class="line">    <span class="comment">//知道phase发生变化、才能释放</span></span><br><span class="line">    <span class="keyword">while</span> ((q = head.get()) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">           q.phase != (<span class="keyword">int</span>)(root.state &gt;&gt;&gt; PHASE_SHIFT)) &#123;</span><br><span class="line">        <span class="comment">//释放节点并转到下一个节点</span></span><br><span class="line">        <span class="keyword">if</span> (head.compareAndSet(q, q.next) &amp;&amp;</span><br><span class="line">            (t = q.thread) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//释放线程</span></span><br><span class="line">            q.thread = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//唤醒等待的线程</span></span><br><span class="line">            LockSupport.unpark(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="QNode-isReleasable"><a href="#QNode-isReleasable" class="headerlink" title="QNode.isReleasable"></a>QNode.isReleasable</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//表示等待可以结束</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isReleasable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//没有等待线程</span></span><br><span class="line">    <span class="keyword">if</span> (thread == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">//phase发生变化、结束</span></span><br><span class="line">    <span class="keyword">if</span> (phaser.getPhase() != phase) &#123;</span><br><span class="line">        thread = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//线程中断</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        wasInterrupted = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">//可中断模式发生中断、结束</span></span><br><span class="line">    <span class="keyword">if</span> (wasInterrupted &amp;&amp; interruptible) &#123;</span><br><span class="line">        thread = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//超时判断、结束</span></span><br><span class="line">    <span class="keyword">if</span> (timed) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nanos &gt; <span class="number">0L</span>) &#123;</span><br><span class="line">            nanos = deadline - System.nanoTime();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">            thread = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="QNode-block"><a href="#QNode-block" class="headerlink" title="QNode.block"></a>QNode.block</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">block</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isReleasable())</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">//没有设置超时</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!timed)</span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//设置了超时</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; <span class="number">0L</span>)</span><br><span class="line">        LockSupport.parkNanos(<span class="keyword">this</span>, nanos);</span><br><span class="line">    <span class="keyword">return</span> isReleasable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/image/hexo/image-20200725140252917.png&quot; alt=&quot;image-20200725140252917&quot;&gt;&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;&lt;strong&gt;Phaser&lt;/strong&gt;是从JDK1.7引入的，更
      
    
    </summary>
    
    
      <category term="JAVA" scheme="https://blog.huhdcc.top/categories/JAVA/"/>
    
      <category term="多线程" scheme="https://blog.huhdcc.top/categories/JAVA/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="JAVA" scheme="https://blog.huhdcc.top/tags/JAVA/"/>
    
      <category term="多线程" scheme="https://blog.huhdcc.top/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="源码深入" scheme="https://blog.huhdcc.top/tags/%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>多线程高阶-52-ForkJoin详解</title>
    <link href="https://blog.huhdcc.top/2020/07/19/47803/hub/"/>
    <id>https://blog.huhdcc.top/2020/07/19/47803/hub/</id>
    <published>2020-07-19T02:09:31.000Z</published>
    <updated>2020-07-23T08:59:43.852Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/image/hexo/image-20200719101018337.png" alt="image-20200719101018337"></p><p><img src="/image/hexo/image-20200719102418252.png" alt="image-20200719102418252"></p><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><h3 id="RecursiveTask"><a href="#RecursiveTask" class="headerlink" title="RecursiveTask"></a>RecursiveTask</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ForkJoinPool forkJoinPool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">    ForkJoinTask&lt;Integer&gt; futureTask = forkJoinPool.submit(<span class="keyword">new</span> CalculatedRecursiveTask(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">    System.out.println(futureTask.get());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Integer MAX_SIZE = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//RecursiveTask</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CalculatedRecursiveTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">java</span>.<span class="title">lang</span>.<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> start;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> end;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CalculatedRecursiveTask</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> java.lang.<span class="function">Integer <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (end - start &lt;= MAX_SIZE) &#123;</span><br><span class="line">            <span class="keyword">return</span> IntStream.rangeClosed(start, end).sum();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> middle = (start + end) / <span class="number">2</span>;</span><br><span class="line">            CalculatedRecursiveTask left = <span class="keyword">new</span> CalculatedRecursiveTask(start, middle);</span><br><span class="line">            CalculatedRecursiveTask right = <span class="keyword">new</span> CalculatedRecursiveTask(middle + <span class="number">1</span>, end);</span><br><span class="line">            left.fork();</span><br><span class="line">            right.fork();</span><br><span class="line">            <span class="keyword">return</span> left.join() + right.join();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="RecursiveAction"><a href="#RecursiveAction" class="headerlink" title="RecursiveAction"></a>RecursiveAction</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger sum = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ForkJoinPool forkJoinPool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">    forkJoinPool.submit(<span class="keyword">new</span> CalculatedRecursiveTask(<span class="number">1</span>, <span class="number">100</span>));</span><br><span class="line">    forkJoinPool.awaitQuiescence(<span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">    System.out.println(sum.get());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Integer MAX_SIZE = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//RecursiveAction</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CalculatedRecursiveTask</span> <span class="keyword">extends</span> <span class="title">RecursiveAction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> start;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> end;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CalculatedRecursiveTask</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (end - start &lt;= MAX_SIZE) &#123;</span><br><span class="line">            sum.getAndAdd(IntStream.rangeClosed(start, end).sum());</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> middle = (start + end) / <span class="number">2</span>;</span><br><span class="line">            CalculatedRecursiveTask left = <span class="keyword">new</span> CalculatedRecursiveTask(start, middle);</span><br><span class="line">            CalculatedRecursiveTask right = <span class="keyword">new</span> CalculatedRecursiveTask(middle + <span class="number">1</span>, end);</span><br><span class="line">            left.fork();</span><br><span class="line">            right.fork();</span><br><span class="line">            left.join();</span><br><span class="line">            right.join();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>&emsp;&emsp;<strong>ForkJoin</strong>的理念可以使用<strong>分而治之</strong>来理解。把一个比较难处理的任务细化为多个任务，若是还不能解决那么可以再进行细化，最终将各个分支把处理的结果进行合并。</p><p>&emsp;&emsp;这个理念其实是比较常规的，大家都能很容易的想到，并且能够熟练的运用。但是它还运用了<strong>work-stealing</strong>算法(工作窃取)，该算法主要是把分解以后的多个任务放入了多个双端队列，那么工作线程可以从头部或者尾部获取任务。如果某个线程的任务执行完毕，那么它可以从其他线程中获取没有执行完毕的任务（从尾部获取），这样充分的利用线程的空余时间。</p><p><img src="/image/hexo/image-20200719205547339.png" alt="image-20200719205547339"></p><h3 id="主要的角色"><a href="#主要的角色" class="headerlink" title="主要的角色"></a>主要的角色</h3><p><strong>ForkJoinPool</strong>:</p><p>&emsp;&emsp;<strong>ForkJoin</strong>的管理者，任务都需要提交给它去处理，负责了整个<strong>workerThread</strong>的创建以及激活等操作、<strong>workQueue</strong>的创建以及分配等操作，它相当于整个<strong>ForkJoin</strong>的容器。</p><h3 id="ForkJoinWorkerThread"><a href="#ForkJoinWorkerThread" class="headerlink" title="ForkJoinWorkerThread:"></a>ForkJoinWorkerThread:</h3><p>&emsp;&emsp;工作线程，处理任务的线程。内部有一个<strong>ForkJoinPool.WorkQueue</strong>的任务队列，<strong>WorkQueue</strong>依赖与<strong>ForkJoinPool</strong>。</p><h3 id="ForkJoinPool-WorkQueue"><a href="#ForkJoinPool-WorkQueue" class="headerlink" title="ForkJoinPool.WorkQueue:"></a>ForkJoinPool.WorkQueue:</h3><p>&emsp;&emsp;双端任务队列，主要存储了当前线程需要执行的任务，<code>工作窃取</code>就是通过尾部获取未执行的任务。</p><h3 id="ForkJoinTask："><a href="#ForkJoinTask：" class="headerlink" title="ForkJoinTask："></a>ForkJoinTask：</h3><p>&emsp;&emsp;任务类型(<strong>RecursiveTask、RecursiveAction</strong>),<code>RecursiveTask</code>：主要是有返回值。<code>RecursiveAction</code>:不具备返回值。<code>fork</code>用于分解任务并异步执行，<code>join</code>用于处理任务执行完毕执行结果的合并。</p><h2 id="ForkJoinTask详解"><a href="#ForkJoinTask详解" class="headerlink" title="ForkJoinTask详解"></a>ForkJoinTask详解</h2><h3 id="类声明"><a href="#类声明" class="headerlink" title="类声明"></a>类声明</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt;, <span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//任务状态值、通过ForkJoinPool或者工作线程去修改</span></span><br><span class="line"><span class="comment">//volatile保证内存可见性</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> status;</span><br><span class="line"><span class="comment">//用于屏蔽完成状态位</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DONE_MASK   = <span class="number">0xf0000000</span>;</span><br><span class="line"><span class="comment">//表示正常完成（负值）</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NORMAL      = <span class="number">0xf0000000</span>;</span><br><span class="line"><span class="comment">//表示被取消(负值且&lt; NORMAL)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED   = <span class="number">0xc0000000</span>;</span><br><span class="line"><span class="comment">//异常完成(负值且&lt;CANCELLED)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCEPTIONAL = <span class="number">0x80000000</span>;</span><br><span class="line"><span class="comment">//用于signal(1&lt;&lt;16)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL      = <span class="number">0x00010000</span>;</span><br><span class="line"><span class="comment">//后十六位的task标签</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SMASK       = <span class="number">0x0000ffff</span>;</span><br></pre></td></tr></table></figure><p><img src="/image/hexo/image-20200720074842646.png" alt="image-20200720074842646"></p><h3 id="常见方法"><a href="#常见方法" class="headerlink" title="常见方法"></a>常见方法</h3><h4 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ForkJoinTask&lt;V&gt; <span class="title">fork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t;</span><br><span class="line">    <span class="comment">//判断当前的线程是否是ForkJoinWorkerThread</span></span><br><span class="line">    <span class="keyword">if</span> ((t = Thread.currentThread()) <span class="keyword">instanceof</span> ForkJoinWorkerThread)</span><br><span class="line">        <span class="comment">//尝试将任务添加到workQueue中</span></span><br><span class="line">        ((ForkJoinWorkerThread)t).workQueue.push(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//尝试将任务添加到common的线程池中</span></span><br><span class="line">        ForkJoinPool.common.externalPush(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="join"><a href="#join" class="headerlink" title="join"></a>join</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">join</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s;</span><br><span class="line">    <span class="comment">//doJoin会尝试获取任务执行的结果</span></span><br><span class="line">    <span class="keyword">if</span> ((s = doJoin() &amp; DONE_MASK) != NORMAL)</span><br><span class="line">        reportException(s);</span><br><span class="line">    <span class="keyword">return</span> getRawResult();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="doJoin"><a href="#doJoin" class="headerlink" title="doJoin"></a>doJoin</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">doJoin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s; Thread t; ForkJoinWorkerThread wt; ForkJoinPool.WorkQueue w;</span><br><span class="line">    <span class="comment">//如果任务执行完毕返回status</span></span><br><span class="line">    <span class="keyword">return</span> (s = status) &lt; <span class="number">0</span> ? s :</span><br><span class="line">    <span class="comment">//判断当前是否是ForkJoinWorkerThread</span></span><br><span class="line">        ((t = Thread.currentThread()) <span class="keyword">instanceof</span> ForkJoinWorkerThread) ?</span><br><span class="line">        (w = (wt = (ForkJoinWorkerThread)t).workQueue).</span><br><span class="line">        <span class="comment">//尝试从任务队列取出this、并且执行恩物    </span></span><br><span class="line">        tryUnpush(<span class="keyword">this</span>) &amp;&amp; (s = doExec()) &lt; <span class="number">0</span> ? s :</span><br><span class="line">    <span class="comment">//等待任务执行结束、会尝试帮助其他的线程完成任务</span></span><br><span class="line">        wt.pool.awaitJoin(w, <span class="keyword">this</span>, <span class="number">0L</span>) :</span><br><span class="line">        externalAwaitDone();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="setCompletion"><a href="#setCompletion" class="headerlink" title="setCompletion"></a>setCompletion</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//主要用于标记当前task的completion状态</span></span><br><span class="line"><span class="comment">//满足条件则唤醒等待该task的线程</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">setCompletion</span><span class="params">(<span class="keyword">int</span> completion)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> s;;) &#123;</span><br><span class="line">        <span class="comment">//如果当前task的status已经完成(&lt;0)，返回status</span></span><br><span class="line">        <span class="comment">//status可能是某一次循环被其他线程操作完全</span></span><br><span class="line">        <span class="keyword">if</span> ((s = status) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        <span class="comment">//CAS:尝试将原来的status设置为它与completion位或的结果</span></span><br><span class="line">        <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, STATUS, s, s | completion)) &#123;</span><br><span class="line">            <span class="comment">//SIGNAL标记</span></span><br><span class="line">            <span class="comment">//task只要完成(发生异常或取消)，或者completion传入的值1&lt;&lt;16</span></span><br><span class="line">            <span class="comment">//唤醒其他的线程</span></span><br><span class="line">            <span class="keyword">if</span> ((s &gt;&gt;&gt; <span class="number">16</span>) != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123; notifyAll(); &#125;</span><br><span class="line">            <span class="comment">//CAS成功、返回参数中的completion</span></span><br><span class="line">            <span class="keyword">return</span> completion;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="doExec"><a href="#doExec" class="headerlink" title="doExec"></a>doExec</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//运行ForkJoinTask的核心</span></span><br><span class="line"><span class="comment">//使用final修饰</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">doExec</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s; <span class="keyword">boolean</span> completed;</span><br><span class="line">    <span class="comment">//如果任务未完成则会继续运行</span></span><br><span class="line">    <span class="keyword">if</span> ((s = status) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//exec</span></span><br><span class="line">            completed = exec();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable rex) &#123;</span><br><span class="line">            <span class="comment">//发生异常情况、setExceptionalCompletion设置结果</span></span><br><span class="line">            <span class="keyword">return</span> setExceptionalCompletion(rex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (completed)</span><br><span class="line">            <span class="comment">//正常完成、调用setCompletio将返回s</span></span><br><span class="line">            s = setCompletion(NORMAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="setExceptionalCompletion"><a href="#setExceptionalCompletion" class="headerlink" title="setExceptionalCompletion"></a>setExceptionalCompletion</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//主要用于记录异常并且在满足条件的情形下传播异常</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">setExceptionalCompletion</span><span class="params">(Throwable ex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//记录异常信息到结果</span></span><br><span class="line">    <span class="keyword">int</span> s = recordExceptionalCompletion(ex);</span><br><span class="line">    <span class="keyword">if</span> ((s &amp; DONE_MASK) == EXCEPTIONAL)</span><br><span class="line">        <span class="comment">//status去除非完成标志位 == EXCEPTIONAL</span></span><br><span class="line">        <span class="comment">//内部传播异常</span></span><br><span class="line">        <span class="comment">//internalPropagateException空的方法，需要子类去实现</span></span><br><span class="line">        internalPropagateException(ex);</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="reportException"><a href="#reportException" class="headerlink" title="reportException"></a>reportException</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//任务执行期间抛出未捕获的异常或者被取消</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reportException</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == CANCELLED)</span><br><span class="line">        <span class="comment">//任务取消抛出CancellationException</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CancellationException();</span><br><span class="line">    <span class="keyword">if</span> (s == EXCEPTIONAL)</span><br><span class="line">        <span class="comment">//未捕获异常则通过rethrow包装为RunTimeException</span></span><br><span class="line">        rethrow(getThrowableException());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="getThrowableException"><a href="#getThrowableException" class="headerlink" title="getThrowableException"></a>getThrowableException</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取给定任务的执行异常</span></span><br><span class="line"><span class="comment">//如果异常不是当前的线程抛出</span></span><br><span class="line"><span class="comment">//尝试以记录的异常为原因创建一个与抛出异常类型相同的新的异常</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Throwable <span class="title">getThrowableException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((status &amp; DONE_MASK) != EXCEPTIONAL)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//通过当前任务对象的哈希值从哈希链表中找到对应的异常节点</span></span><br><span class="line">    <span class="keyword">int</span> h = System.identityHashCode(<span class="keyword">this</span>);</span><br><span class="line">    ExceptionNode e;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = exceptionTableLock;</span><br><span class="line">    <span class="comment">//加锁操作</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//清理被GC回收的任务的异常节点</span></span><br><span class="line">        expungeStaleExceptions();</span><br><span class="line">        ExceptionNode[] t = exceptionTable;</span><br><span class="line">      <span class="comment">//取模运算获取对应的索引进而获取哈希数组槽位中的节点</span></span><br><span class="line">        e = t[h &amp; (t.length - <span class="number">1</span>)];</span><br><span class="line">      <span class="comment">//遍历找到当前任务对应的异常节点</span></span><br><span class="line">        <span class="keyword">while</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() != <span class="keyword">this</span>)</span><br><span class="line">            e = e.next;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//解锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    Throwable ex;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span> || (ex = e.ex) == <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">//没有出现任何的异常、退出</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//存在异常、当不是当前线程所抛出</span></span><br><span class="line">    <span class="keyword">if</span> (e.thrower != Thread.currentThread().getId()) &#123;</span><br><span class="line">        <span class="comment">//反射找到构造方法、并且开始构造一个新的异常</span></span><br><span class="line">        Class&lt;? extends Throwable&gt; ec = ex.getClass();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Constructor&lt;?&gt; noArgCtor = <span class="keyword">null</span>;</span><br><span class="line">            Constructor&lt;?&gt;[] cs = ec.getConstructors();<span class="comment">// public ctors only</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cs.length; ++i) &#123;</span><br><span class="line">                Constructor&lt;?&gt; c = cs[i];</span><br><span class="line">                Class&lt;?&gt;[] ps = c.getParameterTypes();</span><br><span class="line">                <span class="keyword">if</span> (ps.length == <span class="number">0</span>)</span><br><span class="line">                    <span class="comment">//标记无参构造方法、在没有找到期望的构造方法的时候去使用</span></span><br><span class="line">                    noArgCtor = c;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ps.length == <span class="number">1</span> &amp;&amp; ps[<span class="number">0</span>] == Throwable<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                    <span class="comment">//发现了期望的Throwable类型的参数的构造方法</span></span><br><span class="line">                    Throwable wx = (Throwable)c.newInstance(ex);</span><br><span class="line">                    <span class="keyword">return</span> (wx == <span class="keyword">null</span>) ? ex : wx;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//没有找到期望的构造方法</span></span><br><span class="line">            <span class="keyword">if</span> (noArgCtor != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//通过无参构造的方法进行构建一个新的异常</span></span><br><span class="line">                Throwable wx = (Throwable)(noArgCtor.newInstance());</span><br><span class="line">                <span class="keyword">if</span> (wx != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//设置原始的异常信息</span></span><br><span class="line">                    wx.initCause(ex);</span><br><span class="line">                    <span class="keyword">return</span> wx;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ignore) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="recordExceptionalCompletion"><a href="#recordExceptionalCompletion" class="headerlink" title="recordExceptionalCompletion"></a>recordExceptionalCompletion</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//记录异常</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">recordExceptionalCompletion</span><span class="params">(Throwable ex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s;</span><br><span class="line">    <span class="keyword">if</span> ((s = status) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//判断是否是异常的状态status</span></span><br><span class="line">        <span class="comment">//禁止重写hash值，不适用子类的hashCode函数</span></span><br><span class="line">        <span class="keyword">int</span> h = System.identityHashCode(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = exceptionTableLock;</span><br><span class="line">        <span class="comment">//获取异常锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//抹除脏异常数据</span></span><br><span class="line">            expungeStaleExceptions();</span><br><span class="line">            <span class="comment">//异常表数组，exceptionTable全局静态变量</span></span><br><span class="line">            ExceptionNode[] t = exceptionTable;</span><br><span class="line">            <span class="comment">//通过hash值和数组长度进行一个运算获取一个初始的索引</span></span><br><span class="line">            <span class="keyword">int</span> i = h &amp; (t.length - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (ExceptionNode e = t[i]; ; e = e.next) &#123;</span><br><span class="line">                <span class="comment">//找到空的索引位</span></span><br><span class="line">                <span class="keyword">if</span> (e == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//创建一个新的ExceptionNode、保存this</span></span><br><span class="line">                    <span class="comment">//退出循环</span></span><br><span class="line">                    t[i] = <span class="keyword">new</span> ExceptionNode(<span class="keyword">this</span>, ex, t[i]);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果已经设置了相同的元素在索引中、退出循环</span></span><br><span class="line">                <span class="keyword">if</span> (e.get() == <span class="keyword">this</span>) </span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//记录成功、更新task为异常完成</span></span><br><span class="line">        s = setCompletion(EXCEPTIONAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="exceptionTable相关"><a href="#exceptionTable相关" class="headerlink" title="exceptionTable相关"></a>exceptionTable相关</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全局异常Node表</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ExceptionNode[] exceptionTable;</span><br><span class="line"><span class="comment">//异常可重入锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ReentrantLock exceptionTableLock;</span><br><span class="line"><span class="comment">//变量表引用队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ReferenceQueue&lt;Object&gt; exceptionTableRefQueue;</span><br><span class="line"><span class="comment">//异常表的固定容量32</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCEPTION_MAP_CAPACITY = <span class="number">32</span>;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化操作</span></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    exceptionTableLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    exceptionTableRefQueue = <span class="keyword">new</span> ReferenceQueue&lt;Object&gt;();</span><br><span class="line">    exceptionTable = <span class="keyword">new</span> ExceptionNode[EXCEPTION_MAP_CAPACITY];</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        U = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">        Class&lt;?&gt; k = ForkJoinTask<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        STATUS = U.objectFieldOffset</span><br><span class="line">            (k.getDeclaredField(<span class="string">"status"</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ExceptionNode"><a href="#ExceptionNode" class="headerlink" title="ExceptionNode"></a>ExceptionNode</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ExceptionNode实现了一个弱引用</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionNode</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ForkJoinTask</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Throwable ex;</span><br><span class="line">    ExceptionNode next;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> thrower;  <span class="comment">// use id not ref to avoid weak cycles</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hashCode;  <span class="comment">// store task hashCode before weak ref disappears</span></span><br><span class="line">    ExceptionNode(ForkJoinTask&lt;?&gt; task, Throwable ex, ExceptionNode next) &#123;</span><br><span class="line">        <span class="comment">//指向弱引用的构造函数</span></span><br><span class="line">        <span class="comment">//保存引用为task</span></span><br><span class="line">        <span class="comment">//全局队列</span></span><br><span class="line">        <span class="keyword">super</span>(task, exceptionTableRefQueue);</span><br><span class="line">        <span class="comment">//抛出异常的引用</span></span><br><span class="line">        <span class="keyword">this</span>.ex = ex;</span><br><span class="line">        <span class="comment">//ExceptionNode以链表的方式存在</span></span><br><span class="line">        <span class="comment">//先入者为后入者的</span></span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="comment">//保存抛出异常的线程ID</span></span><br><span class="line">        <span class="keyword">this</span>.thrower = Thread.currentThread().getId();</span><br><span class="line">        <span class="comment">//hash码保存关联的task的哈希值</span></span><br><span class="line">        <span class="keyword">this</span>.hashCode = System.identityHashCode(task);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="expungeStaleExceptions"><a href="#expungeStaleExceptions" class="headerlink" title="expungeStaleExceptions"></a>expungeStaleExceptions</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//清除异常表中的脏数据</span></span><br><span class="line"><span class="comment">//持有全局锁才可使用</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">expungeStaleExceptions</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//进入转换</span></span><br><span class="line">    <span class="comment">//exceptionTableRefQueue不为空，且</span></span><br><span class="line">    <span class="keyword">for</span> (Object x; (x = exceptionTableRefQueue.poll()) != <span class="keyword">null</span>;) &#123;</span><br><span class="line">        <span class="comment">//依次获取元素</span></span><br><span class="line">        <span class="keyword">if</span> (x <span class="keyword">instanceof</span> ExceptionNode) &#123;</span><br><span class="line">            <span class="comment">//计算在exceptionTable中的索引</span></span><br><span class="line">            <span class="keyword">int</span> hashCode = ((ExceptionNode)x).hashCode;</span><br><span class="line">            ExceptionNode[] t = exceptionTable;</span><br><span class="line">            <span class="keyword">int</span> i = hashCode &amp; (t.length - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//取出Node</span></span><br><span class="line">            ExceptionNode e = t[i];</span><br><span class="line">            ExceptionNode pred = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//进入循环、直到e为null就停止</span></span><br><span class="line">            <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                ExceptionNode next = e.next;</span><br><span class="line">                <span class="comment">//x:队首出对的元素</span></span><br><span class="line">                <span class="keyword">if</span> (e == x) &#123;</span><br><span class="line">                    <span class="comment">//pred:没有前置元素，e排在链表的首位</span></span><br><span class="line">                    <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">                        <span class="comment">//没有前置元素、直接修改引用指向了next</span></span><br><span class="line">                        t[i] = next;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        <span class="comment">//存在了前置的元素、说明循环过N次、跳出循环</span></span><br><span class="line">                        pred.next = next;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果当前e不是x，准备开启下一轮循环、pred指向了e，进行下一个元素的比窘</span></span><br><span class="line">                pred = e;</span><br><span class="line">                e = next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="externalAwaitDone"><a href="#externalAwaitDone" class="headerlink" title="externalAwaitDone"></a>externalAwaitDone</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//等待未完成的非ForkJoinWorkerThread线程提交的任务</span></span><br><span class="line"><span class="comment">//返回任务执行的结果</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">externalAwaitDone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1.如果是CountedCompleter任务、等待externalHelpComplete返回</span></span><br><span class="line">    <span class="comment">//2.否则ForkJoinPool.common.tryExternalUnpush(this)返回doExec结果</span></span><br><span class="line">    <span class="comment">//3.否则返回0</span></span><br><span class="line">    <span class="keyword">int</span> s = ((<span class="keyword">this</span> <span class="keyword">instanceof</span> CountedCompleter) ? <span class="comment">// try helping</span></span><br><span class="line">             ForkJoinPool.common.externalHelpComplete(</span><br><span class="line">                 <span class="comment">//辅助完成外部提交的externalHelpComplete任务</span></span><br><span class="line">                 (CountedCompleter&lt;?&gt;)<span class="keyword">this</span>, <span class="number">0</span>) :</span><br><span class="line">             <span class="comment">//辅助完成外部提交的非externalHelpComplete任务</span></span><br><span class="line">             ForkJoinPool.common.tryExternalUnpush(<span class="keyword">this</span>) ? doExec() : <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//任务还未执行完毕、阻塞等待</span></span><br><span class="line">    <span class="keyword">if</span> (s &gt;= <span class="number">0</span> &amp;&amp; (s = status) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">//标记有线程需要被唤醒</span></span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, STATUS, s, s | SIGNAL)) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (status &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="comment">//任务未执行完毕、陷入阻塞等待被唤醒</span></span><br><span class="line">                            wait(<span class="number">0L</span>);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                            interrupted = <span class="keyword">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        <span class="comment">//任务执行完毕、唤醒所有陷入阻塞的线程</span></span><br><span class="line">                        notifyAll();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((s = status) &gt;= <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (interrupted)</span><br><span class="line">            <span class="comment">//中断线程</span></span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="get"><a href="#get" class="headerlink" title="get"></a>get</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取异步任务的执行结果</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">    <span class="comment">//如果是ForkJoinWorkerThread则执行doJoin否则externalInterruptibleAwaitDone</span></span><br><span class="line">    <span class="keyword">int</span> s = (Thread.currentThread() <span class="keyword">instanceof</span> ForkJoinWorkerThread) ?</span><br><span class="line">        doJoin() : externalInterruptibleAwaitDone();</span><br><span class="line">    Throwable ex;</span><br><span class="line">    <span class="keyword">if</span> ((s &amp;= DONE_MASK) == CANCELLED)</span><br><span class="line">        <span class="comment">//如果任务被取消抛出CancellationException</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CancellationException();</span><br><span class="line">    <span class="keyword">if</span> (s == EXCEPTIONAL &amp;&amp; (ex = getThrowableException()) != <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">//任务执行过程中出现异常则抛出对应的异常信息</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ExecutionException(ex);</span><br><span class="line">    <span class="keyword">return</span> getRawResult();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="externalInterruptibleAwaitDone"><a href="#externalInterruptibleAwaitDone" class="headerlink" title="externalInterruptibleAwaitDone"></a>externalInterruptibleAwaitDone</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//阻塞非ForkJoinWorkerThread线程</span></span><br><span class="line"><span class="comment">//等待任务执行完毕或中断线程</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">externalInterruptibleAwaitDone</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">if</span> ((s = status) &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (s = ((<span class="keyword">this</span> <span class="keyword">instanceof</span> CountedCompleter) ?</span><br><span class="line">              ForkJoinPool.common.externalHelpComplete(</span><br><span class="line">                  (CountedCompleter&lt;?&gt;)<span class="keyword">this</span>, <span class="number">0</span>) :</span><br><span class="line">              ForkJoinPool.common.tryExternalUnpush(<span class="keyword">this</span>) ? doExec() :</span><br><span class="line">              <span class="number">0</span>)) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//任务需要阻塞陷入等待</span></span><br><span class="line">        <span class="keyword">while</span> ((s = status) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, STATUS, s, s | SIGNAL)) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (status &gt;= <span class="number">0</span>)</span><br><span class="line">                        <span class="comment">//陷入阻塞等待</span></span><br><span class="line">                        wait(<span class="number">0L</span>);</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        <span class="comment">//唤醒等待中的所有的线程</span></span><br><span class="line">                        notifyAll();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="invoke"><a href="#invoke" class="headerlink" title="invoke"></a>invoke</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//开始执行任务、等待执行并返回任务执行的结果</span></span><br><span class="line"><span class="comment">//出现异常、则抛出对应的未捕获的异常</span></span><br><span class="line"><span class="comment">//如果中断了线程并不会立即返回、而是等待任务执行有了结果才会对中断状态进行补偿</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">invoke</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s;</span><br><span class="line">    <span class="keyword">if</span> ((s = doInvoke() &amp; DONE_MASK) != NORMAL)</span><br><span class="line">        reportException(s);</span><br><span class="line">    <span class="keyword">return</span> getRawResult();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="doInvoke"><a href="#doInvoke" class="headerlink" title="doInvoke"></a>doInvoke</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">doInvoke</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s; Thread t; ForkJoinWorkerThread wt;</span><br><span class="line">    <span class="comment">//执行任务、执行完毕返回status</span></span><br><span class="line">    <span class="keyword">return</span> (s = doExec()) &lt; <span class="number">0</span> ? s :</span><br><span class="line">    <span class="comment">//如果当前线程是ForkJoinWorkerThread根据不同的任务类型执行不同的等待</span></span><br><span class="line">        ((t = Thread.currentThread()) <span class="keyword">instanceof</span> ForkJoinWorkerThread) ?</span><br><span class="line">        (wt = (ForkJoinWorkerThread)t).pool.</span><br><span class="line">        awaitJoin(wt.workQueue, <span class="keyword">this</span>, <span class="number">0L</span>) :</span><br><span class="line">        externalAwaitDone();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="invokeAll"><a href="#invokeAll" class="headerlink" title="invokeAll"></a>invokeAll</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行两个任务</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeAll</span><span class="params">(ForkJoinTask&lt;?&gt; t1, ForkJoinTask&lt;?&gt; t2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s1, s2;</span><br><span class="line">    <span class="comment">//t2任务交给线程池进行调度</span></span><br><span class="line">    t2.fork();</span><br><span class="line">    <span class="comment">//t1通过当前的线程执行</span></span><br><span class="line">    <span class="keyword">if</span> ((s1 = t1.doInvoke() &amp; DONE_MASK) != NORMAL)</span><br><span class="line">        t1.reportException(s1);</span><br><span class="line">    <span class="comment">//等待t2任务执行完毕</span></span><br><span class="line">    <span class="keyword">if</span> ((s2 = t2.doJoin() &amp; DONE_MASK) != NORMAL)</span><br><span class="line">        t2.reportException(s2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行任务数组</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeAll</span><span class="params">(ForkJoinTask&lt;?&gt;... tasks)</span> </span>&#123;</span><br><span class="line">    Throwable ex = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> last = tasks.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = last; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        ForkJoinTask&lt;?&gt; t = tasks[i];</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//都不能为null</span></span><br><span class="line">            <span class="keyword">if</span> (ex == <span class="keyword">null</span>)</span><br><span class="line">                ex = <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (i != <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//除了第一个任务都交给线程池进行调度</span></span><br><span class="line">            t.fork();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//第一个任务由当先线程进行执行</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (t.doInvoke() &lt; NORMAL &amp;&amp; ex == <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">//记录第一个任务执行的异常</span></span><br><span class="line">            ex = t.getException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= last; ++i) &#123;</span><br><span class="line">        ForkJoinTask&lt;?&gt; t = tasks[i];</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//第一个任务异常结束、取消其他的任务</span></span><br><span class="line">            <span class="keyword">if</span> (ex != <span class="keyword">null</span>)</span><br><span class="line">                t.cancel(<span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (t.doJoin() &lt; NORMAL)</span><br><span class="line">                <span class="comment">//由任务异常结束、记录异常信息</span></span><br><span class="line">                ex = t.getException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ex != <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">//如果由任务异常结束、抛出数组最前面那么异常结束任务的异常</span></span><br><span class="line">        rethrow(ex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//批量执行任务</span></span><br><span class="line"><span class="comment">//返回每个任务对应的ForkJoinTask</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends ForkJoinTask&lt;?&gt;&gt; <span class="function">Collection&lt;T&gt; <span class="title">invokeAll</span><span class="params">(Collection&lt;T&gt; tasks)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(tasks <span class="keyword">instanceof</span> RandomAccess) || !(tasks <span class="keyword">instanceof</span> List&lt;?&gt;)) &#123;</span><br><span class="line">        <span class="comment">//将任务封装成ForkJoinTask</span></span><br><span class="line">        invokeAll(tasks.toArray(<span class="keyword">new</span> ForkJoinTask&lt;?&gt;[tasks.size()]));</span><br><span class="line">        <span class="keyword">return</span> tasks;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   </span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    List&lt;? extends ForkJoinTask&lt;?&gt;&gt; ts =</span><br><span class="line">        (List&lt;? extends ForkJoinTask&lt;?&gt;&gt;) tasks;</span><br><span class="line">    Throwable ex = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> last = ts.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = last; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        ForkJoinTask&lt;?&gt; t = ts.get(i);</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ex == <span class="keyword">null</span>)</span><br><span class="line">                ex = <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (i != <span class="number">0</span>)</span><br><span class="line">            t.fork();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (t.doInvoke() &lt; NORMAL &amp;&amp; ex == <span class="keyword">null</span>)</span><br><span class="line">            ex = t.getException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= last; ++i) &#123;</span><br><span class="line">        ForkJoinTask&lt;?&gt; t = ts.get(i);</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ex != <span class="keyword">null</span>)</span><br><span class="line">                t.cancel(<span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (t.doJoin() &lt; NORMAL)</span><br><span class="line">                ex = t.getException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ex != <span class="keyword">null</span>)</span><br><span class="line">        rethrow(ex);</span><br><span class="line">    <span class="keyword">return</span> tasks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;批量执行任务其实都是排在前面的任务由当前的线程去执行，其余的都交给了线程池去调度执行，如果有多个任务抛出了异常，只会抛出排在最前面的那个任务的异常。</p><h4 id="quietlyInvoke"><a href="#quietlyInvoke" class="headerlink" title="quietlyInvoke"></a>quietlyInvoke</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不需要执行结果的invoke</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">quietlyInvoke</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    doInvoke();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="quietlyJoin"><a href="#quietlyJoin" class="headerlink" title="quietlyJoin"></a>quietlyJoin</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不需要执行结果的join</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">quietlyJoin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    doJoin();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="cancel"><a href="#cancel" class="headerlink" title="cancel"></a>cancel</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//主要通过setCompletion标记尚未执行完毕的任务状态为CANCELLED</span></span><br><span class="line"><span class="comment">//尝试唤醒通过join等待此任务的线程</span></span><br><span class="line"><span class="comment">//已经执行完毕的任务无法取消</span></span><br><span class="line"><span class="comment">//mayInterruptIfRunning并没有使用，ForkJoinTask并不支持在取消任务时中断已经开始执行的任务</span></span><br><span class="line"><span class="comment">//当然该子类可以重写进行实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (setCompletion(CANCELLED) &amp; DONE_MASK) == CANCELLED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="tryUnfork"><a href="#tryUnfork" class="headerlink" title="tryUnfork"></a>tryUnfork</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//取消fork将任务从任务队列中移除</span></span><br><span class="line"><span class="comment">//如果此任务时当前线程最近才刚刚通过fork方法调度、并且尚未在另一个线程中去执行、通常情况下会成功</span></span><br><span class="line"><span class="comment">//不保证所有的都会成功</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryUnfork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t;</span><br><span class="line">    <span class="keyword">return</span> (((t = Thread.currentThread()) <span class="keyword">instanceof</span> ForkJoinWorkerThread) ?</span><br><span class="line">            <span class="comment">//针对ForkJoinWorkerThread的取消逻辑</span></span><br><span class="line">            ((ForkJoinWorkerThread)t).workQueue.tryUnpush(<span class="keyword">this</span>) :</span><br><span class="line">            <span class="comment">//针对非ForkJoinWorkerThread的取消逻辑</span></span><br><span class="line">            ForkJoinPool.common.tryExternalUnpush(<span class="keyword">this</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="reinitialize"><a href="#reinitialize" class="headerlink" title="reinitialize"></a>reinitialize</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//重新初始化该任务</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reinitialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((status &amp; DONE_MASK) == EXCEPTIONAL)</span><br><span class="line">        <span class="comment">//存在异常从哈希链表数组中移除当前任务的异常节点</span></span><br><span class="line">        clearExceptionalCompletion();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//重置status==0</span></span><br><span class="line">        status = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="helpQuiesce"><a href="#helpQuiesce" class="headerlink" title="helpQuiesce"></a>helpQuiesce</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果有一批任务被安排进行执行，但是不知道什么时候结束、希望在这些任务都执行完毕后再安排一个任务</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">helpQuiesce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t;</span><br><span class="line">    <span class="comment">//根据执行线程的类型执行不同的执行逻辑</span></span><br><span class="line">    <span class="keyword">if</span> ((t = Thread.currentThread()) <span class="keyword">instanceof</span> ForkJoinWorkerThread) &#123;</span><br><span class="line">        ForkJoinWorkerThread wt = (ForkJoinWorkerThread)t;</span><br><span class="line">        wt.pool.helpQuiescePool(wt.workQueue);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ForkJoinPool.quiesceCommonPool();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="getSurplusQueuedTaskCount"><a href="#getSurplusQueuedTaskCount" class="headerlink" title="getSurplusQueuedTaskCount"></a>getSurplusQueuedTaskCount</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取当前工作线程持有的任务数比其他可能窃取其任务的其他线程持有的任务数的一个估计值</span></span><br><span class="line"><span class="comment">//如果当前线程不是ForkJoinPool中则返回0</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getSurplusQueuedTaskCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ForkJoinPool.getSurplusQueuedTaskCount();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="子类实现"><a href="#子类实现" class="headerlink" title="子类实现"></a>子类实现</h3><h4 id="RecursiveTask-1"><a href="#RecursiveTask-1" class="headerlink" title="RecursiveTask"></a>RecursiveTask</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//带有返回结果的Task,定义了一个表示执行结果的result字段</span></span><br><span class="line"><span class="comment">//compute抽象方法用于当ForkJoinTask被调度执行exec方法时调用</span></span><br><span class="line"><span class="comment">//compute也是进行任务的拆分的逻辑</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">RecursiveTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">ForkJoinTask</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">5232453952276485270L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The result of the computation.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    V result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The main computation performed by this task.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the result of the computation</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> V <span class="title">compute</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getRawResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setRawResult</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line">        result = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Implements execution conventions for RecursiveTask.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">exec</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        result = compute();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="RecursiveAction-1"><a href="#RecursiveAction-1" class="headerlink" title="RecursiveAction"></a>RecursiveAction</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//没有返回值</span></span><br><span class="line"><span class="comment">//getRawResult永远为null</span></span><br><span class="line"><span class="comment">//setRawResult什么都不操作</span></span><br><span class="line"><span class="comment">//compute进行任务拆分</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">RecursiveAction</span> <span class="keyword">extends</span> <span class="title">ForkJoinTask</span>&lt;<span class="title">Void</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">5232453952276485070L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The main computation performed by this task.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">compute</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Always returns &#123;<span class="doctag">@code</span> null&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> null&#125; always</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Void <span class="title">getRawResult</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">null</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Requires null completion value.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setRawResult</span><span class="params">(Void mustBeNull)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Implements execution conventions for RecursiveActions.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">exec</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        compute();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="CountedCompleter"><a href="#CountedCompleter" class="headerlink" title="CountedCompleter"></a>CountedCompleter</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JDK8新增的CountedCompleter、操作完成后可以触发钩子函数、它是一个特殊的ForkJoinTask</span></span><br><span class="line"><span class="comment">//在触发完成动作时：检查有没有挂起的action、若没有则执行一个完成的动作</span></span><br><span class="line"><span class="comment">//可以支持返回结果或不返回结果、对方法进行重写</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CountedCompleter</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ForkJoinTask</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">5232453752276485070L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//一个链表结构、完成的触发顺序则是先进后出的模式(任务的完成者)</span></span><br><span class="line">    <span class="keyword">final</span> CountedCompleter&lt;?&gt; completer;</span><br><span class="line">    <span class="comment">//完成前挂起等待的任务数量</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> pending;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">CountedCompleter</span><span class="params">(CountedCompleter&lt;?&gt; completer,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">int</span> initialPendingCount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.completer = completer;</span><br><span class="line">        <span class="keyword">this</span>.pending = initialPendingCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">CountedCompleter</span><span class="params">(CountedCompleter&lt;?&gt; completer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.completer = completer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">CountedCompleter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.completer = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拆分逻辑</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">compute</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用了无条件complete或者调用tryComplet如果等待的任务数==0，触发该方法</span></span><br><span class="line">    <span class="comment">//默认不做任何操作</span></span><br><span class="line">    <span class="comment">//该实现主要取决于要实现的操作，比如并行流中的ops会处理一些结果集的reduce操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompletion</span><span class="params">(CountedCompleter&lt;?&gt; caller)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用completeexcepttion或者compute抛出异常时执行的操作、任务尚未执行完毕</span></span><br><span class="line">    <span class="comment">//默认返回true</span></span><br><span class="line">    <span class="comment">//异常完成的钩子函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onExceptionalCompletion</span><span class="params">(Throwable ex, CountedCompleter&lt;?&gt; caller)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//提供了扩展性、表示异常应该传递给this的completer</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回此任务的构造函数中建立的实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> CountedCompleter&lt;?&gt; getCompleter() &#123;</span><br><span class="line">        <span class="keyword">return</span> completer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回当前挂起等待的任务数量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getPendingCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pending;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置挂起等待的任务数量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setPendingCount</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">        pending = count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//原子性的将给定的值添加到挂起的计数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">addToPendingCount</span><span class="params">(<span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">        U.getAndAddInt(<span class="keyword">this</span>, PENDING, delta);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在当前持有的给定期望值、原子的挂起的计数设置为给定的计数expected修改到count</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetPendingCount</span><span class="params">(<span class="keyword">int</span> expected, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> U.compareAndSwapInt(<span class="keyword">this</span>, PENDING, expected, count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当前任务的挂起的任务数量原子减为0</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">decrementPendingCountUnlessZero</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> c;</span><br><span class="line">        <span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> ((c = pending) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     !U.compareAndSwapInt(<span class="keyword">this</span>, PENDING, c, c - <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> CountedCompleter&lt;?&gt; getRoot() &#123;</span><br><span class="line">        CountedCompleter&lt;?&gt; a = <span class="keyword">this</span>, p;</span><br><span class="line">        <span class="keyword">while</span> ((p = a.completer) != <span class="keyword">null</span>)</span><br><span class="line">            a = p;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果挂起的计数不为0，则减少计数，否则调用onCompletion</span></span><br><span class="line">    <span class="comment">//类似的尝试此任务的completer，存在则将此任务标记完成</span></span><br><span class="line">    <span class="comment">//尝试完成根任务或减少栈链下游的某一个completer的挂起数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">tryComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CountedCompleter&lt;?&gt; a = <span class="keyword">this</span>, s = a;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> c;;) &#123;</span><br><span class="line">            <span class="comment">//a(this或this的completer链中的某一个)的的挂起任务数为0,代表它挂起的任务都完成了.</span></span><br><span class="line">            <span class="keyword">if</span> ((c = a.pending) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//a的钩子函数:</span></span><br><span class="line">                <span class="comment">//对this于参数是否相等进行判断，如并行流聚合可以根据这个条件进行结果集的合并</span></span><br><span class="line">                a.onCompletion(s);</span><br><span class="line">                <span class="keyword">if</span> ((a = (s = a).completer) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//原来a的completer不存在，a不再是root了，那么就不需要传递</span></span><br><span class="line">                    <span class="comment">//调用quietlyComplete</span></span><br><span class="line">                    <span class="comment">//此时说明整条链上的completer的挂起任务全部都是0</span></span><br><span class="line">                    s.quietlyComplete();</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//对this的completer栈的某一次循环发现挂起任务数不为0</span></span><br><span class="line">            <span class="comment">//对该completer的挂起数-1</span></span><br><span class="line">            <span class="comment">//表示它挂起的任务完成了一个</span></span><br><span class="line">            <span class="comment">//如果产生了竞争状态，某个链上的任务抢先-1操作</span></span><br><span class="line">            <span class="comment">//那么进入下一次循环、进入到链上的下一个completer的传播逻辑</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(a, PENDING, c, c - <span class="number">1</span>))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//基本等效tryComplete</span></span><br><span class="line">    <span class="comment">//仅仅是不执行onCompletion</span></span><br><span class="line">    <span class="comment">//tryComplete会在判断链上的某个completer的挂起数是否为0</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">propagateCompletion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CountedCompleter&lt;?&gt; a = <span class="keyword">this</span>, s = a;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> c;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((c = a.pending) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((a = (s = a).completer) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    s.quietlyComplete();</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(a, PENDING, c, c - <span class="number">1</span>))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当获得多个子任务的任何一个结果</span></span><br><span class="line">    <span class="comment">//适合findAny场景</span></span><br><span class="line">    <span class="comment">//它丝毫不考虑挂起数、直接执行当前task的几个完成的方法</span></span><br><span class="line">    <span class="comment">//并且尝试对completer进行tryComplete</span></span><br><span class="line">    <span class="comment">//不改变自身的挂起任务数、但会让completer对栈上的其他completer或者自身尝试减少挂起数或者完成root</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">complete</span><span class="params">(T rawResult)</span> </span>&#123;</span><br><span class="line">        CountedCompleter&lt;?&gt; p;</span><br><span class="line">        <span class="comment">//使用参数设置当前任务的结果</span></span><br><span class="line">        setRawResult(rawResult);</span><br><span class="line">        <span class="comment">//直接调用钩子函数</span></span><br><span class="line">        onCompletion(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">//将status设置为NORMAL</span></span><br><span class="line">        quietlyComplete();</span><br><span class="line">        <span class="keyword">if</span> ((p = completer) != <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">//自己不改变自身的挂起数、也不尝试完成root</span></span><br><span class="line">           p.tryComplete();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果此任何的挂起计数为0，返回此任何，否则递减其挂起计数并返回</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> CountedCompleter&lt;?&gt; firstComplete() &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> c;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((c = pending) == <span class="number">0</span>)</span><br><span class="line">                <span class="comment">//当前task没有挂起的任务数则返回</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, PENDING, c, c - <span class="number">1</span>))</span><br><span class="line">                <span class="comment">//尝试坚守一个任务数并返回null</span></span><br><span class="line">                <span class="comment">//可能出现CAS失败</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//会针对当前任务判断是否又completer</span></span><br><span class="line">    <span class="comment">//有则对completer进行firstComplete</span></span><br><span class="line">    <span class="comment">//否则将当前任务安静的完成并且返回null</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> CountedCompleter&lt;?&gt; nextComplete() &#123;</span><br><span class="line">        CountedCompleter&lt;?&gt; p;</span><br><span class="line">        <span class="keyword">if</span> ((p = completer) != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> p.firstComplete();</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            quietlyComplete();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//等效于getRoot.quietlyCompleteRoot</span></span><br><span class="line">    <span class="comment">//遍历到root的completer执行quietlyComplete</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">quietlyCompleteRoot</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (CountedCompleter&lt;?&gt; a = <span class="keyword">this</span>, p;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((p = a.completer) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                a.quietlyComplete();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            a = p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果当前task尚未完成，尝试去运行指定数量的未运行的完成路径上的任务</span></span><br><span class="line">    <span class="comment">//当前任务处于他们的完成路径上、实现特殊的工作窃取</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">helpComplete</span><span class="params">(<span class="keyword">int</span> maxTasks)</span> </span>&#123;</span><br><span class="line">        Thread t; ForkJoinWorkerThread wt;</span><br><span class="line">        <span class="keyword">if</span> (maxTasks &gt; <span class="number">0</span> &amp;&amp; status &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//判断当前线程是否是ForkJoinWorkerThread</span></span><br><span class="line">            <span class="keyword">if</span> ((t = Thread.currentThread()) <span class="keyword">instanceof</span> ForkJoinWorkerThread)</span><br><span class="line">                (wt = (ForkJoinWorkerThread)t).pool.</span><br><span class="line">                <span class="comment">//尝试执行当前任务并尝试从线程的工作队列中尝试帮助前置任务执行</span></span><br><span class="line">                    helpComplete(wt.workQueue, <span class="keyword">this</span>, maxTasks);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">//使用common池的externalHelpComplete方法</span></span><br><span class="line">                ForkJoinPool.common.externalHelpComplete(<span class="keyword">this</span>, maxTasks);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//支持FJT的异常传播</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">internalPropagateException</span><span class="params">(Throwable ex)</span> </span>&#123;</span><br><span class="line">        CountedCompleter&lt;?&gt; a = <span class="keyword">this</span>, s = a;</span><br><span class="line">        <span class="comment">//循环判断每一个task是否需要传递异常给completer</span></span><br><span class="line">        <span class="comment">//无代码体的while循环、神迹</span></span><br><span class="line">        <span class="keyword">while</span> (a.onExceptionalCompletion(ex, s) &amp;&amp;</span><br><span class="line">               <span class="comment">//需要传递给completer并且具备completer并且completer还不是完成态</span></span><br><span class="line">               (a = (s = a).completer) != <span class="keyword">null</span> &amp;&amp; a.status &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">               <span class="comment">//使用completer去记录异常的完成、记录成功进入下轮的循环</span></span><br><span class="line">               a.recordExceptionalCompletion(ex) == EXCEPTIONAL)</span><br><span class="line">            ;</span><br><span class="line">        </span><br><span class="line">   <span class="comment">//因为onExceptionalCompletion固定返回true,若没有中间完成的任务</span></span><br><span class="line">        <span class="comment">//直到最后一个completer,也就是root,root不具备completer,将中断循环</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写的exec</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">exec</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//直接调用了compute方法并且返回false</span></span><br><span class="line">        <span class="comment">//在ForkJoinTask中的doExec方法调用了exce后得到true，将执行setCompletion操作</span></span><br><span class="line">        <span class="comment">//主要将在首次唤醒等待结果的线程</span></span><br><span class="line">        <span class="comment">//此处return false将不再执行上述的操作</span></span><br><span class="line">        compute();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getRawResult</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">null</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setRawResult</span><span class="params">(T t)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe U;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> PENDING;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            U = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">            PENDING = U.objectFieldOffset</span><br><span class="line">                (CountedCompleter.class.getDeclaredField("pending"));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;1.完成态/异常态之间的切换：<code>internalPropagateException</code>置空了实现，对于不同方式的实现、需要不同的传递行为。重写的<code>internalPropagateException</code>不断的判断当前任务是否要将异常信号传递给链上的下一个任务，让后让未完成的<code>completer</code>去记录同一个异常ex。</p><p>&emsp;&emsp;2.只要<code>completer</code>完成过，显然while循环中断，当前<code>completer</code>和后续的<code>completer</code>将不会被处理：</p><p>如果后续的<code>completer</code>已经出现过了异常，也会走一遍同样的逻辑，传递给后面的<code>completer</code>，如果它正常完成，也必然要有相应向后传递的行为。</p><p>&emsp;&emsp;3.如果传递异常的任务本身就是另一个或者几个任务的<code>completer</code>、它的异常信息显然不会进行反向传递：</p><p>&emsp;&emsp;&emsp;&emsp;(1)<code>tryComplete</code>方法会产生两个结果：<code>completer</code>链前方的某一个<code>completer</code>的挂起任务数-1，或者<code>completer</code>前方的某一个<code>completer(root)</code>的<code>quietlyComplete</code>被执行。</p><p>&emsp;&emsp;&emsp;&emsp;(2)<code>tryComplete</code>仅会对<code>root</code>执行<code>quietlyComplete</code>进而执行<code>setComplete</code>,而对于链上的其他任务，最多帮其挂起数-1，而不会将他们设置为完成状态。但是线程池在执行任务时，<code>invoke</code>,<code>doExce</code>,<code>get</code>操作都会将<code>setComplete</code>。</p><p>&emsp;&emsp;&emsp;&emsp;(3)每一个<code>CountedCompelet</code>都可能有自己的<code>completer</code>栈链，而每一个<code>CountedComplete</code>也可以位于其他的<code>CountedComplete</code>的栈链上且上游不唯一，下游唯一，任何一条栈链仅有一个<code>root</code>，且<code>root</code>的<code>completer</code>为null。</p><p>&emsp;&emsp;&emsp;&emsp;(4)<code>tryComplete</code>只能向前影响到链上的<code>completer</code>，所以随时可以将一些<code>completer</code>的数量设置为任意数，所以可能出现下一个<code>completer</code>的挂起数为0，但是下下一个<code>completer</code>只能安静的完成或者将其挂起数-1。</p><p>&emsp;&emsp;&emsp;&emsp;(5)<code>helpComplete</code>方法主要用于工作窃取，非<code>common</code>线程池窃取的时自己的任务。</p><p>&emsp;&emsp;我们可能会有各种各样的情景,<code>ForkJoin</code>框架无法阻止我们对<code>ForkJoinTask</code>的<code>exec</code>函数进行任意式的扩展,也无法阻止我们对<code>CountedCompleter</code>的<code>compute</code>任意扩展,那么如何在我们任意拓展的情景下保持效率和健壮?比如下面这个使用场景:</p><p>&emsp;&emsp;&emsp;a.建立一种<code>ForkJoinTask</code>,直接继承<code>CountedCompleter</code>并重写<code>compute</code>方法,则它可以运行在<code>ForkJoinPool</code>中.</p><p>&emsp;&emsp;&emsp;b.我们接下来在<code>compute</code>方法中多次根据计算结果集的大小进行拆分并递归fork子任务入池,父任务成为子任务的<code>completer</code>,同时<code>compute</code>方法自身也负责不可拆分的计算逻辑,并在自身这一块计算结束后,可能等待所有fork入池的子任务结束,也可能不等待子任务,直接结束父任务,让线程空出来做其他的事.</p><p>&emsp;&emsp;&emsp;c.所有子任务结束后,使用一个合并函数合并子任务的结果集和自身的结果,并作为最终的结果.然后<code>tryComplete</code>(如果b中使用了join,或者判断当前任务是root).</p><p>&emsp;&emsp;&emsp;显然,b中fork出的子任务,也同样要执行bc的逻辑.那么可能出现这样的情况:</p><p>不同的父任务子任务在<code>ForkJoinPool</code>最初始压入当前工作线程的队列中,但随时可能被其他工作线程甚至外部线程偷去执行.</p><p>&emsp;&emsp;&emsp;父任务抢先抢得运行资源,运行完自己计算的部分,而入池的子任务及子孙任务有大量未完成.</p><p>难道父任务的执行线程就这样干等?ForkJoin框架适宜多计算,轻io,轻阻塞的情况,且本身就是为了避免线程忙的忙死饿的饿死,因此每个任务等待子任务执行结束是不可取的,这或许也是为什么有了<code>ForkJoinTask</code>,却还要有<code>CountedCompleter</code>的原因之一吧.</p><p>&emsp;&emsp;&emsp;若我们在任何每一个任务中只是单纯地将该分出去的子任务fork入池并执行自己那一部分,并不让当前线程join子任务呢?(事实上不join子任务恰好可以将当前线程的资源腾出来做其他的事)</p><p>&emsp;&emsp;&emsp;所以,除了前面提到的若干种向前影响<code>completer</code>栈链的挂起数或root的完成态,还需要一个能向栈链后方有所影响的操作,比如帮助子任务的完成,毕竟子任务也是b中fork出来且由自己入队的.</p><p>&emsp;&emsp;&emsp;<code>helpComplete</code>方法就可以做到这一点,它在<code>ForkJoinPool</code>中,它仅应在当前任务未完成时使用,首先它会尝试将当前任务从出队列并执行(<code>ForkJoinPool::popCC</code>及成功后续doExec,LIFO),出队失败则表示正在被执行甚至被偷去执行.出队这一步之后,再尝试自己的线程工作队列中找出自己的子孙任务(FIFO)并进行执行(<code>ForkJoinPool::pollAndExecCC</code>).</p><p>&emsp;&emsp;&emsp;而若执行完某个父任务的工作线程必然会调用tryComplete等有关方法,将自身或栈链后方的某一个<code>completer</code>的挂起数减一,甚至因为一些不合理的api使用(如直接更改了后方某个任务的挂起数量)而直接终止了root,将root任务标记成完成态.(注意前面强调的”运行完自己计算的部分”,这就是否定本句话的关键了,前面也说明<code>helpComplete</code>仅在当前任务未完成时使用,显然,完成了自己负责的计算内容并不代表当前任务完成了,因为它的子任务还没有完成,因此它不会调用<code>tryComplete</code>,并且可以去帮助子任务)</p><p>&emsp;&emsp;&emsp;同时,执行完父任务负责的计算内容的任务线程也会去找它栈链后方的其他任务,按照b的逻辑,这将是它的子任务,帮助它们完成,每完成一个子任务(子任务无子任务,不再help的情况),会进行<code>tryComplete</code>传递一次.</p><h2 id="ForkJoinWorkerThread-1"><a href="#ForkJoinWorkerThread-1" class="headerlink" title="ForkJoinWorkerThread"></a>ForkJoinWorkerThread</h2><p>&emsp;&emsp;<code>ForkJoinTask</code>被声称是一个轻量于普通线程和Future的实体,而它在ForkJoinPool中的运行载体便是<code>ForkJoinWorkerThread</code>,这个轻量究竟体现在何处?</p><h3 id="类声明-1"><a href="#类声明-1" class="headerlink" title="类声明"></a>类声明</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinWorkerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span></span><br></pre></td></tr></table></figure><h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//每个ForkJoinWorkerThread都只能属于一个线程池,且保存该池的引用</span></span><br><span class="line"><span class="keyword">final</span> ForkJoinPool pool; </span><br><span class="line"><span class="comment">//每个ForkJoinWorkerThread都有一个工作队列</span></span><br><span class="line"><span class="comment">//显然队列中的任务就是该线程干活的最小单位了</span></span><br><span class="line"><span class="comment">//它也是工作窃取机制的核心</span></span><br><span class="line"><span class="keyword">final</span> ForkJoinPool.WorkQueue workQueue;</span><br></pre></td></tr></table></figure><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指定线程池</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">ForkJoinWorkerThread</span><span class="params">(ForkJoinPool pool)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 线程名称</span></span><br><span class="line">    <span class="keyword">super</span>(<span class="string">"aForkJoinWorkerThread"</span>);</span><br><span class="line">    <span class="keyword">this</span>.pool = pool;</span><br><span class="line">    <span class="comment">//将工作线程注册到ForkJoinPool后会返回一个工作队列</span></span><br><span class="line">    <span class="comment">//供当前线程使用和供其他线程偷取</span></span><br><span class="line">    <span class="keyword">this</span>.workQueue = pool.registerWorker(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指定线程组</span></span><br><span class="line">ForkJoinWorkerThread(ForkJoinPool pool, ThreadGroup threadGroup,</span><br><span class="line">                     AccessControlContext acc) &#123;</span><br><span class="line">    <span class="keyword">super</span>(threadGroup, <span class="keyword">null</span>, <span class="string">"aForkJoinWorkerThread"</span>);</span><br><span class="line">    <span class="comment">//inheritedAccessControlContext是从Thread继承下来的</span></span><br><span class="line">    <span class="comment">//字面意思是继承的访问控制上下文,设置为acc.</span></span><br><span class="line">    U.putOrderedObject(<span class="keyword">this</span>, INHERITEDACCESSCONTROLCONTEXT, acc);</span><br><span class="line">    <span class="comment">//注册入池之前,清除掉本地化信息</span></span><br><span class="line">    eraseThreadLocals(); </span><br><span class="line">    <span class="keyword">this</span>.pool = pool;</span><br><span class="line">    <span class="keyword">this</span>.workQueue = pool.registerWorker(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h4 id="getPool"><a href="#getPool" class="headerlink" title="getPool"></a>getPool</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回注册的线程池</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ForkJoinPool <span class="title">getPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pool;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="getPoolIndex"><a href="#getPoolIndex" class="headerlink" title="getPoolIndex"></a>getPoolIndex</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回当前线程工作队列在池中的索引</span></span><br><span class="line"><span class="comment">//每个队列都会维护一个在池中的索引.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPoolIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> workQueue.getPoolIndex();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="onStart"><a href="#onStart" class="headerlink" title="onStart"></a>onStart</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//空函数,可交给子类实现</span></span><br><span class="line"><span class="comment">//它的作用是在构造之后处理任务之前</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="onTermination"><a href="#onTermination" class="headerlink" title="onTermination"></a>onTermination</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//工作线程终止时的勾子方法</span></span><br><span class="line"><span class="comment">//负责执行一些有关的清理操作</span></span><br><span class="line"><span class="comment">//但是若要重写它,必须在方法的最后调用super.onTermination</span></span><br><span class="line"><span class="comment">//参数exception是造成该线程终止的异常</span></span><br><span class="line"><span class="comment">//若是正常结束,则它是null.</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onTermination</span><span class="params">(Throwable exception)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="run"><a href="#run" class="headerlink" title="run"></a>run</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//ForkJoinPool中会有一个WorkQueue的数组</span></span><br><span class="line">    <span class="comment">//在取消线程的注册后本线程关联的WorkQueue会从该数组移除</span></span><br><span class="line">    <span class="comment">//但WorkQueue中的array不会置空.</span></span><br><span class="line">    <span class="keyword">if</span> (workQueue.array == <span class="keyword">null</span>) &#123;</span><br><span class="line">        Throwable exception = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//前置操作函数</span></span><br><span class="line">            onStart();</span><br><span class="line">            <span class="comment">//用线程池的runWorker方法执行,传入队列</span></span><br><span class="line">            pool.runWorker(workQueue);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            <span class="comment">//发生异常,中断前记录下来</span></span><br><span class="line">            exception = ex;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//将记录下来的异常调用勾子方法.</span></span><br><span class="line">                onTermination(exception);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                <span class="keyword">if</span> (exception == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="comment">//执行勾子方法本身出现了异常,记录下来</span></span><br><span class="line">                    exception = ex;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//调用线程池的解除注册方法,会将本线程的WorkQueue从数组中移除,同时使用上述异常.</span></span><br><span class="line">                pool.deregisterWorker(<span class="keyword">this</span>, exception);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="eraseThreadLocals"><a href="#eraseThreadLocals" class="headerlink" title="eraseThreadLocals"></a>eraseThreadLocals</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//擦除本地变量</span></span><br><span class="line"><span class="comment">//把当前线程的两个ThreadLocalMap全部置空</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">eraseThreadLocals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    U.putObject(<span class="keyword">this</span>, THREADLOCALS, <span class="keyword">null</span>);</span><br><span class="line">    U.putObject(<span class="keyword">this</span>, INHERITABLETHREADLOCALS, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="afterTopLevelExec"><a href="#afterTopLevelExec" class="headerlink" title="afterTopLevelExec"></a>afterTopLevelExec</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//每正常运行完一次顶级task,就调用一次它</span></span><br><span class="line"><span class="comment">//这个顶级任务自带易误解天性</span></span><br><span class="line"><span class="comment">//其实可以理解为每一次从队列取出的任务</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterTopLevelExec</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="子类"><a href="#子类" class="headerlink" title="子类"></a>子类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不具备任何特殊权限</span></span><br><span class="line"><span class="comment">//也不是用户定义的任何线程组的成员,每次运行完一个顶级任务</span></span><br><span class="line"><span class="comment">//则擦除本地化变量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">InnocuousForkJoinWorkerThread</span> <span class="keyword">extends</span> <span class="title">ForkJoinWorkerThread</span> </span>&#123;</span><br><span class="line">   <span class="comment">//自已创建默认线程组.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadGroup innocuousThreadGroup =</span><br><span class="line">        createThreadGroup();</span><br><span class="line">    <span class="comment">//访问控制上下文支持权限.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AccessControlContext INNOCUOUS_ACC =</span><br><span class="line">        <span class="keyword">new</span> AccessControlContext(</span><br><span class="line">            <span class="keyword">new</span> ProtectionDomain[] &#123;</span><br><span class="line">                <span class="keyword">new</span> ProtectionDomain(<span class="keyword">null</span>, <span class="keyword">null</span>)</span><br><span class="line">            &#125;);</span><br><span class="line">    <span class="comment">//构造函数.</span></span><br><span class="line">    InnocuousForkJoinWorkerThread(ForkJoinPool pool) &#123;</span><br><span class="line">        <span class="keyword">super</span>(pool, innocuousThreadGroup, INNOCUOUS_ACC);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">afterTopLevelExec</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//在每一次从队列取出的"顶级"任务运行后即擦除本地化变量.</span></span><br><span class="line">        eraseThreadLocals();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> ClassLoader <span class="title">getContextClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果获取线程上下文类加载器,永远直接返回系统类加载器.</span></span><br><span class="line">        <span class="keyword">return</span> ClassLoader.getSystemClassLoader();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//尝试对未捕获异常处理器的设置,忽略.</span></span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUncaughtExceptionHandler</span><span class="params">(UncaughtExceptionHandler x)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//禁止直接设置线程的上下文类加载器.</span></span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContextClassLoader</span><span class="params">(ClassLoader cl)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(<span class="string">"setContextClassLoader"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建一个以顶级线程组为父的线程组.</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ThreadGroup <span class="title">createThreadGroup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sun.misc.Unsafe u = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">            Class&lt;?&gt; tk = Thread<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">            Class&lt;?&gt; gk = ThreadGroup<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">            <span class="keyword">long</span> tg = u.objectFieldOffset(tk.getDeclaredField(<span class="string">"group"</span>));</span><br><span class="line">            <span class="keyword">long</span> gp = u.objectFieldOffset(gk.getDeclaredField(<span class="string">"parent"</span>));</span><br><span class="line">            <span class="comment">//当前线程的所属组.</span></span><br><span class="line">            ThreadGroup group = (ThreadGroup)</span><br><span class="line">                u.getObject(Thread.currentThread(), tg);</span><br><span class="line">            <span class="comment">//循环条件,当前线程的所属组不是null</span></span><br><span class="line">            <span class="keyword">while</span> (group != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//不停地循环向上取parent</span></span><br><span class="line">                ThreadGroup parent = (ThreadGroup)u.getObject(group, gp);</span><br><span class="line">                <span class="keyword">if</span> (parent == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="comment">//发现无parent的线程组,说明是系统顶级线程组</span></span><br><span class="line">                    <span class="comment">//用它当parent创建一个"无害"线程组返回.</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> ThreadGroup(group,</span><br><span class="line">                                           <span class="string">"InnocuousForkJoinWorkerThreadGroup"</span>);</span><br><span class="line">                <span class="comment">//有parent,把它赋给group开启下一轮循环.</span></span><br><span class="line">                group = parent;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">//有异常用Error包装抛出.</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//不能return就抛出Error.</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Cannot create ThreadGroup"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;1.内部维护了一个工作队列，实现任务调度以及工作窃取。</p><p>&emsp;&emsp;2.每次顶级任务运行结束、清理<code>ThreadLocal</code>,避免同线程的本地化数据被污染。</p><h3 id="并行可窃取的分治查找算法"><a href="#并行可窃取的分治查找算法" class="headerlink" title="并行可窃取的分治查找算法"></a>并行可窃取的分治查找算法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinTest2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> ForkJoinTest2().testDivideSearch();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDivideSearch</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Integer[] array = <span class="keyword">new</span> Integer[<span class="number">10000000</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++)&#123;</span><br><span class="line">            array[i] = i+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        AtomicReference&lt;Integer&gt; result = <span class="keyword">new</span> AtomicReference&lt;&gt;();</span><br><span class="line">        Integer find = <span class="keyword">new</span> Searcher&lt;&gt;(<span class="keyword">null</span>, array, result, <span class="number">0</span>,</span><br><span class="line">                array.length - <span class="number">1</span>,<span class="keyword">this</span>::match).invoke();</span><br><span class="line">        System.out.println((<span class="string">"查找结束,任务返回:"</span> + find + <span class="string">",result:&#123;"</span> + result.get()) + <span class="string">"&#125;"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Searcher</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">CountedCompleter</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> E[] array; <span class="keyword">final</span> AtomicReference&lt;E&gt; result; <span class="keyword">final</span> <span class="keyword">int</span> lo, hi;</span><br><span class="line">        <span class="keyword">final</span> Function&lt;E,Boolean&gt; matcher;</span><br><span class="line"></span><br><span class="line">        Searcher(CountedCompleter&lt;?&gt; p, E[] array, AtomicReference&lt;E&gt; result,</span><br><span class="line">                 <span class="keyword">int</span> lo, <span class="keyword">int</span> hi,Function&lt;E,Boolean&gt; matcher)&#123;</span><br><span class="line">            <span class="keyword">super</span>(p);</span><br><span class="line">            <span class="keyword">this</span>.array = array;</span><br><span class="line">            <span class="keyword">this</span>.result = result;</span><br><span class="line">            <span class="keyword">this</span>.lo = lo;</span><br><span class="line">            <span class="keyword">this</span>.hi = hi;</span><br><span class="line">            <span class="keyword">this</span>.matcher = matcher;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> l = <span class="keyword">this</span>.lo;<span class="keyword">int</span> h = <span class="keyword">this</span>.hi;</span><br><span class="line">            <span class="keyword">while</span>(result.get() == <span class="keyword">null</span> &amp;&amp; h &gt;= l)&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(h - l &gt;=<span class="number">2</span>)&#123;</span><br><span class="line">                    <span class="keyword">int</span> mid = (l + h)&gt;&gt;&gt;<span class="number">1</span>;</span><br><span class="line">                    <span class="comment">//添加挂起任务数量,这样当出现tryComplete时可以触发root的结束(未查到)</span></span><br><span class="line">                    addToPendingCount(<span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">new</span> Searcher&lt;E&gt;(<span class="keyword">this</span>,array,result,mid,h,matcher).fork();</span><br><span class="line">                    h = mid;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    E x = array[l];</span><br><span class="line">                    <span class="keyword">if</span>(matcher.apply(x) &amp;&amp;  result.compareAndSet(<span class="keyword">null</span>,x))&#123;</span><br><span class="line">                        <span class="keyword">super</span>.quietlyCompleteRoot();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当前未有任何一个线程查到结果,当前任务也完成了子集查找,减少一个挂起数量,若挂起数已减至0则终止.</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">null</span> == result.get())</span><br><span class="line">                tryComplete();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(Integer x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &gt; <span class="number">2000000</span> &amp;&amp;  x%<span class="number">2</span> ==<span class="number">0</span> &amp;&amp; x%<span class="number">3</span> == <span class="number">0</span> &amp;&amp; x%<span class="number">5</span> ==<span class="number">0</span> &amp;&amp; x %<span class="number">7</span> ==<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;1.对任务分治，拆分成为足够多的子任务，剩下的不需要再进行拆分的父任务由当前的线程去执行。</p><p>&emsp;&emsp;2.子任务压入工作队列，其他空闲的线程则会进行工作窃取并且完成该任务。</p><p>&emsp;&emsp;3.此时若是某个任务的子任务查找到期望数据以后会将它放入<code>result</code>，并且安静的完成根任务。</p><p>&emsp;&emsp;4.此刻的任务链处于了一个尴尬的情形：查找到期望数据的子任务将<code>root</code>设置完成态，而整个非<code>root</code>链上的任务都是属于未完成。但是由于不满足条件无法退出循环，但是此刻已经得到了自己所期望的数据，那么任务的<code>status</code>依旧为未完成，是否存在了重复执行的问题？</p><p>&emsp;&emsp;5.由于<code>ForkJoinTask</code>肯定是由<code>ForkJoinPool</code>进行统一的调度，在<code>common</code>池中，任务执行前必须出队，尽管<code>compute</code>方法没有将这些任务设置为完成态，但是任务不会重复执行。所以<code>compute</code>方法会因为中止循环而结束，此后的方法都不存在任何的外部引用而会被GC回收，即使存在，用它去获取子孙任务的执行情况或者<code>result</code>也是没有任何实际的意义的。</p><h3 id="跨节点（Map-Reduce）"><a href="#跨节点（Map-Reduce）" class="headerlink" title="跨节点（Map,Reduce）"></a>跨节点（Map,Reduce）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinTest3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> ForkJoinTest3().testMapReduce();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMapReduce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Integer[] array = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        <span class="comment">//方法一.</span></span><br><span class="line">        Integer result = <span class="keyword">new</span> MapRed&lt;&gt;(<span class="keyword">null</span>, array, (a)-&gt;a+<span class="number">2</span>, (a,b)-&gt;a+b,  <span class="number">0</span>,array.length).invoke();</span><br><span class="line">        System.out.println(<span class="string">"方法一result:&#123;"</span> + result + <span class="string">"&#125;"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第一种map reduce方式,很好理解.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;E&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">MapRed</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">CountedCompleter</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> E[] array;</span><br><span class="line">        <span class="keyword">final</span> MyMapper&lt;E&gt; mapper;</span><br><span class="line">        <span class="keyword">final</span> MyReducer&lt;E&gt; reducer;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> lo, hi;</span><br><span class="line">        <span class="comment">//兄弟节点的引用</span></span><br><span class="line">        MapRed&lt;E&gt; sibling;</span><br><span class="line">        E result;</span><br><span class="line"></span><br><span class="line">        MapRed(CountedCompleter&lt;?&gt; p, E[] array, MyMapper&lt;E&gt; mapper,</span><br><span class="line">               MyReducer&lt;E&gt; reducer, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi) &#123;</span><br><span class="line">            <span class="keyword">super</span>(p);</span><br><span class="line">            <span class="keyword">this</span>.array = array;</span><br><span class="line">            <span class="keyword">this</span>.mapper = mapper;</span><br><span class="line">            <span class="keyword">this</span>.reducer = reducer;</span><br><span class="line">            <span class="keyword">this</span>.lo = lo;</span><br><span class="line">            <span class="keyword">this</span>.hi = hi;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (hi - lo &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> mid = (lo + hi) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">                MapRed&lt;E&gt; left = <span class="keyword">new</span> MapRed(<span class="keyword">this</span>, array, mapper, reducer, lo, mid);</span><br><span class="line">                MapRed&lt;E&gt; right = <span class="keyword">new</span> MapRed(<span class="keyword">this</span>, array, mapper, reducer, mid, hi);</span><br><span class="line">                left.sibling = right;</span><br><span class="line">                right.sibling = left;</span><br><span class="line">                <span class="comment">//只挂起右任务</span></span><br><span class="line">                setPendingCount(<span class="number">1</span>);</span><br><span class="line">                right.fork();</span><br><span class="line">                <span class="comment">//直接运算左任务.</span></span><br><span class="line">                left.compute();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (hi &gt; lo)</span><br><span class="line">                    result = mapper.apply(array[lo]);</span><br><span class="line">                <span class="comment">//它会依次调用onCompletion.并且是自己调自己或completer调子,</span></span><br><span class="line">                <span class="comment">//且只有左右两个子后完成的能调成功(父任务的挂起数达到0).</span></span><br><span class="line">                tryComplete();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompletion</span><span class="params">(CountedCompleter&lt;?&gt; caller)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//忽略自己调自己.</span></span><br><span class="line">            <span class="keyword">if</span> (caller != <span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="comment">//参数是子任务.</span></span><br><span class="line">                MapRed&lt;E&gt; child = (MapRed&lt;E&gt;) caller;</span><br><span class="line">                MapRed&lt;E&gt; sib = child.sibling;</span><br><span class="line">                <span class="comment">//设置父的result.</span></span><br><span class="line">                <span class="keyword">if</span> (sib == <span class="keyword">null</span> || sib.result == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    result = child.result;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    result = reducer.apply(child.result, sib.result);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> E <span class="title">getRawResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * mapper和reducer简单的不能再简单</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@FunctionalInterface</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyMapper</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function">E <span class="title">apply</span><span class="params">(E e)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@FunctionalInterface</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyReducer</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function">E <span class="title">apply</span><span class="params">(E a, E b)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;1.第一步也是将任务进行分治拆解，将任务拆分成为左边和右边。</p><p>&emsp;&emsp;2.左边直接由父任务执行，也可能会再次拆分，右边则加入线程池，每个叶子任务执行完毕后调用<code>tryComplete</code>。</p><p>&emsp;&emsp;3.会触发一系列的<code>complete</code>栈元素的挂起数下降或者完成。</p><h2 id="WorkQueue"><a href="#WorkQueue" class="headerlink" title="WorkQueue"></a>WorkQueue</h2><h3 id="类声明-2"><a href="#类声明-2" class="headerlink" title="类声明"></a>类声明</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@sun</span>.misc.Contended</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkQueue</span></span></span><br></pre></td></tr></table></figure><h3 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化线程池,owner</span></span><br><span class="line">WorkQueue(ForkJoinPool pool, ForkJoinWorkerThread owner) &#123;</span><br><span class="line">    <span class="keyword">this</span>.pool = pool;</span><br><span class="line">    <span class="keyword">this</span>.owner = owner;</span><br><span class="line">    <span class="comment">// Place indices in the center of array (that is not yet allocated)</span></span><br><span class="line">    base = top = INITIAL_QUEUE_CAPACITY &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="相关成员"><a href="#相关成员" class="headerlink" title="相关成员"></a>相关成员</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//队列内部数组的初始容量,默认是2的12次方,它必须是2的几次方,且不能小于4.</span></span><br><span class="line"><span class="comment">//但它应该设置一个较大的值来减少队列间的缓存行共享.</span></span><br><span class="line"><span class="comment">//在前面的java运行时和54篇java官方文档术语中曾提到,jvm通常会将</span></span><br><span class="line"><span class="comment">//数组放在能够共享gc标记(如卡片标记)的位置,这样每一次写都会造成严重内存竞态.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INITIAL_QUEUE_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">13</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最大内部数组容量,默认64M,也必须是2的平方,但不大于1&lt;&lt;(31-数组元素项宽度),</span></span><br><span class="line"><span class="comment">//根据官方注释,这可以确保无需计算索引概括,但定义一个略小于此的值有助于用户在</span></span><br><span class="line"><span class="comment">//系统饱合前捕获失控的程序.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_QUEUE_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">26</span>; <span class="comment">// 64M</span></span><br><span class="line"><span class="comment">// unsafe机制有关的字段.</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe U;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>  ABASE;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>  ASHIFT;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> QTOP;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> QLOCK;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> QCURRENTSTEAL;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例字段</span></span><br><span class="line"><span class="comment">// 版本号,小于0代表不活跃,注释解释奇数代表正在扫描,但从代码语义上看正好相反</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> scanState;    </span><br><span class="line"><span class="comment">// 前一个池栈控制信号(ctl),它保有前一个栈顶记录</span></span><br><span class="line"><span class="keyword">int</span> stackPred;      </span><br><span class="line"><span class="comment">// 偷盗的任务数</span></span><br><span class="line"><span class="keyword">int</span> nsteals;               </span><br><span class="line"><span class="comment">// 一个随机数,用于决定偷取任务的索引</span></span><br><span class="line"><span class="keyword">int</span> hint;        </span><br><span class="line"><span class="comment">// 配置,表示池的索引和模式</span></span><br><span class="line"><span class="keyword">int</span> config;       </span><br><span class="line"><span class="comment">// 队列锁,1表示锁了,小于0表示终止,其他情况是0.</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> qlock;     </span><br><span class="line"><span class="comment">// 底,表示下一个poll操作的插槽索引</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> base;         </span><br><span class="line"><span class="comment">// 顶,表示下一个push操作的插槽索引</span></span><br><span class="line"><span class="keyword">int</span> top;                   </span><br><span class="line"><span class="comment">// 存放任务元素的数组,初始不分配,首扩容会分配</span></span><br><span class="line">ForkJoinTask&lt;?&gt;[] array;   </span><br><span class="line"><span class="comment">// 包含该队列的池,可能在某些时刻是null</span></span><br><span class="line"><span class="keyword">final</span> ForkJoinPool pool;   </span><br><span class="line"><span class="comment">// 持有该队列的线程,如果队列是共享的,owner是null</span></span><br><span class="line"><span class="keyword">final</span> ForkJoinWorkerThread owner;</span><br><span class="line"><span class="comment">// 在调用park阻塞的owner,非阻塞时为null</span></span><br><span class="line"><span class="keyword">volatile</span> Thread parker;    </span><br><span class="line"><span class="comment">// 被在awaitJoin中join的task</span></span><br><span class="line"><span class="keyword">volatile</span> ForkJoinTask&lt;?&gt; currentJoin;  </span><br><span class="line"><span class="comment">// 字面意思当前偷的任务,主要用来helpStealer方法使用</span></span><br><span class="line"><span class="keyword">volatile</span> ForkJoinTask&lt;?&gt; currentSteal;</span><br></pre></td></tr></table></figure><h3 id="静态函数"><a href="#静态函数" class="headerlink" title="静态函数"></a>静态函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        U = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">        Class&lt;?&gt; wk = WorkQueue<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        Class&lt;?&gt; ak = ForkJoinTask[]<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        <span class="comment">//top字段的句柄.</span></span><br><span class="line">        QTOP = U.objectFieldOffset</span><br><span class="line">            (wk.getDeclaredField(<span class="string">"top"</span>));</span><br><span class="line">        <span class="comment">//qlock字段的句柄.</span></span><br><span class="line">        QLOCK = U.objectFieldOffset</span><br><span class="line">            (wk.getDeclaredField(<span class="string">"qlock"</span>));</span><br><span class="line">        <span class="comment">//currentSteal的句柄</span></span><br><span class="line">        QCURRENTSTEAL = U.objectFieldOffset</span><br><span class="line">            (wk.getDeclaredField(<span class="string">"currentSteal"</span>));</span><br><span class="line">        <span class="comment">//ABASE是ForkJoinTask数组的首地址.</span></span><br><span class="line">        ABASE = U.arrayBaseOffset(ak);</span><br><span class="line">        <span class="comment">//scale代表数组元素的索引大小.它必须是2的平方.</span></span><br><span class="line">        <span class="keyword">int</span> scale = U.arrayIndexScale(ak);</span><br><span class="line">        <span class="keyword">if</span> ((scale &amp; (scale - <span class="number">1</span>)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"data type scale not a power of two"</span>);</span><br><span class="line">        <span class="comment">//计算ASHIFT,它是31与scale的高位0位数量的差值.因为上一步约定了scale一定是一个正的2的几次方,</span></span><br><span class="line">        <span class="comment">//ASHIFT的结果一定会大于1.可以理解ASHIFT是数组索引大小的有效位数.</span></span><br><span class="line">        ASHIFT = <span class="number">31</span> - Integer.numberOfLeadingZeros(scale);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h3><h4 id="getPoolIndex-1"><a href="#getPoolIndex-1" class="headerlink" title="getPoolIndex"></a>getPoolIndex</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回本队列在池中的索引</span></span><br><span class="line"><span class="comment">//使用config的2至4位表示</span></span><br><span class="line"><span class="comment">//因为config的最后一位是奇偶位,忽略</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getPoolIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (config &amp; <span class="number">0xffff</span>) &gt;&gt;&gt; <span class="number">1</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="queueSize"><a href="#queueSize" class="headerlink" title="queueSize"></a>queueSize</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回队列中的任务数.</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">queueSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//非owner的调用者必须先读base,用base-top,得到的结果小于0则取相反数,否则取0.</span></span><br><span class="line">    <span class="comment">//忽略即时的负数,它并不严格准确.</span></span><br><span class="line">    <span class="keyword">int</span> n = base - top;       </span><br><span class="line">    <span class="keyword">return</span> (n &gt;= <span class="number">0</span>) ? <span class="number">0</span> : -n; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="isEmpty"><a href="#isEmpty" class="headerlink" title="isEmpty"></a>isEmpty</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断队列是否为空队.本方法较为精确</span></span><br><span class="line"><span class="comment">//对于近空队列,要检查是否有至少一个未被占有的任务</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ForkJoinTask&lt;?&gt;[] a; <span class="keyword">int</span> n, m, s;</span><br><span class="line">    <span class="comment">//base大于等于top,说明空了.</span></span><br><span class="line">    <span class="keyword">return</span> ((n = base - (s = top)) &gt;= <span class="number">0</span> ||</span><br><span class="line">            <span class="comment">//有容量,且恰好计算为1,可能只有一个任务.</span></span><br><span class="line">            (n == -<span class="number">1</span> &amp;&amp; </span><br><span class="line">             <span class="comment">//计算为1,再验数组是不是空的.          </span></span><br><span class="line">             ((a = array) == <span class="keyword">null</span> || (m = a.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">              <span class="comment">//取该位置元素的值判空,空则说明isEmpty.</span></span><br><span class="line">              <span class="comment">//取值的方式是取ForkJoinTask.class首地址加上偏移量(数组长度减一(最后一个元素位置,经典案例32-1)与运算top减一左移ASHIFT(索引大小有效位数)位)的值.</span></span><br><span class="line">              U.getObject</span><br><span class="line">              (a, (<span class="keyword">long</span>)((m &amp; (s - <span class="number">1</span>)) &lt;&lt; ASHIFT) + ABASE) == <span class="keyword">null</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="push"><a href="#push" class="headerlink" title="push"></a>push</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将一个任务压入队列,前文提过的fork最终就会压队</span></span><br><span class="line"><span class="comment">//但此方法只能由非共享队列的持有者调用</span></span><br><span class="line"><span class="comment">//当使用线程池的"外部压入"externalPush方法时,压入共享队列.</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(ForkJoinTask&lt;?&gt; task)</span> </span>&#123;</span><br><span class="line">    ForkJoinTask&lt;?&gt;[] a; ForkJoinPool p;</span><br><span class="line">    <span class="comment">//保存当时的base top.</span></span><br><span class="line">    <span class="keyword">int</span> b = base, s = top, n;</span><br><span class="line">    <span class="comment">//如果数组被移除则忽略.</span></span><br><span class="line">    <span class="keyword">if</span> ((a = array) != <span class="keyword">null</span>) &#123; </span><br><span class="line">        <span class="comment">//数组最后一个下标</span></span><br><span class="line">        <span class="comment">//如长度32,则m取31这个质数.此时保存一个m,对于保存后其他push操作相当于打了屏障.</span></span><br><span class="line">        <span class="keyword">int</span> m = a.length - <span class="number">1</span>; </span><br><span class="line">        <span class="comment">//向数组中的指定位置压入该任务</span></span><br><span class="line">        <span class="comment">//位置包含上面的m和s进行与运算(数组中的位置)</span></span><br><span class="line">        <span class="comment">//结果左移索引有效长度位(索引长度),再加上数组首索引偏移量(起始地址).  </span></span><br><span class="line">        U.putOrderedObject(a, ((m &amp; s) &lt;&lt; ASHIFT) + ABASE, task);</span><br><span class="line">        <span class="comment">//将top加1.</span></span><br><span class="line">        U.putOrderedInt(<span class="keyword">this</span>, QTOP, s + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> ((n = s - b) &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//计算旧的任务数量,发现不大于1个</span></span><br><span class="line">            <span class="comment">//说明原来很可能工作线程正在阻塞等待新的任务.需要唤醒它.</span></span><br><span class="line">            <span class="keyword">if</span> ((p = pool) != <span class="keyword">null</span>)</span><br><span class="line">                <span class="comment">//signalWork会根据情况,添加新的工作线程或唤醒等待任务的线程.</span></span><br><span class="line">                p.signalWork(p.workQueues, <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (n &gt;= m)<span class="comment">//2.</span></span><br><span class="line">            <span class="comment">//任务数量超出了,对数组扩容.</span></span><br><span class="line">            growArray();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="growArray"><a href="#growArray" class="headerlink" title="growArray"></a>growArray</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加任务过程主流程无锁,包括可能出现的growArray</span></span><br><span class="line"><span class="comment">//当原队列为空时,它会初始化一个数组,否则扩容一倍</span></span><br><span class="line"><span class="comment">//持有者调用时,不需要加锁</span></span><br><span class="line"><span class="comment">//但当其他线程调用时,需要持有锁.在resize过程中,base可以移动,但top不然</span></span><br><span class="line"><span class="keyword">final</span> ForkJoinTask&lt;?&gt;[] growArray() &#123;</span><br><span class="line">    <span class="comment">//记录老数组.</span></span><br><span class="line">    ForkJoinTask&lt;?&gt;[] oldA = array;</span><br><span class="line">    <span class="comment">//根据老数组决定新容量,老数组空则INITIAL_QUEUE_CAPACITY否则国倍.</span></span><br><span class="line">    <span class="keyword">int</span> size = oldA != <span class="keyword">null</span> ? oldA.length &lt;&lt; <span class="number">1</span> : INITIAL_QUEUE_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (size &gt; MAXIMUM_QUEUE_CAPACITY)</span><br><span class="line">        <span class="comment">//新大小大于最大数组大小则拒绝.</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(<span class="string">"Queue capacity exceeded"</span>);</span><br><span class="line">    <span class="keyword">int</span> oldMask, t, b;</span><br><span class="line">    <span class="comment">//直接将原来的数组引用替换成新的.</span></span><br><span class="line">    ForkJoinTask&lt;?&gt;[] a = array = <span class="keyword">new</span> ForkJoinTask&lt;?&gt;[size];</span><br><span class="line">    <span class="comment">//如果是初次分配,就此打住返回a,是扩容,且老数组非空则进入下面的循环拷贝.</span></span><br><span class="line">    <span class="keyword">if</span> (oldA != <span class="keyword">null</span> &amp;&amp; (oldMask = oldA.length - <span class="number">1</span>) &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (t = top) - (b = base) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//根据前面的运算,size一定是2的幂,减一用来哈希,这是经典处理办法.</span></span><br><span class="line">        <span class="keyword">int</span> mask = size - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123; </span><br><span class="line">            ForkJoinTask&lt;?&gt; x;</span><br><span class="line">            <span class="comment">//老数组base自增过若干次的得到b,它代表的元素对应的索引.</span></span><br><span class="line">            <span class="keyword">int</span> oldj = ((b &amp; oldMask) &lt;&lt; ASHIFT) + ABASE;</span><br><span class="line">            <span class="comment">//用b在新数组中找出索引.</span></span><br><span class="line">            <span class="keyword">int</span> j    = ((b &amp;    mask) &lt;&lt; ASHIFT) + ABASE;</span><br><span class="line">            <span class="comment">//老数组中用索引取出元素.</span></span><br><span class="line">            x = (ForkJoinTask&lt;?&gt;)U.getObjectVolatile(oldA, oldj);</span><br><span class="line">            <span class="keyword">if</span> (x != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                <span class="comment">//老数组置空,放入新数组.</span></span><br><span class="line">                U.compareAndSwapObject(oldA, oldj, x, <span class="keyword">null</span>))</span><br><span class="line">                U.putObjectVolatile(a, j, x);</span><br><span class="line">            <span class="comment">//每处理完一个task,就将base自增1,直到top为止.</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (++b != t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回新数组.</span></span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="pop"><a href="#pop" class="headerlink" title="pop"></a>pop</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//存在下一个任务,弹出,顺序是后进先出.此方法仅限非共享队列的owner调用</span></span><br><span class="line"><span class="keyword">final</span> ForkJoinTask&lt;?&gt; pop() &#123;</span><br><span class="line">    ForkJoinTask&lt;?&gt;[] a; ForkJoinTask&lt;?&gt; t; <span class="keyword">int</span> m;</span><br><span class="line">    <span class="comment">//还有元素.</span></span><br><span class="line">    <span class="keyword">if</span> ((a = array) != <span class="keyword">null</span> &amp;&amp; (m = a.length - <span class="number">1</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//1.top至少比base大一.注意,每次循环都会读出新的top,它是volatile修饰的</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> s; (s = top - <span class="number">1</span>) - base &gt;= <span class="number">0</span>;) &#123;</span><br><span class="line">            <span class="comment">//top对应的索引.</span></span><br><span class="line">            <span class="keyword">long</span> j = ((m &amp; s) &lt;&lt; ASHIFT) + ABASE;</span><br><span class="line">            <span class="comment">//2.该索引没有元素,break,返回null.而且就代表这个位置的确是null,与竞态无关</span></span><br><span class="line">            <span class="comment">//因为此方法仅owner线程使用,不会出现另一个线程计算了同样的j,且先执行了3的情况</span></span><br><span class="line">            <span class="comment">//出现这种情况,则是此位置的任务当先被执行并出栈,或者就从未设置过任务,后续分析这种极端情况</span></span><br><span class="line">            <span class="comment">//故如果出现某个任务在数组的中间</span></span><br><span class="line">            <span class="comment">//提前被执行并置空(非pop或poll方式),那么再对WorkQueue进行pop时将会中断</span></span><br><span class="line">            <span class="comment">//留下一部分null之后的任务不能出栈,所以可以允许任务非pop或poll方式查出并执行</span></span><br><span class="line">            <span class="comment">//但为了能pop出所有任务,不能中间置null.</span></span><br><span class="line">            <span class="keyword">if</span> ((t = (ForkJoinTask&lt;?&gt;)U.getObject(a, j)) == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//3.有元素,将该索引位置置null.若cas失败,说明元素被取出了</span></span><br><span class="line">            <span class="comment">//但下次循环即使在2处break并返回null,也不是因为竞态,因为每次循环到1都会读取新的top</span></span><br><span class="line">            <span class="comment">//也就有新的j</span></span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapObject(a, j, t, <span class="keyword">null</span>)) &#123;</span><br><span class="line">                <span class="comment">//数组位置置null的同时top减1.</span></span><br><span class="line">                U.putOrderedInt(<span class="keyword">this</span>, QTOP, s);</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//循环退出,说明top位置没有元素,也相当于说明数组为空</span></span><br><span class="line">    <span class="comment">//显然此方法的另一个作用是将队列压缩,空队列会将top先降到base+1</span></span><br><span class="line">    <span class="comment">//再循环最后一次将top降到base.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="pollAt"><a href="#pollAt" class="headerlink" title="pollAt"></a>pollAt</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果b是base,使用FIFO的次序尝试无竞态取底部的任务</span></span><br><span class="line"><span class="comment">//它会在ForkJoinPool的scan和helpStealer中使用.</span></span><br><span class="line"><span class="keyword">final</span> ForkJoinTask&lt;?&gt; pollAt(<span class="keyword">int</span> b) &#123;</span><br><span class="line">    ForkJoinTask&lt;?&gt; t; ForkJoinTask&lt;?&gt;[] a;</span><br><span class="line">    <span class="keyword">if</span> ((a = array) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//和前面一样的的方式计算b对应的索引j</span></span><br><span class="line">        <span class="keyword">int</span> j = (((a.length - <span class="number">1</span>) &amp; b) &lt;&lt; ASHIFT) + ABASE;</span><br><span class="line">        <span class="keyword">if</span> ((t = (ForkJoinTask&lt;?&gt;)U.getObjectVolatile(a, j)) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">            <span class="comment">//j对应位置有task且当前base==b,尝试将task出队.</span></span><br><span class="line">            base == b &amp;&amp; U.compareAndSwapObject(a, j, t, <span class="keyword">null</span>)) &#123;</span><br><span class="line">            <span class="comment">//出队成功base增1.不需要额外的同步,因为两个线程不可能同时在上面的cas成功.</span></span><br><span class="line">            <span class="comment">//当一切条件匹配(b就是base且j位置有元素),pollAt同一个b只会有一个返回非空的t.</span></span><br><span class="line">            <span class="comment">//如果多个线程传入的b不相等,在同一时刻只有一个会等于base.</span></span><br><span class="line">            base = b + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用FIFO的次序取下一个任务</span></span><br><span class="line"><span class="keyword">final</span> ForkJoinTask&lt;?&gt; poll() &#123;</span><br><span class="line">    ForkJoinTask&lt;?&gt;[] a; <span class="keyword">int</span> b; ForkJoinTask&lt;?&gt; t;</span><br><span class="line">    <span class="comment">//1.循环从base取任务,当base增长到top或其他操作重置array为null则终止循环</span></span><br><span class="line">    <span class="keyword">while</span> ((b = base) - top &lt; <span class="number">0</span> &amp;&amp; (a = array) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//前面已叙述过取索引的逻辑</span></span><br><span class="line">        <span class="comment">//使用一个top到base间的数与数组长度-1与运算并左移索引长度位再加上数组基准偏移量.后面不再缀述</span></span><br><span class="line">        <span class="keyword">int</span> j = (((a.length - <span class="number">1</span>) &amp; b) &lt;&lt; ASHIFT) + ABASE;</span><br><span class="line">        <span class="comment">//取出task</span></span><br><span class="line">        t = (ForkJoinTask&lt;?&gt;)U.getObjectVolatile(a, j);</span><br><span class="line">        <span class="comment">//2.如果发生竞态,base已经不是b,直接开启下一轮循环把新的base读给b</span></span><br><span class="line">        <span class="keyword">if</span> (base == b) &#123;</span><br><span class="line">            <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//3.当前t是base任务,用cas置空,base+1,返回t.</span></span><br><span class="line">                <span class="comment">//如果此处发生竞态,则只有一个线程可以成功返回t并重置base(4).</span></span><br><span class="line">                <span class="comment">//不成功的线程会开启下一轮循环,此时成功线程可能未来的及执行4更新base,</span></span><br><span class="line">                <span class="comment">//也可能已经更新base,则导致先前失败的线程在2处通过</span></span><br><span class="line">                <span class="comment">//经5种或判队列空返回,或非空再次循环</span></span><br><span class="line">                <span class="comment">//而在当前成功线程执行4成功后,所有前面失败的线程可以在1处读到新的base</span></span><br><span class="line">                <span class="comment">//这些线程在下一次循环中依旧只会有一个成功弹出t并重置base,直到所有线程执行完毕</span></span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapObject(a, j, t, <span class="keyword">null</span>)) &#123;</span><br><span class="line">                    <span class="comment">//4重置加返回</span></span><br><span class="line">                    base = b + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">return</span> t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//5.t取出的是空,发现此时临时变量b(其他成功线程在此轮循环前置的base)已增至top-1</span></span><br><span class="line">            <span class="comment">//且当前线程又没能成功的弹出t,说明一定会有一个线程</span></span><br><span class="line">            <span class="comment">//将t弹出并更新base到top的值,当前线程没必要再开下一个循环了,直接break并返回null</span></span><br><span class="line">            <span class="comment">//t取出的是空,但是没到top,说明只是被提前执行并置空了,那么继续读取新的base并循环</span></span><br><span class="line">            <span class="comment">//且若没有其他线程去更改base,array的长度,或者把top降到</span></span><br><span class="line">            <span class="comment">//base,则当前线程就永远死循环下去了,因为每次循环都是125且每个变量都不变.因此为避免循环,</span></span><br><span class="line">            <span class="comment">//个任务可以提前执行,但一定不能提前离队(置null).</span></span><br><span class="line">            <span class="comment">//也就是说:只能用poll或pop方式弹出任务,其他方式获得任务并执行是允许的</span></span><br><span class="line">            <span class="comment">//但不能在执行后置null,留待后续源码验证一下</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (b + <span class="number">1</span> == top) <span class="comment">// now empty</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从循环退出来有两种情况,可能是在5处满足退出条件,或者在2处发现b已经是脏数据</span></span><br><span class="line">    <span class="comment">//下轮循环不满足循环条件所致.两种都应该返回null.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="nextLocalTask"><a href="#nextLocalTask" class="headerlink" title="nextLocalTask"></a>nextLocalTask</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据mode来取下一个本队列元素.根据模式.</span></span><br><span class="line"><span class="keyword">final</span> ForkJoinTask&lt;?&gt; nextLocalTask() &#123;</span><br><span class="line">    <span class="comment">//当前WorkQueue的配置了FIFO,则poll,否则pop</span></span><br><span class="line">    <span class="comment">//尽管还未看到注册worker的源码,在此提前透露下</span></span><br><span class="line">    <span class="comment">//ForkJoinPool也有一个config(前面讲构造函数提过)</span></span><br><span class="line">    <span class="comment">//该config保存了mode信息,并原样赋给了WorkQueue的mode.注意,相应的任务会出队</span></span><br><span class="line">    <span class="keyword">return</span> (config &amp; FIFO_QUEUE) == <span class="number">0</span> ? pop() : poll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="peek"><a href="#peek" class="headerlink" title="peek"></a>peek</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据模式取出下一个任务,但是不出队</span></span><br><span class="line"><span class="keyword">final</span> ForkJoinTask&lt;?&gt; peek() &#123;</span><br><span class="line">    ForkJoinTask&lt;?&gt;[] a = array; <span class="keyword">int</span> m;</span><br><span class="line">    <span class="comment">//空队,返回null.</span></span><br><span class="line">    <span class="keyword">if</span> (a == <span class="keyword">null</span> || (m = a.length - <span class="number">1</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//根据mode定位要取的索引j</span></span><br><span class="line">    <span class="keyword">int</span> i = (config &amp; FIFO_QUEUE) == <span class="number">0</span> ? top - <span class="number">1</span> : base;</span><br><span class="line">    <span class="keyword">int</span> j = ((i &amp; m) &lt;&lt; ASHIFT) + ABASE;</span><br><span class="line">    <span class="comment">//返回读出的值,不出队</span></span><br><span class="line">    <span class="keyword">return</span> (ForkJoinTask&lt;?&gt;)U.getObjectVolatile(a, j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="tryUnpush"><a href="#tryUnpush" class="headerlink" title="tryUnpush"></a>tryUnpush</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果参数t是当前队的top,则弹出</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryUnpush</span><span class="params">(ForkJoinTask&lt;?&gt; t)</span> </span>&#123;</span><br><span class="line">    ForkJoinTask&lt;?&gt;[] a; <span class="keyword">int</span> s;</span><br><span class="line">    <span class="keyword">if</span> ((a = array) != <span class="keyword">null</span> &amp;&amp; (s = top) != base &amp;&amp;</span><br><span class="line">        <span class="comment">//1.满足非空条件.尝试用t去当当作计算出的索引位置的原任务的值并cas为null来出队</span></span><br><span class="line">        U.compareAndSwapObject</span><br><span class="line">        (a, (((a.length - <span class="number">1</span>) &amp; --s) &lt;&lt; ASHIFT) + ABASE, t, <span class="keyword">null</span>)) &#123;</span><br><span class="line">        <span class="comment">//cas成功,说明t确实是top,将top减一返回true</span></span><br><span class="line">        U.putOrderedInt(<span class="keyword">this</span>, QTOP, s);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.cas失败或不满足1的条件,返回false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="cancelAll"><a href="#cancelAll" class="headerlink" title="cancelAll"></a>cancelAll</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//移除并取消队列中所有已知的任务,忽略异常</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">cancelAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ForkJoinTask&lt;?&gt; t;</span><br><span class="line">    <span class="keyword">if</span> ((t = currentJoin) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//有currentJoin,引用置空,取消并忽略异常</span></span><br><span class="line">        currentJoin = <span class="keyword">null</span>;</span><br><span class="line">        ForkJoinTask.cancelIgnoringExceptions(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((t = currentSteal) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//有currentSteal,引用置空,取消并忽略异常</span></span><br><span class="line">        currentSteal = <span class="keyword">null</span>;</span><br><span class="line">        ForkJoinTask.cancelIgnoringExceptions(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//除了上面两个,就只剩下数组中的任务了.按LILO的顺序弹出并依次取消,忽略所有异常</span></span><br><span class="line">    <span class="keyword">while</span> ((t = poll()) != <span class="keyword">null</span>)</span><br><span class="line">        ForkJoinTask.cancelIgnoringExceptions(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="pollAndExecAll"><a href="#pollAndExecAll" class="headerlink" title="pollAndExecAll"></a>pollAndExecAll</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按FIFO顺序从队首弹出任务并执行所有非空任务</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">pollAndExecAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (ForkJoinTask&lt;?&gt; t; (t = poll()) != <span class="keyword">null</span>;)</span><br><span class="line">        <span class="comment">//很明显,如果未按严格顺序执行,先执行中间的一个任务</span></span><br><span class="line">        <span class="comment">//再调用本方法,则会半路中止</span></span><br><span class="line">        t.doExec();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="execLocalTasks"><a href="#execLocalTasks" class="headerlink" title="execLocalTasks"></a>execLocalTasks</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//移除并执行完所有本队列的任务,如果是先进先出,则执行前面的pollAndExecAll方法</span></span><br><span class="line"><span class="comment">//否则pop循环执行到空为止.按前面的分析,只要坚持只能pop或poll弹出,其他方式执行任务但不能置空的原则</span></span><br><span class="line"><span class="comment">//可以保证pop或poll出现空的情况只能是竞态发生的情况</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">execLocalTasks</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> b = base, m, s;</span><br><span class="line">    ForkJoinTask&lt;?&gt;[] a = array;</span><br><span class="line">    <span class="comment">//初始满足条件,top至少比base大1.队列非空</span></span><br><span class="line">    <span class="keyword">if</span> (b - (s = top - <span class="number">1</span>) &lt;= <span class="number">0</span> &amp;&amp; a != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">        (m = a.length - <span class="number">1</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//不是FIFO模式.</span></span><br><span class="line">        <span class="keyword">if</span> ((config &amp; FIFO_QUEUE) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (ForkJoinTask&lt;?&gt; t;;) &#123;</span><br><span class="line">                <span class="comment">//原子getAndSet,查出并弹出原本的task</span></span><br><span class="line">                <span class="keyword">if</span> ((t = (ForkJoinTask&lt;?&gt;)U.getAndSetObject</span><br><span class="line">                     (a, ((m &amp; s) &lt;&lt; ASHIFT) + ABASE, <span class="keyword">null</span>)) == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="comment">//弹出的task是空,break.说明整个工作流程中,如果未保证严格有序</span></span><br><span class="line">                    <span class="comment">//如先从中间的某个任务开始执行并且出队了,再调用execLocalTasks,会导致中间停顿</span></span><br><span class="line">                    <span class="comment">//只执行不出队,则至少不会中断.出现t是null的情况只能是竞态或末尾</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">//top减一,执行任务</span></span><br><span class="line">                U.putOrderedInt(<span class="keyword">this</span>, QTOP, s);</span><br><span class="line">                t.doExec();</span><br><span class="line">                <span class="comment">//如果base大于等于top,则中止</span></span><br><span class="line">                <span class="keyword">if</span> (base - (s = top - <span class="number">1</span>) &gt; <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//是FIFO模式,pollAndExecAll.</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pollAndExecAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="runTask"><a href="#runTask" class="headerlink" title="runTask"></a>runTask</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//重点入口方法来了,前面留下诸多关于执行任务是否出队的讨论,下面来分析入口方法</span></span><br><span class="line"><span class="comment">//该方法的入口是每个工作线程的run方法,因此只有一个线程</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runTask</span><span class="params">(ForkJoinTask&lt;?&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//传入task是空直接不理会.</span></span><br><span class="line">    <span class="keyword">if</span> (task != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//标记成忙.scanState是WorkQueue的成员变量,每个WorkQueue只有一个值</span></span><br><span class="line">        <span class="comment">//前面说过,一般情况下,每个线程会有一个WorkQueue,所以某种情况来讲也可以标记为</span></span><br><span class="line">        <span class="comment">//当前ForkJoinWorkerThread繁忙.</span></span><br><span class="line">        <span class="comment">//SCANNING常量值是1,这个操作实质上就是将scanState变量的个位置0</span></span><br><span class="line">        <span class="comment">//也就是变成了偶数并标记它要忙了</span></span><br><span class="line">        <span class="comment">//显然偶数才表示忙碌,这也是为什么前面觉得官方注释scanState是奇数表示"正在扫描"很奇怪.</span></span><br><span class="line">        scanState &amp;= ~SCANNING; </span><br><span class="line">        <span class="comment">//将currentSteal设置为传入的任务,并运行该任务,若该任务内部进行了分叉,则进入相应的入队逻辑</span></span><br><span class="line">        (currentSteal = task).doExec();</span><br><span class="line">        <span class="comment">//执行完该任务后,将currentSteal置空.将该task释放掉,帮助gc</span></span><br><span class="line">        U.putOrderedObject(<span class="keyword">this</span>, QCURRENTSTEAL, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//调用前面提到的,根据mode选择依次pop或poll的方式将自己的工作队列内的任务出队并执行的方法</span></span><br><span class="line">        execLocalTasks();</span><br><span class="line">        <span class="comment">//到此,自己队列中的所有任务都已经完成.包含偷来的任务fork后又入队到自己队列的子任务</span></span><br><span class="line">        <span class="comment">//取出owner线程.处理偷取任务有关的一些信息</span></span><br><span class="line">        ForkJoinWorkerThread thread = owner;</span><br><span class="line">        <span class="keyword">if</span> (++nsteals &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//发现当前WorkQueue偷来的任务数即将溢出了,将它转到线程池    </span></span><br><span class="line">            transferStealCount(pool);</span><br><span class="line">        <span class="comment">//取消忙碌标记.</span></span><br><span class="line">        scanState |= SCANNING;</span><br><span class="line">        <span class="keyword">if</span> (thread != <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">//执行afterTopLevelExec勾子方法,上一节中介绍ForkJoinWorkerThread时已介绍</span></span><br><span class="line">            thread.afterTopLevelExec();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//方法结束,注意,没有任何操作将task从所在的数组中移除,不论这个task是哪个WorkQueue中的元素</span></span><br><span class="line">    <span class="comment">//同时,此方法原则上讲可以多次调用(尽管事实上就一次调用)</span></span><br><span class="line">    <span class="comment">//入口处和出口处分别用忙碌标记来标记scanState,但重复标记显然不影响执行.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="transferStealCount"><a href="#transferStealCount" class="headerlink" title="transferStealCount"></a>transferStealCount</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果线程池中已经初始化了用于记录的stealCounter</span></span><br><span class="line"><span class="comment">//则用它加上当前WorkQueue的nsteals/或最大整数(发生溢出时)</span></span><br><span class="line"><span class="comment">//并初始化当前WorkQueue的nsteals</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">transferStealCount</span><span class="params">(ForkJoinPool p)</span> </span>&#123;</span><br><span class="line">    AtomicLong sc;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="keyword">null</span> &amp;&amp; (sc = p.stealCounter) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//线程池中存放了stealCounter,它是一个原子整数</span></span><br><span class="line">        <span class="keyword">int</span> s = nsteals;</span><br><span class="line">        nsteals = <span class="number">0</span>; <span class="comment">//恢复0</span></span><br><span class="line">        <span class="comment">//若nsteals是负,增加最大整数,否则增加nsteal         </span></span><br><span class="line">        sc.getAndAdd((<span class="keyword">long</span>)(s &lt; <span class="number">0</span> ? Integer.MAX_VALUE : s));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="tryRemoveAndExec"><a href="#tryRemoveAndExec" class="headerlink" title="tryRemoveAndExec"></a>tryRemoveAndExec</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//简单梳理一下tryRemoveAndExec的执行流程和生命周期.</span></span><br><span class="line"><span class="comment">//a.显然,一上来就判队列的空和参数的空,如果第一个if都进不去,按约定返回true</span></span><br><span class="line"><span class="comment">//b.经过1初始化一个内层循环,并初始化了n,它决定内循环最多跑n次</span></span><br><span class="line"><span class="comment">//如果内循环一直不break(9找到任务或12发现顶部任务是完成态),也假定一般碰不到14(发现目标任务完成了)</span></span><br><span class="line"><span class="comment">//也没有出现几种return(3查出null,14某轮内循环目标task发现被完成了)</span></span><br><span class="line"><span class="comment">//那么最终只会耗尽次数,遍历到底,在13处return false(确定此轮循环task不在队列)</span></span><br><span class="line"><span class="comment">//c.如果出现了几种break(9,12),9其实代表查到任务,12代表顶部任务已完成(官方说取消)</span></span><br><span class="line"><span class="comment">//那就会停止内循环,重新开启一轮外循环,初始化n,继续从新的top到base遍历(b).</span></span><br><span class="line"><span class="comment">//但此时,可能找不到task了(它已经在上一轮内循环出队或被替换成代理)</span></span><br><span class="line"><span class="comment">//但也可能实际上未出队(该task不是top,即4,base也发生了改变造成7未执行),那么可能在本轮循环</span></span><br><span class="line"><span class="comment">//找到任务,在b中进入相应的break,并且成功移除并会进入d,也可能没进入break而是再重复一次b</span></span><br><span class="line"><span class="comment">//d.如果某一次break成功删除了任务,那么外循环更新了n,base,top</span></span><br><span class="line"><span class="comment">//重启了一次内循环,但是所有找到task的分支不会再有了,如果接下来不再碰到被完成(取消)的顶部任务11-12</span></span><br><span class="line"><span class="comment">//同样也没发现目标task完成了(不进14),那么最终的结果就是n次内循环后n降低到0,直接return false.</span></span><br><span class="line"><span class="comment">//e.从b-d任何一次内循环在最后发现了task结束,立即返回false</span></span><br><span class="line"><span class="comment">//否则,它可能在某一次内循环中弹出并执行了该任务,却可能一直在等待它完成,因此这个机制可以让等待task完成前,</span></span><br><span class="line"><span class="comment">//帮助当前WorkQueue清理顶部无效任务等操作.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果task存在,则将它从队列中移除并执行,发现有位于顶部的取消任务,则移除之,只用于awaitJoin</span></span><br><span class="line"><span class="comment">//如果队列空并且任务不知道完成了,则返回true</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRemoveAndExec</span><span class="params">(ForkJoinTask&lt;?&gt; task)</span> </span>&#123;</span><br><span class="line">    ForkJoinTask&lt;?&gt;[] a; <span class="keyword">int</span> m, s, b, n;</span><br><span class="line">    <span class="comment">//进入if的条件,存在非空任务数组,参数task非空</span></span><br><span class="line">    <span class="keyword">if</span> ((a = array) != <span class="keyword">null</span> &amp;&amp; (m = a.length - <span class="number">1</span>) &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">        task != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//循环条件,队列非空.从s开始遍历到b,也就是从顶到底.后进先出</span></span><br><span class="line">        <span class="keyword">while</span> ((n = (s = top) - (b = base)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//1.内层循环.</span></span><br><span class="line">            <span class="keyword">for</span> (ForkJoinTask&lt;?&gt; t;;) &#123;</span><br><span class="line">                <span class="comment">//2.从顶开始的索引j,每次向下找一个.    </span></span><br><span class="line">                <span class="keyword">long</span> j = ((--s &amp; m) &lt;&lt; ASHIFT) + ABASE;</span><br><span class="line">                <span class="keyword">if</span> ((t = (ForkJoinTask&lt;?&gt;)U.getObject(a, j)) == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="comment">//3.取出的是空,返回值取决于top是不是内层循环是第一次运行</span></span><br><span class="line">                    <span class="comment">//外循环每次会将s更新为新top,</span></span><br><span class="line">                    <span class="comment">//内循环则会每次将s减一.内循环只跑了一次的情况,显然会返回true</span></span><br><span class="line">                    <span class="comment">//显然这种情况下top也没有被其他线程更新</span></span><br><span class="line">                    <span class="comment">//内循环又是第一次跑,那么将足以说明当前队列为空,该为false</span></span><br><span class="line">                    <span class="comment">//true的情况,向下遍历了几个元素打到了底</span></span><br><span class="line">                    <span class="comment">//未进入46 10这三种要重开启一轮外循环的情况,也没找到task.</span></span><br><span class="line">                    <span class="comment">//不管怎样,发现空任务就返回</span></span><br><span class="line">                    <span class="keyword">return</span> s + <span class="number">1</span> == top;<span class="comment">// 比预期短,第一个或第n个出现了空值,但循环条件未false</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (t == task) &#123;</span><br><span class="line">                    <span class="comment">//找到的任务t不是空,且是目标任务</span></span><br><span class="line">                    <span class="keyword">boolean</span> removed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (s + <span class="number">1</span> == top) &#123;</span><br><span class="line">                        <span class="comment">//4.发现是首轮内循环,s+1==top成立,进行pop操作,将task弹出并将top减一</span></span><br><span class="line">                        <span class="comment">//显然,task是最顶任务,可以用pop方式,将它置空</span></span><br><span class="line">                        <span class="keyword">if</span> (U.compareAndSwapObject(a, j, task, <span class="keyword">null</span>)) &#123;</span><br><span class="line">                            U.putOrderedInt(<span class="keyword">this</span>, QTOP, s);</span><br><span class="line">                            <span class="comment">//5.置removed为true.</span></span><br><span class="line">                            removed = <span class="keyword">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//6.不是首轮循环,而且base没有在处理期间发生改变</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (base == b) </span><br><span class="line">                        <span class="comment">//7.尝试将task替换成一个EmptyTask实例.成功则removed是true</span></span><br><span class="line">                        <span class="comment">//这样虽然该任务出了队,但在队上还有一个空的任务,而不会出现前面担心的中间null</span></span><br><span class="line">                        <span class="comment">//的情况,也不改变top或base的值</span></span><br><span class="line">                        removed = U.compareAndSwapObject(</span><br><span class="line">                        a, j, task, <span class="keyword">new</span> EmptyTask());</span><br><span class="line">                    <span class="keyword">if</span> (removed)</span><br><span class="line">                        <span class="comment">//8.只要任务成功出队(不论是4还是7,则执行</span></span><br><span class="line">                        task.doExec();</span><br><span class="line">                    <span class="comment">//9.只要找到任务,退出内循环,回到外循环重置相应的条件</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//10.本轮内循环没找到匹配task的任务.</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (t.status &lt; <span class="number">0</span> &amp;&amp; s + <span class="number">1</span> == top) &#123;<span class="comment">//官方注释是取消</span></span><br><span class="line">                    <span class="comment">//11.若t是完成的任务且是首轮内循环且top未变动,将该任务出队并令top减一</span></span><br><span class="line">                    <span class="keyword">if</span> (U.compareAndSwapObject(a, j, t, <span class="keyword">null</span>))</span><br><span class="line">                        U.putOrderedInt(<span class="keyword">this</span>, QTOP, s);</span><br><span class="line">                    <span class="comment">//12.只要进入此分支就退出内循环</span></span><br><span class="line">                    <span class="keyword">break</span>; </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (--n == <span class="number">0</span>)</span><br><span class="line">                    <span class="comment">//13.内循环每执行到此一次,就说明有一次没找到目标任务</span></span><br><span class="line">                    <span class="comment">//减少n(开始时的base top差值).达0时返回false停止循环</span></span><br><span class="line">                    <span class="comment">//即每个内循环都只能执行n次,进入外循环时重置n</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//14.结束了任何一轮内循环时,发现目标task已经完成,则停止外循环返回false</span></span><br><span class="line">            <span class="keyword">if</span> (task.status &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//15.task参数传空,或者当前WorkQueue没有任务,直接返回true</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="popCC"><a href="#popCC" class="headerlink" title="popCC"></a>popCC</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此方法适用于不论共享或者独有的模式,只在helpComplete时使用.</span></span><br><span class="line"><span class="comment">//它会弹出和task相同的CountedCompleter,在前一节讲解CountedCompleter时已介绍过此方法</span></span><br><span class="line"><span class="comment">//父Completer仅能在栈链上找到它的父和祖先completer并帮助减挂起任务数或完成root,但在此处</span></span><br><span class="line"><span class="comment">//它可以帮助栈链上的前置(子任务),前提是要popCC弹出.</span></span><br><span class="line"><span class="keyword">final</span> CountedCompleter&lt;?&gt; popCC(CountedCompleter&lt;?&gt; task, <span class="keyword">int</span> mode) &#123;</span><br><span class="line">    <span class="keyword">int</span> s; ForkJoinTask&lt;?&gt;[] a; Object o;</span><br><span class="line">    <span class="comment">//当前队列有元素.</span></span><br><span class="line">    <span class="keyword">if</span> (base - (s = top) &lt; <span class="number">0</span> &amp;&amp; (a = array) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//老逻辑从顶部确定j.</span></span><br><span class="line">        <span class="keyword">long</span> j = (((a.length - <span class="number">1</span>) &amp; (s - <span class="number">1</span>)) &lt;&lt; ASHIFT) + ABASE;</span><br><span class="line">        <span class="keyword">if</span> ((o = U.getObjectVolatile(a, j)) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">            (o <span class="keyword">instanceof</span> CountedCompleter)) &#123;</span><br><span class="line">            <span class="comment">//当前队列中存在类型为CountedCompleter的元素.对该completer栈链开启一个循环</span></span><br><span class="line">            CountedCompleter&lt;?&gt; t = (CountedCompleter&lt;?&gt;)o;</span><br><span class="line">            <span class="keyword">for</span> (CountedCompleter&lt;?&gt; r = t;;) &#123;</span><br><span class="line">                <span class="comment">//对该CountedCompleter及它的completer栈元素进行遍历,每一个遍历到的临时存放r.</span></span><br><span class="line">                <span class="comment">//找到r==task,说明有一个completer位于task的执行路径.</span></span><br><span class="line">                <span class="keyword">if</span> (r == task) &#123;</span><br><span class="line">                    <span class="comment">//mode小于0,这个mode其实有误解性</span></span><br><span class="line">                    <span class="comment">//它的调用者其实是将一个WorkQueue的config传给了这个mode.</span></span><br><span class="line">                    <span class="comment">//而config只有两处初始化,一是将线程注册到池的时候,初始化WorkQueue</span></span><br><span class="line">                    <span class="comment">//二是外部提交的任务,使用externalSubmit时新建的WorkQueue</span></span><br><span class="line">                    <span class="comment">//config会是负值且没有owner</span></span><br><span class="line">                    <span class="comment">//它也说明是共享队列,需要有锁定机制</span></span><br><span class="line">                    <span class="keyword">if</span> (mode &lt; <span class="number">0</span>) &#123; </span><br><span class="line">                        <span class="comment">//另一个字段qlock派上了用场,将它置为1表示加锁</span></span><br><span class="line">                        <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, QLOCK, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                            <span class="comment">//加锁成功,在top和array这过程中未发生变动的情况下,尝试</span></span><br><span class="line">                            <span class="comment">//将t出队,此时t是栈顶上的元素,它的completer栈链前方有task</span></span><br><span class="line">                            <span class="keyword">if</span> (top == s &amp;&amp; array == a &amp;&amp;</span><br><span class="line">                                U.compareAndSwapObject(a, j, t, <span class="keyword">null</span>)) &#123;</span><br><span class="line">                                U.putOrderedInt(<span class="keyword">this</span>, QTOP, s - <span class="number">1</span>);</span><br><span class="line">                                U.putOrderedInt(<span class="keyword">this</span>, QLOCK, <span class="number">0</span>);</span><br><span class="line">                                <span class="keyword">return</span> t;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">//不论出队成功还是失败,解锁</span></span><br><span class="line">                            U.compareAndSwapInt(<span class="keyword">this</span>, QLOCK, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//非共享队列,直接将t出列</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapObject(a, j, t, <span class="keyword">null</span>)) &#123;</span><br><span class="line">                        U.putOrderedInt(<span class="keyword">this</span>, QTOP, s - <span class="number">1</span>);</span><br><span class="line">                        <span class="keyword">return</span> t;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//只要找到,哪怕两处cas出现不成功的情况,也是竞态失败,break终止循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//r不等于task,找出r的父并开始下轮循环,直到root或找到task为止</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((r = r.completer) == <span class="keyword">null</span>) <span class="comment">// try parent</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//空队列,顶部不是Completer或者不是task的子任务,返回null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="pollAndExecCC"><a href="#pollAndExecCC" class="headerlink" title="pollAndExecCC"></a>pollAndExecCC</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//尝试在无竞态下偷取此WorkQueue中与给定task处于同一个completer栈链上的任务并运行它</span></span><br><span class="line"><span class="comment">//若不成功,返回一个校验合/控制信号给调用它的helpComplete方法</span></span><br><span class="line"><span class="comment">//返回规则,成功偷取则返回1;返回2代表可重试(被其他小偷击败),如果队列非空但未找到匹配task,返回-1</span></span><br><span class="line"><span class="comment">//其他情况返回一个强制负的基准索引.</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">pollAndExecCC</span><span class="params">(CountedCompleter&lt;?&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> b, h; ForkJoinTask&lt;?&gt;[] a; Object o;</span><br><span class="line">    <span class="keyword">if</span> ((b = base) - top &gt;= <span class="number">0</span> || (a = array) == <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">//空队列,与最小整数(负值)取或作为信号h</span></span><br><span class="line">        h = b | Integer.MIN_VALUE;  <span class="comment">// to sense movement on re-poll</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//从底部取索引j</span></span><br><span class="line">        <span class="keyword">long</span> j = (((a.length - <span class="number">1</span>) &amp; b) &lt;&lt; ASHIFT) + ABASE;</span><br><span class="line">        <span class="comment">//用该索引取task取出null,说明被捷足先登了,信号置为可重试</span></span><br><span class="line">        <span class="keyword">if</span> ((o = U.getObjectVolatile(a, j)) == <span class="keyword">null</span>)</span><br><span class="line">            h = <span class="number">2</span>;                  <span class="comment">// retryable</span></span><br><span class="line">        <span class="comment">//取出的非空任务类型不是CountedCompleter.说明不匹配,信号-1</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> CountedCompleter))</span><br><span class="line">            h = -<span class="number">1</span>;                 <span class="comment">// unmatchable</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//是CountedCompleter类型</span></span><br><span class="line">            CountedCompleter&lt;?&gt; t = (CountedCompleter&lt;?&gt;)o;</span><br><span class="line">            <span class="keyword">for</span> (CountedCompleter&lt;?&gt; r = t;;) &#123;</span><br><span class="line">                <span class="comment">//基本同上个方法的逻辑,只是上个方法t取的是top,这里取base.</span></span><br><span class="line">                <span class="comment">//r从t开始找它的父,直到它本身或它的父等于task.将它从底端出队.</span></span><br><span class="line">                <span class="keyword">if</span> (r == task) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (base == b &amp;&amp;</span><br><span class="line">                        U.compareAndSwapObject(a, j, t, <span class="keyword">null</span>)) &#123;</span><br><span class="line">                        <span class="comment">//出队成功,因为我们找的是base,且竞态成功,直接更新base即可</span></span><br><span class="line">                        base = b + <span class="number">1</span>;</span><br><span class="line">                        <span class="comment">//出队后执行该出队的任务.返回1代表成功</span></span><br><span class="line">                        t.doExec();</span><br><span class="line">                        h = <span class="number">1</span>;      <span class="comment">// success</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//base被其他线程修改了,或者cas竞态失败.(其实是一个情况),信号2</span></span><br><span class="line">                    <span class="comment">//可以从新的base开始重试.</span></span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        h = <span class="number">2</span>;      <span class="comment">// lost CAS</span></span><br><span class="line">                    <span class="comment">//只要找到task的子任务就break,返回竞态成功或可重试的信号</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//迭代函数,当前r不是task,将r指向它的父,直到某一个r的父是task或者是null进入else if</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((r = r.completer) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//能够进来,说明r已经指向了root,却没有找到整条链上有这个task,返回信号为未匹配到</span></span><br><span class="line">                    h = -<span class="number">1</span>;         <span class="comment">// unmatched</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="isApparentlyUnblocked"><a href="#isApparentlyUnblocked" class="headerlink" title="isApparentlyUnblocked"></a>isApparentlyUnblocked</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果当前线程拥有此队列且明显未被锁定,返回true</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isApparentlyUnblocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread wt; Thread.State s;</span><br><span class="line">    <span class="comment">//前面提过的scanState会在一上来runTask时和1的反码取与运算,直到运行完任务才会反向运算</span></span><br><span class="line">    <span class="comment">//这个过程,scanState的最后一位会置0,但这与此判断条件关系不大</span></span><br><span class="line">    <span class="comment">//前面对scanState有所注释,小于0代表不活跃</span></span><br><span class="line">    <span class="keyword">return</span> (scanState &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">            <span class="comment">//队列处于活跃态且当前线程的状态不是阻塞,不是等待,不是定时等待,则返回true</span></span><br><span class="line">            (wt = owner) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">            (s = wt.getState()) != Thread.State.BLOCKED &amp;&amp;</span><br><span class="line">            s != Thread.State.WAITING &amp;&amp;</span><br><span class="line">            s != Thread.State.TIMED_WAITING);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;1.规避了伪共享</p><p>&emsp;&emsp;2.使用<code>scanState</code>表示运行的状态，版本号。小于0表示：不活跃维护了忙碌标记。忙碌(偶数)，取消忙碌(奇数)。</p><p>&emsp;&emsp;3.维护了可变的数组，以及base-top,任务压入队列以后进行数组的容量检测，进行数组的容量扩容，并且保证扩容后元素的索引保持不变。</p><p>&emsp;&emsp;4.维护了任务窃取的记录和个数，在溢出等情况及时的累加给线程池。</p><p>&emsp;&emsp;5.维护了队列锁，在<code>popCC</code>且当前为共享队列的情形下使用。保证争抢的同步。</p><h2 id="ForkJoinPool详解"><a href="#ForkJoinPool详解" class="headerlink" title="ForkJoinPool详解"></a>ForkJoinPool详解</h2><p><img src="/image/hexo/image-20200719215142068.png" alt="image-20200719215142068"></p><h3 id="类声明-3"><a href="#类声明-3" class="headerlink" title="类声明"></a>类声明</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@sun</span>.misc.Contended</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinPool</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span></span></span><br></pre></td></tr></table></figure><h3 id="构造函数-2"><a href="#构造函数-2" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造函数</span></span><br><span class="line">ForkJoinPool f1 = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">ForkJoinPool f2 = ForkJoinPool.commonPool();</span><br><span class="line"><span class="comment">//parallelism并行级别、默认为CPU核心数</span></span><br><span class="line">ForkJoinPool f3 = <span class="keyword">new</span> ForkJoinPool(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> parallelism      并行级别, 默认为CPU核心数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> factory          工作线程工厂</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> handler          异常处理器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mode        调度模式: true表示FIFO_QUEUE; false表示LIFO_QUEUE</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> workerNamePrefix 工作线程的名称前缀</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">ForkJoinPool</span><span class="params">(<span class="keyword">int</span> parallelism, ForkJoinWorkerThreadFactory factory, UncaughtExceptionHandler handler,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">int</span> mode, String workerNamePrefix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.workerNamePrefix = workerNamePrefix;</span><br><span class="line">    <span class="keyword">this</span>.factory = factory;</span><br><span class="line">    <span class="keyword">this</span>.ueh = handler;</span><br><span class="line">    <span class="keyword">this</span>.config = (parallelism &amp; SMASK) | mode;</span><br><span class="line">    <span class="keyword">long</span> np = (<span class="keyword">long</span>) (-parallelism); <span class="comment">// offset ctl counts</span></span><br><span class="line">    <span class="keyword">this</span>.ctl = ((np &lt;&lt; AC_SHIFT) &amp; AC_MASK) | ((np &lt;&lt; TC_SHIFT) &amp; TC_MASK);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>parallelism</strong>：默认值为CPU核心数，ForkJoinPool里工作线程数量与该参数有关，但它不表示最大线程数；</li><li><strong>factory</strong>：工作线程工厂，默认是DefaultForkJoinWorkerThreadFactory，其实就是用来创建工作线程对象——ForkJoinWorkerThread；</li><li><strong>handler</strong>：异常处理器；</li><li><strong>config</strong>：保存parallelism和mode信息，供后续读取；</li><li><strong>ctl</strong>：线程池的核心控制字段</li></ul><p>这些入参目前不用关注，我们重点是<code>mode</code>这个字段，ForkJoinPool支持两种模式：</p><ol><li>同步模式（默认方式）：对于工作线程（Worker）自身队列中的任务，采用<strong>后进先出（LIFO）</strong>的方式执行</li><li>异步模式：对于工作线程（Worker）自身队列中的任务，采用<strong>先进先出（FIFO）</strong>的方式执行</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mode  &#x3D; asyncMode ? FIFO_QUEUE : LIFO_QUEUE</span><br></pre></td></tr></table></figure><h3 id="Executors构建"><a href="#Executors构建" class="headerlink" title="Executors构建"></a>Executors构建</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Executors方法,显然ForkJoinPool被称作工作窃取线程池.参数指定了并行度.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newWorkStealingPool</span><span class="params">(<span class="keyword">int</span> parallelism)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ForkJoinPool</span><br><span class="line">        (parallelism,</span><br><span class="line">        <span class="comment">//默认线程工厂,前文中已提过默认的ForkJoinWorkerThread</span></span><br><span class="line">         ForkJoinPool.defaultForkJoinWorkerThreadFactory,</span><br><span class="line">         <span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//不提供并行度.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newWorkStealingPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ForkJoinPool</span><br><span class="line">        <span class="comment">//使用所有可用的处理器</span></span><br><span class="line">        (Runtime.getRuntime().availableProcessors(),</span><br><span class="line">         ForkJoinPool.defaultForkJoinWorkerThreadFactory,</span><br><span class="line">         <span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对应的,ForkJoinPool的构造器们.</span></span><br><span class="line"><span class="comment">//不指定任何参数.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ForkJoinPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//并行度取MAX_CAP和可用处理器数的最小值.</span></span><br><span class="line">    <span class="keyword">this</span>(Math.min(MAX_CAP, Runtime.getRuntime().availableProcessors()),</span><br><span class="line">        <span class="comment">//默认的线程工厂.无异常处理器,非异步模式.</span></span><br><span class="line">         defaultForkJoinWorkerThreadFactory, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//同上,只是使用参数中的并行度.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ForkJoinPool</span><span class="params">(<span class="keyword">int</span> parallelism)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(parallelism, defaultForkJoinWorkerThreadFactory, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ForkJoinPool</span><span class="params">(<span class="keyword">int</span> parallelism,</span></span></span><br><span class="line"><span class="function"><span class="params">                    ForkJoinWorkerThreadFactory factory,</span></span></span><br><span class="line"><span class="function"><span class="params">                    UncaughtExceptionHandler handler,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">boolean</span> asyncMode)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//并行度需要校验</span></span><br><span class="line">    <span class="keyword">this</span>(checkParallelism(parallelism),</span><br><span class="line">        <span class="comment">//校验线程工厂</span></span><br><span class="line">         checkFactory(factory),</span><br><span class="line">        <span class="comment">//参数指定的未捕获异常处理器.</span></span><br><span class="line">         handler,</span><br><span class="line">        <span class="comment">//前面的几处代码asyncMode都是false,会选用LIFO队列,是true是会选用FIFO队列,后面详述.</span></span><br><span class="line">         asyncMode ? FIFO_QUEUE : LIFO_QUEUE,</span><br><span class="line">        <span class="comment">//线程名前缀</span></span><br><span class="line">         <span class="string">"ForkJoinPool-"</span> + nextPoolId() + <span class="string">"-worker-"</span>);</span><br><span class="line">    <span class="comment">//检查许可,不关心.</span></span><br><span class="line">    checkPermission();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//检查方法很简单.</span></span><br><span class="line"><span class="comment">//并行度不能大于MAX_CAP不能不大于0.</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">checkParallelism</span><span class="params">(<span class="keyword">int</span> parallelism)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parallelism &lt;= <span class="number">0</span> || parallelism &gt; MAX_CAP)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">return</span> parallelism;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//线程工厂非空即可.</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ForkJoinWorkerThreadFactory checkFactory</span><br><span class="line">    (ForkJoinWorkerThreadFactory factory) &#123;</span><br><span class="line">    <span class="keyword">if</span> (factory == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">return</span> factory;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最终构造器,私有.待介绍完一些基础字段后再述.</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">ForkJoinPool</span><span class="params">(<span class="keyword">int</span> parallelism,</span></span></span><br><span class="line"><span class="function"><span class="params">                     ForkJoinWorkerThreadFactory factory,</span></span></span><br><span class="line"><span class="function"><span class="params">                     UncaughtExceptionHandler handler,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">int</span> mode,</span></span></span><br><span class="line"><span class="function"><span class="params">                     String workerNamePrefix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.workerNamePrefix = workerNamePrefix;</span><br><span class="line">    <span class="keyword">this</span>.factory = factory;</span><br><span class="line">    <span class="keyword">this</span>.ueh = handler;</span><br><span class="line">    <span class="comment">//config初始化值,用并行度与mode取或,显然mode是FIFO时,将有一个第17位的1.</span></span><br><span class="line">    <span class="keyword">this</span>.config = (parallelism &amp; SMASK) | mode;</span><br><span class="line">    <span class="comment">//np保存并行度(正数)的相反数(补码).</span></span><br></pre></td></tr></table></figure><h3 id="线程工厂"><a href="#线程工厂" class="headerlink" title="线程工厂"></a>线程工厂</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ForkJoinWorkerThread的线程工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">interface</span> <span class="title">ForkJoinWorkerThreadFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建新线程要实现的方法.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ForkJoinWorkerThread <span class="title">newThread</span><span class="params">(ForkJoinPool pool)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//前面看到的默认线程工厂</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultForkJoinWorkerThreadFactory</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">ForkJoinWorkerThreadFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ForkJoinWorkerThread <span class="title">newThread</span><span class="params">(ForkJoinPool pool)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ForkJoinWorkerThread(pool);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建InnocuousForkJoinWorkerThread的线程工厂,上一文已经介绍过</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">InnocuousForkJoinWorkerThreadFactory</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">ForkJoinWorkerThreadFactory</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AccessControlContext innocuousAcc;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        Permissions innocuousPerms = <span class="keyword">new</span> Permissions();</span><br><span class="line">        innocuousPerms.add(modifyThreadPermission);</span><br><span class="line">        innocuousPerms.add(<span class="keyword">new</span> RuntimePermission(</span><br><span class="line">                               <span class="string">"enableContextClassLoaderOverride"</span>));</span><br><span class="line">        innocuousPerms.add(<span class="keyword">new</span> RuntimePermission(</span><br><span class="line">                               <span class="string">"modifyThreadGroup"</span>));</span><br><span class="line">        innocuousAcc = <span class="keyword">new</span> AccessControlContext(<span class="keyword">new</span> ProtectionDomain[] &#123;</span><br><span class="line">                <span class="keyword">new</span> ProtectionDomain(<span class="keyword">null</span>, innocuousPerms)</span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ForkJoinWorkerThread <span class="title">newThread</span><span class="params">(ForkJoinPool pool)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (ForkJoinWorkerThread.InnocuousForkJoinWorkerThread)</span><br><span class="line">            java.security.AccessController.doPrivileged(</span><br><span class="line">                <span class="keyword">new</span> java.security.PrivilegedAction&lt;ForkJoinWorkerThread&gt;() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> ForkJoinWorkerThread <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> ForkJoinWorkerThread.</span><br><span class="line">                        InnocuousForkJoinWorkerThread(pool);</span><br><span class="line">                &#125;&#125;, innocuousAcc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//空任务</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EmptyTask</span> <span class="keyword">extends</span> <span class="title">ForkJoinTask</span>&lt;<span class="title">Void</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">7721805057305804111L</span>;</span><br><span class="line">    EmptyTask() &#123; status = ForkJoinTask.NORMAL; &#125; <span class="comment">//状态直接是已正常完成.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Void <span class="title">getRawResult</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">null</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setRawResult</span><span class="params">(Void x)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">exec</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">true</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 与边界有关的常量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SMASK        = <span class="number">0xffff</span>;        <span class="comment">// 后16位.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_CAP      = <span class="number">0x7fff</span>;        <span class="comment">// 前面在定并行度时参考的最大容量.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EVENMASK     = <span class="number">0xfffe</span>;        <span class="comment">// 后16位验偶数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SQMASK       = <span class="number">0x007e</span>;        <span class="comment">// 最大64个偶数槽,从第2位至7位共6位,2的6次方.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 与WorkQueue有关</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SCANNING     = <span class="number">1</span>;             <span class="comment">// 对WorkQueue正在运行任务的标记</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INACTIVE     = <span class="number">1</span> &lt;&lt; <span class="number">31</span>;       <span class="comment">// 标记负数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SS_SEQ       = <span class="number">1</span> &lt;&lt; <span class="number">16</span>;       <span class="comment">// 版本号使用,第17位1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ForkJoinPool和WorkQueue的config有关常量.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MODE_MASK    = <span class="number">0xffff</span> &lt;&lt; <span class="number">16</span>;  <span class="comment">// 能滤取前16位.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LIFO_QUEUE   = <span class="number">0</span>;<span class="comment">//前面提到过的,非async模式(false),值取0.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FIFO_QUEUE   = <span class="number">1</span> &lt;&lt; <span class="number">16</span>;<span class="comment">//async模式(true),值取1.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_QUEUE = <span class="number">1</span> &lt;&lt; <span class="number">31</span>;       <span class="comment">// 共享队列标识,符号位表示负.</span></span><br></pre></td></tr></table></figure><h3 id="提交任务"><a href="#提交任务" class="headerlink" title="提交任务"></a>提交任务</h3><h4 id="invoke-1"><a href="#invoke-1" class="headerlink" title="invoke"></a>invoke</h4><p>&emsp;&emsp;同步方法：调用线程等待任务执行完毕才会返回。</p><h4 id="execute"><a href="#execute" class="headerlink" title="execute"></a>execute</h4><p>&emsp;&emsp;异步方法：调用线程立即返回且没有返回值。</p><h4 id="submit"><a href="#submit" class="headerlink" title="submit"></a>submit</h4><p>&emsp;&emsp;异步方法：调用线程立即返回且有返回值（<code>Future</code>）。</p><h3 id="方法-2"><a href="#方法-2" class="headerlink" title="方法"></a>方法</h3><h4 id="lockRunState"><a href="#lockRunState" class="headerlink" title="lockRunState"></a>lockRunState</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//尝试对runState进行加锁操作</span></span><br><span class="line"><span class="comment">//runState：原值或者新值(竞态且成功)</span></span><br><span class="line"><span class="comment">//简单来说：锁住runState</span></span><br><span class="line"><span class="comment">//标志位设置为1：尝试lock的线程可以更改runState的信号位等</span></span><br><span class="line"><span class="comment">//lockRunState成功的线程则是去更改ctl控制信号、工作队列等</span></span><br><span class="line"><span class="comment">//runState也可以称为：运行状态锁</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">lockRunState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rs;</span><br><span class="line">    <span class="comment">//runState为奇数、表示已经上锁进入awaitRunStateLock</span></span><br><span class="line">    <span class="keyword">return</span> ((((rs = runState) &amp; RSLOCK) != <span class="number">0</span> ||</span><br><span class="line">             <span class="comment">//否则尝试进行CAS：rs+1更改为奇数</span></span><br><span class="line">             !U.compareAndSwapInt(<span class="keyword">this</span>, RUNSTATE, rs, rs |= RSLOCK)) ?</span><br><span class="line">            <span class="comment">//runState已经锁住或者CAS更新rs失败进入awaitRunStateLock等待加锁成功</span></span><br><span class="line">            <span class="comment">//否则返回rs</span></span><br><span class="line">            awaitRunStateLock() : rs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="awaitRunStateLock"><a href="#awaitRunStateLock" class="headerlink" title="awaitRunStateLock"></a>awaitRunStateLock</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//主要自旋或者进行阻塞等待runState锁可用</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">awaitRunStateLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Object lock;</span><br><span class="line">    <span class="keyword">boolean</span> wasInterrupted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> spins = SPINS, r = <span class="number">0</span>, rs, ns;;) &#123;</span><br><span class="line">        <span class="comment">//进入循环再次重新读取rs</span></span><br><span class="line">        <span class="keyword">if</span> (((rs = runState) &amp; RSLOCK) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//rs依旧还是偶数、CAS尝试设置其为奇数、主要为了锁定runState</span></span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, RUNSTATE, rs, ns = rs | RSLOCK)) &#123;</span><br><span class="line">                <span class="comment">//锁成功以后发现了扰动</span></span><br><span class="line">                <span class="comment">//打断当前线程</span></span><br><span class="line">                <span class="keyword">if</span> (wasInterrupted) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.currentThread().interrupt();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//返回一个新的runState、奇数</span></span><br><span class="line">                <span class="comment">//表示已经锁住唯一的出口、也说明了一定要拿到锁</span></span><br><span class="line">                <span class="keyword">return</span> ns;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//被锁住或者出现了CAS竞争失败</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (r == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//循环中仅此执行一次</span></span><br><span class="line">            <span class="comment">//nextSecondarySeed主要是生成一个伪随机码不会返回0</span></span><br><span class="line">            <span class="comment">//其中r的初始值为0</span></span><br><span class="line">            r = ThreadLocalRandom.nextSecondarySeed();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (spins &gt; <span class="number">0</span>) &#123;</span><br><span class="line">             <span class="comment">//将r的值进行一些转换并开启下轮循环.默认spins是0,不会有自旋次数</span></span><br><span class="line">            <span class="comment">//从源码来看,自旋的唯一作用就是改变r的值,使之可能重新进入</span></span><br><span class="line">            <span class="comment">//也会根据r的结果决定是否减少一次自旋.</span></span><br><span class="line">            <span class="comment">//r的算法,将当前r的后6位保留,用r的后26位与前26位异或被保存为r的前26位(a)</span></span><br><span class="line">            <span class="comment">//再将(a)的结果处理,r的前21位保持不变,后11位与前11位异或并保存为r的后11位(b)</span></span><br><span class="line">            <span class="comment">//再将(b)的结果处理,r的后7位保持不变,用前25位与后25位异或并保存为r的前25位(c)</span></span><br><span class="line">            <span class="comment">//个中数学原理,有兴趣的研究一下吧</span></span><br><span class="line">            <span class="comment">//显然,自旋次数并不是循环次数,它只能决定进入6中锁代码块前要运行至少几轮循环</span></span><br><span class="line">            r ^= r &lt;&lt; <span class="number">6</span>; r ^= r &gt;&gt;&gt; <span class="number">21</span>; r ^= r &lt;&lt; <span class="number">7</span>; <span class="comment">// xorshift</span></span><br><span class="line">            <span class="keyword">if</span> (r &gt;= <span class="number">0</span>)</span><br><span class="line">                <span class="comment">//r依旧大于等于0则自旋次数-1</span></span><br><span class="line">                --spins;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//r不为0，</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((rs &amp; STARTED) == <span class="number">0</span> || (lock = stealCounter) == <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">//线程的runState还没有开启或者说还没有初始化锁stealCounter</span></span><br><span class="line">            <span class="comment">//处于了初始化的竞态让出当前线程的执行去</span></span><br><span class="line">            <span class="comment">//再次获取到执行权、重新进入循环</span></span><br><span class="line">            Thread.yield();   <span class="comment">// initialization race</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, RUNSTATE, rs, rs | RSIGNAL)) &#123;</span><br><span class="line">        <span class="comment">//没能对runState加锁,也不是5中的初始化时竞态的情况,尝试加上信号位</span></span><br><span class="line">            <span class="comment">//以stealCounter进行加锁.</span></span><br><span class="line">            <span class="comment">//显然,这种加信号位的加法不会因为信号位而失败而会因为runState的其他字段比如锁标识位失败              //重新开始循环即可</span></span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                <span class="comment">//double check</span></span><br><span class="line">                <span class="keyword">if</span> ((runState &amp; RSIGNAL) != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//runState拥有信号位的值</span></span><br><span class="line">                    <span class="comment">//说明没有线程去释放信号位</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                      <span class="comment">//runState期间没有被除去信号位陷入等待</span></span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                        <span class="comment">//等待中出现了异常情况、会中断线程</span></span><br><span class="line">                        <span class="keyword">if</span> (!(Thread.currentThread() <span class="keyword">instanceof</span></span><br><span class="line">                              ForkJoinWorkerThread))</span><br><span class="line">                            wasInterrupted = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="comment">//当前的runState没有信号位的值</span></span><br><span class="line">                    <span class="comment">//说明已经被释放了、唤醒等待的同步块里面的线程</span></span><br><span class="line">                    <span class="comment">//</span></span><br><span class="line">                    lock.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;1.主要针对<code>runState</code>操作，对该字段进行标识。严格意义上来讲，这是为了<code>ctl\工作队列</code>等运行时数据服务的。对运行时数据的修改权限加锁。</p><p>&emsp;&emsp;2.加锁的过程：自旋+阻塞的方式，如果线程池还处于初始话状态则让出执行权。</p><p>&emsp;&emsp;3.同时也设定了自旋的次数,使用随机数判断是否需要减少自旋次数，其降低为0之前不会阻塞。</p><p>&emsp;&emsp;4.加锁的流程主要是进行了一轮又一轮的循环，尝试去设置锁标志位，修改成功返回新的标识，否则去修改信号位（原子性操作）。唯一可能失败的主要是<code>runState</code>的其他位发生了改变，并且很可能是因为锁标识位被释放的缘故。</p><p>&emsp;&emsp;5.如果没有其他的线程竞争去修改<code>runState</code>,那么直接CAS可以成功，并且不需要唤醒其他的线程。否则CAS尝试失败，那么直接暴力重置了<code>newState</code>并且唤醒阻塞的线程。</p><h4 id="createWorker"><a href="#createWorker" class="headerlink" title="createWorker"></a>createWorker</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//尝试工作线程的构建和开启</span></span><br><span class="line"><span class="comment">//它假定已经有别处维护了预留的增加总数</span></span><br><span class="line"><span class="comment">//创建和启动过程中出现任何异常,就执行工作线程的卸载</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">createWorker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//前面构造器传入的factory.</span></span><br><span class="line">    ForkJoinWorkerThreadFactory fac = factory;</span><br><span class="line">    Throwable ex = <span class="keyword">null</span>;</span><br><span class="line">    ForkJoinWorkerThread wt = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//创建线程成功</span></span><br><span class="line">        <span class="keyword">if</span> (fac != <span class="keyword">null</span> &amp;&amp; (wt = fac.newThread(<span class="keyword">this</span>)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//启动该线程.</span></span><br><span class="line">            wt.start();</span><br><span class="line">            <span class="comment">//启动也成功,返回true</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable rex) &#123;</span><br><span class="line">        <span class="comment">//出现异常,保存</span></span><br><span class="line">        ex = rex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//用前面的异常卸载</span></span><br><span class="line">    deregisterWorker(wt, ex);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="tryAddWorker"><a href="#tryAddWorker" class="headerlink" title="tryAddWorker"></a>tryAddWorker</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//尝试添加一个worker</span></span><br><span class="line"><span class="comment">//并在完成前增加ctl里面记录的数量(AC参数</span></span><br><span class="line"><span class="comment">//增加过程是否进行决定于createWorker返回的true还是false</span></span><br><span class="line"><span class="comment">//参数c是一个进入控制信号ctl</span></span><br><span class="line"><span class="comment">//它的总计数为负且没有空闲worker,cas(增加ctl)失败时,若ctl未改变,则可以刷新重试</span></span><br><span class="line"><span class="comment">//否则说明被添加了一个worker,那么它也就不需要再继续了</span></span><br><span class="line"><span class="comment">//从方法的实现上看,c似乎可以传任何值</span></span><br><span class="line"><span class="comment">//如果c传入的值不等于当前ctl,则会多一次循环重读ctl到c</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">tryAddWorker</span><span class="params">(<span class="keyword">long</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//标记add成功与否</span></span><br><span class="line">    <span class="keyword">boolean</span> add = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">//根据参数c生成一个新的ctrl/nc</span></span><br><span class="line">        <span class="comment">//c源自参数或者某一次循环读取的ctl.</span></span><br><span class="line">        <span class="comment">//nc的值计算结果:c加上一个活跃单位1&lt;&lt;48,并对结果保留前16位</span></span><br><span class="line">        <span class="comment">//c加上一个总数单位1&lt;&lt;32,并对结果保留第二个16位(33到48位)</span></span><br><span class="line">        <span class="comment">//nc等于上两步的结果和.显然,nc的后32位全部是0</span></span><br><span class="line">        <span class="keyword">long</span> nc = ((AC_MASK &amp; (c + AC_UNIT)) |</span><br><span class="line">                   (TC_MASK &amp; (c + TC_UNIT)));</span><br><span class="line">        <span class="comment">//ctl未改变</span></span><br><span class="line">        <span class="keyword">if</span> (ctl == c) &#123;</span><br><span class="line">            <span class="comment">//阻塞加锁并判断是否已在终止</span></span><br><span class="line">            <span class="keyword">int</span> rs, stop;                 <span class="comment">// check if terminating</span></span><br><span class="line">            <span class="keyword">if</span> ((stop = (rs = lockRunState()) &amp; STOP) == <span class="number">0</span>)</span><br><span class="line">                <span class="comment">//加锁成功且未终止,尝试cas掉ctl.</span></span><br><span class="line">                add = U.compareAndSwapLong(<span class="keyword">this</span>, CTL, c, nc);</span><br><span class="line">            <span class="comment">//加锁成功,不论cas ctl是否成功,解锁</span></span><br><span class="line">            unlockRunState(rs, rs &amp; ~RSLOCK);</span><br><span class="line">            <span class="comment">//如果已stop,break退出添加worker的步骤</span></span><br><span class="line">            <span class="keyword">if</span> (stop != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (add) &#123;</span><br><span class="line">                <span class="comment">//加锁成功,cas也成功,线程池未进入终止流程,创建worker</span></span><br><span class="line">                createWorker();</span><br><span class="line">                <span class="comment">//创建成功立即break</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这时为前32位发生了变化,只能在新一轮循环处理.注:ADD_WORKER位是第48位,前面已提到</span></span><br><span class="line">        <span class="comment">//它是TC_MASK能负责的最高位</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (((c = ctl) &amp; ADD_WORKER) != <span class="number">0L</span> &amp;&amp; (<span class="keyword">int</span>)c == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="registerWorker"><a href="#registerWorker" class="headerlink" title="registerWorker"></a>registerWorker</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将线程注册入池,同时返回一个WorkQueue,工作线程会在内部记录这个队列.</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> WorkQueue <span class="title">registerWorker</span><span class="params">(ForkJoinWorkerThread wt)</span> </span>&#123;</span><br><span class="line">    UncaughtExceptionHandler handler;</span><br><span class="line">    <span class="comment">//设置成守护线程,这样保证用户线程都已释放的情况下关闭虚拟机</span></span><br><span class="line">    wt.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">if</span> ((handler = ueh) != <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">//构造器提供了异常处理器</span></span><br><span class="line">        wt.setUncaughtExceptionHandler(handler);</span><br><span class="line">    <span class="comment">//构建工作队列</span></span><br><span class="line">    WorkQueue w = <span class="keyword">new</span> WorkQueue(<span class="keyword">this</span>, wt);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>; </span><br><span class="line">    <span class="comment">//取出池config的17-32位保存为mode,</span></span><br><span class="line">    <span class="comment">//前面提过,config在构造时由并行度(后15位)和模式(第17位)表示,根据17位是否有值决定FIFO或LIFO</span></span><br><span class="line">    <span class="comment">//这个与运算进行后,相当于滤掉了并行度信息.                                 </span></span><br><span class="line">    <span class="keyword">int</span> mode = config &amp; MODE_MASK;</span><br><span class="line">    <span class="comment">//创建完队列之后要加锁,尤其后面涉及到可能的数组扩容拷贝,以及一些判断和重设随机数等</span></span><br><span class="line">    <span class="keyword">int</span> rs = lockRunState();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        WorkQueue[] ws; <span class="keyword">int</span> n;      </span><br><span class="line">        <span class="comment">//前面构造器我们看过,没有初始化workQueues,所以如果一个线程此时来注册是被忽略的</span></span><br><span class="line">        <span class="comment">//显然,使用它们的方法一定做了相应的保证.我们后续再看.              </span></span><br><span class="line">        <span class="keyword">if</span> ((ws = workQueues) != <span class="keyword">null</span> &amp;&amp; (n = ws.length) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//队列非空,递增种子.</span></span><br><span class="line">            <span class="comment">//indexSeed值是0,SEED_INCREMENT是每次相加的增量,它的值默认是0x9e3779b9(2654435769)</span></span><br><span class="line">            <span class="comment">//这是一个特殊的值,它的使用不仅此一处,后面稍微介绍.这样减少碰撞可能性</span></span><br><span class="line">            <span class="keyword">int</span> s = indexSeed += SEED_INCREMENT;  </span><br><span class="line">            <span class="keyword">int</span> m = n - <span class="number">1</span>;<span class="comment">//ws数组长度-1,数组长度一定是偶数(后面介绍)</span></span><br><span class="line">            i = ((s &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>) &amp; m;<span class="comment">//奇数位i.</span></span><br><span class="line">            <span class="keyword">if</span> (ws[i] != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//满足这个条件就是发生碰撞了,i已被占用.初始化probes为0</span></span><br><span class="line">                <span class="keyword">int</span> probes = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">//定义步长,数组长度不大于4,步长2,否则取n一半的第2至16位的结果(偶数)再加上2作为步长</span></span><br><span class="line">                <span class="keyword">int</span> step = (n &lt;= <span class="number">4</span>) ? <span class="number">2</span> : ((n &gt;&gt;&gt; <span class="number">1</span>) &amp; EVENMASK) + <span class="number">2</span>;</span><br><span class="line">                <span class="comment">//开启循环,每次对i加上步长并与m求与运算,直到无碰撞为止</span></span><br><span class="line">                <span class="keyword">while</span> (ws[i = (i + step) &amp; m] != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//每次循环增加probes,表示对同一个数组最多只循环n次,达到次数要进行扩容重试</span></span><br><span class="line">                    <span class="keyword">if</span> (++probes &gt;= n) &#123;</span><br><span class="line">                        <span class="comment">//当前数组已经尝试n次,还没有找到无碰撞点,扩容数组一倍,原位置拷贝</span></span><br><span class="line">                        <span class="comment">//此处没有任何加锁动作,与循环之外创建好队列之后的代码共享一个锁,也是lockRunState</span></span><br><span class="line">                        <span class="comment">//可见只有指派索引相关的动作才需要加锁.</span></span><br><span class="line">                        workQueues = ws = Arrays.copyOf(ws, n &lt;&lt;= <span class="number">1</span>);</span><br><span class="line">                        <span class="comment">//重置条件.</span></span><br><span class="line">                        m = n - <span class="number">1</span>;</span><br><span class="line">                        probes = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//s值保存给队列的hint作为随机数种子</span></span><br><span class="line">            <span class="comment">//可见,此处至少可说明每个注册线程时创建的队列都会有不同的hint,它也算是一个标识</span></span><br><span class="line">            w.hint = s;    </span><br><span class="line">            <span class="comment">//队列的配置,i与mode取或,mode只能是0或1&lt;&lt;16 </span></span><br><span class="line">            <span class="comment">//这个结果是将mode可能存放在队列config的17位,从而和池中的config在模式这一块保持一致.</span></span><br><span class="line">            <span class="comment">//i一定是一个不大于m(n-1)的奇数,而n一定不超过后16位(后面叙述),它和mode互不影响.  </span></span><br><span class="line">            <span class="comment">//故队列的config相当于同时保存了在池的workQueues数组的索引和所属池的FIFO或LIFO.                    </span></span><br><span class="line">            w.config = i | mode;</span><br><span class="line">            <span class="comment">//初始化scanState,以奇数i(索引)当值.相当于发布了初始屏障.</span></span><br><span class="line">            <span class="comment">//(不理解?参考runState方法,一上来就将它的末位置0成偶数)</span></span><br><span class="line">            w.scanState = i; </span><br><span class="line">            <span class="comment">//新建的队列置于i处.</span></span><br><span class="line">            ws[i] = w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//解锁.</span></span><br><span class="line">        unlockRunState(rs, rs &amp; ~RSLOCK);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//线程名,这里看到一个有趣的事,无符号右移,i一定是个奇数,假定右移后的值是j,则2*j=i</span></span><br><span class="line">    wt.setName(workerNamePrefix.concat(Integer.toString(i &gt;&gt;&gt; <span class="number">1</span>)));</span><br><span class="line">    <span class="comment">//返回队列给线程</span></span><br><span class="line">    <span class="keyword">return</span> w;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="nextSecondarySeed"><a href="#nextSecondarySeed" class="headerlink" title="nextSecondarySeed"></a>nextSecondarySeed</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">nextSecondarySeed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="keyword">if</span> ((r = UNSAFE.getInt(t, SECONDARY)) != <span class="number">0</span>) &#123;</span><br><span class="line">        r ^= r &lt;&lt; <span class="number">13</span>;   <span class="comment">// xorshift</span></span><br><span class="line">        r ^= r &gt;&gt;&gt; <span class="number">17</span>;</span><br><span class="line">        r ^= r &lt;&lt; <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//原来secondary是0,localInit一个值.</span></span><br><span class="line">        localInit();</span><br><span class="line">        <span class="keyword">if</span> ((r = (<span class="keyword">int</span>)UNSAFE.getLong(t, SEED)) == <span class="number">0</span>)</span><br><span class="line">            r = <span class="number">1</span>; <span class="comment">// avoid zero</span></span><br><span class="line">    &#125;</span><br><span class="line">    UNSAFE.putInt(t, SECONDARY, r);</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="localInit"><a href="#localInit" class="headerlink" title="localInit"></a>localInit</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//localInit</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">localInit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//生成器是一个AtomicLong,从0开始,每次加入PROBE_INCREMENT.</span></span><br><span class="line">    <span class="keyword">int</span> p = probeGenerator.addAndGet(PROBE_INCREMENT);</span><br><span class="line">    <span class="keyword">int</span> probe = (p == <span class="number">0</span>) ? <span class="number">1</span> : p; <span class="comment">// skip 0</span></span><br><span class="line">    <span class="keyword">long</span> seed = mix64(seeder.getAndAdd(SEEDER_INCREMENT));</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    UNSAFE.putLong(t, SEED, seed);</span><br><span class="line">    UNSAFE.putInt(t, PROBE, probe);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//初值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROBE_INCREMENT = <span class="number">0x9e3779b9</span></span><br></pre></td></tr></table></figure><h4 id="deregisterWorker"><a href="#deregisterWorker" class="headerlink" title="deregisterWorker"></a>deregisterWorker</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//解除注册操作.它是一个要终止的工作线程的最终回调,或者创建失败时也会回调.在介绍ForkJoinWorkerThread和前面createWorker时提过.</span></span><br><span class="line"><span class="comment">//这会从数组中移除worker记录,调整数量.如果池已经处在关闭进行中,尝试帮助完成池的关闭.</span></span><br><span class="line"><span class="comment">//参数wt是工作线程,构建失败会是null,ex是造成失败的异常.它也可以是null.</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">deregisterWorker</span><span class="params">(ForkJoinWorkerThread wt, Throwable ex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//处理队列从池的队列数组中的移除.</span></span><br><span class="line">    WorkQueue w = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (wt != <span class="keyword">null</span> &amp;&amp; (w = wt.workQueue) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//存在工作线程且该工作线程有队列的逻辑.</span></span><br><span class="line">        WorkQueue[] ws;            </span><br><span class="line">        <span class="comment">//前面说过,队列的config后16位表示索引,第17位表示mode.         </span></span><br><span class="line">        <span class="keyword">int</span> idx = w.config &amp; SMASK;</span><br><span class="line">        <span class="comment">//加运行时状态锁.</span></span><br><span class="line">        <span class="keyword">int</span> rs = lockRunState();</span><br><span class="line">        <span class="keyword">if</span> ((ws = workQueues) != <span class="keyword">null</span> &amp;&amp; ws.length &gt; idx &amp;&amp; ws[idx] == w)</span><br><span class="line">            <span class="comment">//简单的置空操作.</span></span><br><span class="line">            ws[idx] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//解锁.</span></span><br><span class="line">        unlockRunState(rs, rs &amp; ~RSLOCK);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//处理控制信号中保存的数量.</span></span><br><span class="line">    <span class="keyword">long</span> c; </span><br><span class="line">    <span class="comment">//循环直到减数成功. 哪怕有别的线程在竞态减少,当前方法也要在新的ctl中减少数量                                    </span></span><br><span class="line">    <span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (!U.compareAndSwapLong</span><br><span class="line">                 <span class="comment">//第49位减1.</span></span><br><span class="line">                 (<span class="keyword">this</span>, CTL, c = ctl, ((AC_MASK &amp; (c - AC_UNIT)) |</span><br><span class="line">                                       <span class="comment">//第33位减1.</span></span><br><span class="line">                                       (TC_MASK &amp; (c - TC_UNIT)) |</span><br><span class="line">                                       <span class="comment">//保留后32位.</span></span><br><span class="line">                                       (SP_MASK &amp; c))));</span><br><span class="line">    <span class="comment">//该工作线程有队列,且已经在1出了数组</span></span><br><span class="line">    <span class="keyword">if</span> (w != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//把队列锁设定负数.</span></span><br><span class="line">        w.qlock = -<span class="number">1</span>;                            </span><br><span class="line">        <span class="comment">//把队列中记录的偷取任务数加到池中.前面已论述过此方法</span></span><br><span class="line">        w.transferStealCount(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">//取消队列中所有存活的任务.</span></span><br><span class="line">        w.cancelAll();                         </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//进入循环尝试帮助关闭池或释放阻塞线程,补偿线程等</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;                                   </span><br><span class="line">        WorkQueue[] ws; <span class="keyword">int</span> m, sp;</span><br><span class="line">        <span class="comment">// tryTerminate后面介绍,第一个参数true代表无条件立即结束,第二个参数true</span></span><br><span class="line">        <span class="comment">//代表下次tryTerminate将可以结束.</span></span><br><span class="line">        <span class="keyword">if</span> (tryTerminate(<span class="keyword">false</span>, <span class="keyword">false</span>) || w == <span class="keyword">null</span> || w.array == <span class="keyword">null</span> ||</span><br><span class="line">            (runState &amp; STOP) != <span class="number">0</span> || (ws = workQueues) == <span class="keyword">null</span> ||</span><br><span class="line">            (m = ws.length - <span class="number">1</span>) &lt; <span class="number">0</span>)              </span><br><span class="line">            <span class="comment">//进入if,说明正在结束或已结束,没什么可做的了.</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//控制信号后32位有数值,进尝试释放逻辑.这不是第一次看到ctl的后32了.对于ctl的前32位,</span></span><br><span class="line">        <span class="comment">//我们已经通过构造函数和前面的代码说明,它初始化时与并行度有关,并在后面存放了添加worker数量</span></span><br><span class="line">        <span class="comment">//的值(但不能说存放了并行度,因为添加worker会改变相应的位),后32位的真相也开始浮出水面,</span></span><br><span class="line">        <span class="comment">//在前面的tryAddWorker中,第二轮及以后的循环条件要求后32位不能存在值.而且添加成功也会</span></span><br><span class="line">        <span class="comment">//将后32位置0,故tryAddWorker的第一轮循环会清空后32位,与此有所影响.</span></span><br><span class="line">        <span class="keyword">if</span> ((sp = (<span class="keyword">int</span>)(c = ctl)) != <span class="number">0</span>) &#123; </span><br><span class="line">            <span class="comment">//后32位有值,尝试release,tryRealease方法会将activeCount数量添加第三个参数的值</span></span><br><span class="line">            <span class="comment">//如果第二个参数代表的队列是空闲worker的栈顶,则释放其内的阻塞者</span></span><br><span class="line">            <span class="keyword">if</span> (tryRelease(c, ws[sp &amp; m], AC_UNIT))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//仅有此处释放失败的情况下,开启下一轮循环,其他分支均会退出循环.</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ex != <span class="keyword">null</span> &amp;&amp; (c &amp; ADD_WORKER) != <span class="number">0L</span>) &#123;</span><br><span class="line">            <span class="comment">//此次解除注册是因为异常,且当前添加worker信号依旧满足,则添加一个worker代替原来并退出</span></span><br><span class="line">            tryAddWorker(c);                      </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="comment">// 不需要添加补偿worker,退出循环                             </span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ex == <span class="keyword">null</span>) </span><br><span class="line">        <span class="comment">//前面记录的异常不存在,帮助清理脏异常节点                             </span></span><br><span class="line">        ForkJoinTask.helpExpungeStaleExceptions();</span><br><span class="line">    <span class="keyword">else</span>   </span><br><span class="line">        <span class="comment">//存在异常,重抛.                                     </span></span><br><span class="line">        ForkJoinTask.rethrow(ex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="signalWork"><a href="#signalWork" class="headerlink" title="signalWork"></a>signalWork</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果当前活跃线程数过少,尝试去创建或活化一个worker.</span></span><br><span class="line"><span class="comment">//参数ws是想要找到被唤醒者的队列数组(也就是任何一个ForkJoinPool的成员变量),</span></span><br><span class="line"><span class="comment">//参数q是个非空的队列,则方法只尝试一次,不会重试</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signalWork</span><span class="params">(WorkQueue[] ws, WorkQueue q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> c; <span class="keyword">int</span> sp, i; WorkQueue v; Thread p;</span><br><span class="line">    <span class="keyword">while</span> ((c = ctl) &lt; <span class="number">0L</span>) &#123; </span><br><span class="line">        <span class="comment">//添加worker步骤                      </span></span><br><span class="line">        <span class="comment">//ctl小于0,表示active的太少.但似乎也只能最多加上并行度的数量</span></span><br><span class="line">        <span class="keyword">if</span> ((sp = (<span class="keyword">int</span>)c) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//取ctl的后32位,终于,终于看明白了,这里有一个注释,sp==0代表无闲置worker</span></span><br><span class="line">            <span class="comment">//但不代表后32位全部与闲置worker有关.</span></span><br><span class="line">            <span class="keyword">if</span> ((c &amp; ADD_WORKER) != <span class="number">0L</span>) </span><br><span class="line">                <span class="comment">//ADD_WORKER位有值,说明总worker数量未达到.</span></span><br><span class="line">                <span class="comment">//经过三重关,添加worker.          </span></span><br><span class="line">                tryAddWorker(c);</span><br><span class="line">            <span class="comment">//满足添加worker的第一个条件,无闲置worker,不论有没有成功创建新的worker</span></span><br><span class="line">            <span class="comment">//就都一定会退出循环</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//不存在空闲worker,验证不满足唤醒流程的情况.</span></span><br><span class="line">        <span class="keyword">if</span> (ws == <span class="keyword">null</span>)  </span><br><span class="line">            <span class="comment">//队列数组都还没初始化,显然池不满足条件.                          </span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (ws.length &lt;= (i = sp &amp; SMASK))<span class="comment">// </span></span><br><span class="line">            <span class="comment">//队列数组长度不大于ctl后16位.说明已进入终止态.退出(多像数组的length一定要大于索引)</span></span><br><span class="line">            <span class="comment">//又一次大揭密,ctl后16位似乎与队列数组的长度有关,而且存放的是一个索引. </span></span><br><span class="line">            <span class="comment">//此处隐含条件,ctl后32位不是0,将它的后16位取出来当索引i,要结合1处的条件.      </span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> ((v = ws[i]) == <span class="keyword">null</span>) </span><br><span class="line">            <span class="comment">//队列数组长度正常, 使用索引(ctl的后15位)从ws中取不出队列.</span></span><br><span class="line">            <span class="comment">//说明正在终止,退出.</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//满足了唤醒流程</span></span><br><span class="line">        <span class="comment">//计算数据,第一个为下一个scanState,在前面的addWorker流程,我们看到</span></span><br><span class="line">        <span class="comment">//scanState的第一个值是在队列数组中的索引.显然索引不能乱变.</span></span><br><span class="line">        <span class="comment">//新的scanState值计算,老ctl的整数位在17位加1(SS_SEQ)再取它的后31位.显然每次被唤醒都会走一次这个逻辑.</span></span><br><span class="line">        <span class="keyword">int</span> vs = (sp + SS_SEQ) &amp; ~INACTIVE; </span><br><span class="line">        <span class="keyword">int</span> d = sp - v.scanState; <span class="comment">//屏蔽不必要的cas.   </span></span><br><span class="line">        <span class="comment">//计算nc,它用老的ctl加一个活跃位(48位),然后只取出前32位</span></span><br><span class="line">        <span class="comment">//对后32位取出队列v在上次扫描时存放的值(也是当时ctl的后32位)</span></span><br><span class="line">        <span class="comment">//这里我们又见到一个熟人:stackPred,接下来会有重要的方法使用它.          </span></span><br><span class="line">        <span class="keyword">long</span> nc = (UC_MASK &amp; (c + AC_UNIT)) | (SP_MASK &amp; v.stackPred);</span><br><span class="line">        <span class="comment">//d是0说明ctl的后32位相对于原来v中存放的scanState没有变化,那么也就不需要cas</span></span><br><span class="line">        <span class="comment">//d不是0,需要cas,用nc替换掉c</span></span><br><span class="line">        <span class="keyword">if</span> (d == <span class="number">0</span> &amp;&amp; U.compareAndSwapLong(<span class="keyword">this</span>, CTL, c, nc)) &#123;</span><br><span class="line">            <span class="comment">//把v的scanDate置换成vs,激活了v</span></span><br><span class="line">            v.scanState = vs;                      </span><br><span class="line">            <span class="keyword">if</span> ((p = v.parker) != <span class="keyword">null</span>)</span><br><span class="line">                <span class="comment">//有线程阻塞,唤醒</span></span><br><span class="line">                U.unpark(p);</span><br><span class="line">            <span class="comment">//激活成功,退出循环.</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4.上述过程没有成功,看q是否提供,如果提供了不循环第二次</span></span><br><span class="line">        <span class="keyword">if</span> (q != <span class="keyword">null</span> &amp;&amp; q.base == q.top)        </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="tryRelease"><a href="#tryRelease" class="headerlink" title="tryRelease"></a>tryRelease</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//唤醒并释放worker v(队列),如果它处于空闲worker栈的顶部,此方法是当至少有一个空闲worker</span></span><br><span class="line"><span class="comment">//时的一个快速唤醒方式.</span></span><br><span class="line"><span class="comment">//它的参数,c应当传入此前读取的ctl,v是一个工作队列,如果不传空,应当传一个worker过来,inc代表活跃数的增加数</span></span><br><span class="line"><span class="comment">//如果成功释放,则返回true</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">long</span> c, WorkQueue v, <span class="keyword">long</span> inc)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//类似上面的signalWork方法的计算方式,sp保存ctl的后32位,vs为队列v的下一个scanState.</span></span><br><span class="line">    <span class="comment">//值依旧是sp在17位加1并只取结果的31位.</span></span><br><span class="line">    <span class="keyword">int</span> sp = (<span class="keyword">int</span>)c, vs = (sp + SS_SEQ) &amp; ~INACTIVE; Thread p;</span><br><span class="line">    <span class="comment">//判断是否满足条件,v存在且v的scanState是sp</span></span><br><span class="line">    <span class="comment">//(言外之意sp保存的是一个v的scanState,别急,我们离真相越来越近了,注释说此条件代表v是栈顶)</span></span><br><span class="line">    <span class="keyword">if</span> (v != <span class="keyword">null</span> &amp;&amp; v.scanState == sp) &#123;</span><br><span class="line">        <span class="comment">//满足了前述的条件,v是当前"栈顶",这个栈顶的含义有些奇怪,没有栈,何来栈顶?别急</span></span><br><span class="line">        <span class="comment">//计算新的ctl,算法同上,老ctl加上inc的结果的前32位给nc的前32位</span></span><br><span class="line">        <span class="comment">//v保存的stackPred作为nc的后32位</span></span><br><span class="line">        <span class="comment">//在前面deregisterWorker中,tryRelease方法传入的inc为一个AC_UNIT.相当于增加一个活跃数</span></span><br><span class="line">        <span class="keyword">long</span> nc = (UC_MASK &amp; (c + inc)) | (SP_MASK &amp; v.stackPred);</span><br><span class="line">        <span class="comment">//尝试用前面计算的结果更新为新值.</span></span><br><span class="line">        <span class="keyword">if</span> (U.compareAndSwapLong(<span class="keyword">this</span>, CTL, c, nc)) &#123;</span><br><span class="line">            <span class="comment">//控制信号成功更新为nc,则将v的scanState保存为vs.</span></span><br><span class="line">            v.scanState = vs;</span><br><span class="line">            <span class="keyword">if</span> ((p = v.parker) != <span class="keyword">null</span>)</span><br><span class="line">                <span class="comment">//存在parker,唤醒.</span></span><br><span class="line">                U.unpark(p);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="runWorker"><a href="#runWorker" class="headerlink" title="runWorker"></a>runWorker</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//runWorker方法是线程运行的最顶层方法,它由ForkJoinWorkerThread在注册成功后调用,也是全部生命周期</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(WorkQueue w)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//一上来初始化数组,前面说过,WorkQueue内部的任务数组初始化是null</span></span><br><span class="line">    w.growArray();  </span><br><span class="line">    <span class="comment">//用seed保留构建时的hint随机数,在registerWorker方法中曾介绍过</span></span><br><span class="line">    <span class="comment">//会有一个随机数s是保证每个队列不同的,且其中有一个每次增加一个值的成份,该值是个数学中很奇异的数字</span></span><br><span class="line">    <span class="comment">//而hint的初值即这个s,它同时也被用于确定队列在ws中的索引,间接决定是否扩容      </span></span><br><span class="line">    <span class="keyword">int</span> seed = w.hint; </span><br><span class="line">    <span class="comment">//初始化r,并避免异或时出现0</span></span><br><span class="line">    <span class="keyword">int</span> r = (seed == <span class="number">0</span>) ? <span class="number">1</span> : seed;  </span><br><span class="line">    <span class="comment">//循环</span></span><br><span class="line">    <span class="keyword">for</span> (ForkJoinTask&lt;?&gt; t;;) &#123;</span><br><span class="line">        <span class="comment">//尝试"scan"(终于出现了有没有)队列w,使用随机数r</span></span><br><span class="line">        <span class="keyword">if</span> ((t = scan(w, r)) != <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">//scan到了一个任务t,则运行它.这是进入一个任务处理的主流程</span></span><br><span class="line">            <span class="comment">//前面已介绍过WorkQueue的runTask方法</span></span><br><span class="line">            <span class="comment">//回忆一下,它会在过程中把scanState标记为忙碌</span></span><br><span class="line">            w.runTask(t);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!awaitWork(w, r))</span><br><span class="line">            <span class="comment">//scan不到,尝试等待任务,如果等待过一段时间还未等待,进入8重置r,继续下轮循环scan.若awaitWork返回false代表应break结束worker</span></span><br><span class="line">            <span class="comment">//关于awaitWork的返回我们后面详解</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//或许只能说just math</span></span><br><span class="line">        r ^= r &lt;&lt; <span class="number">13</span>; r ^= r &gt;&gt;&gt; <span class="number">17</span>; r ^= r &lt;&lt; <span class="number">5</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="scan"><a href="#scan" class="headerlink" title="scan"></a>scan</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//尝试扫描队列,并偷取一个"顶级"的任务.扫描开始于一个随机位置(与r有关),如果在扫描过程中发生了</span></span><br><span class="line"><span class="comment">//竞态,则移动到一个随机的位置继续,否则线性地扫描,这个过程持续到在所有相同校验和</span></span><br><span class="line"><span class="comment">//(校验和的计算会采样每个队列的base索引,而base索引会在每次偷的时候移动)的队列上有两次</span></span><br><span class="line"><span class="comment">//连续的空传递,此时worker会尝试对队列进行灭活并重新扫描,如果能找到一个task,则尝试重新</span></span><br><span class="line"><span class="comment">//激活(重新激活可以由别的线程完成),如果找不到task,则返回null用于等待任务.扫描过程应当减少内</span></span><br><span class="line"><span class="comment">//存使用,以及与其他正在扫描的线程的冲突.</span></span><br><span class="line"><span class="comment">//参数w为目标队列,r是前面传递的种子,返回task或null.</span></span><br><span class="line"><span class="keyword">private</span> ForkJoinTask&lt;?&gt; scan(WorkQueue w, <span class="keyword">int</span> r) &#123;</span><br><span class="line">    WorkQueue[] ws; <span class="keyword">int</span> m;</span><br><span class="line">    <span class="comment">//当前工作线程必须是已经完成注册的,即存在工作队列,且r&amp;m能取得它的队列,否则直接返回null.</span></span><br><span class="line">    <span class="keyword">if</span> ((ws = workQueues) != <span class="keyword">null</span> &amp;&amp; (m = ws.length - <span class="number">1</span>) &gt; <span class="number">0</span> &amp;&amp; w != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//1.scan方法是在runWorker的循环中调用的,初次调用时,scanState的值是i(前面说过),是个非负值.</span></span><br><span class="line">        <span class="keyword">int</span> ss = w.scanState;  </span><br><span class="line">        <span class="comment">//scan方法内部开始循环. 用r&amp;m,即w的索引给origin和k,初始化oldSum和checkSum为0.                  </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> origin = r &amp; m, k = origin, oldSum = <span class="number">0</span>, checkSum = <span class="number">0</span>;;) &#123;</span><br><span class="line">            WorkQueue q; ForkJoinTask&lt;?&gt;[] a; ForkJoinTask&lt;?&gt; t;</span><br><span class="line">            <span class="keyword">int</span> b, n; <span class="keyword">long</span> c;</span><br><span class="line">            <span class="comment">//2.选择队列q存在的逻辑.</span></span><br><span class="line">            <span class="keyword">if</span> ((q = ws[k]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//2.1 目标队列q非空(本身base到top间至少存在1个,任务数组非空.</span></span><br><span class="line">                <span class="keyword">if</span> ((n = (b = q.base) - q.top) &lt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">                    (a = q.array) != <span class="keyword">null</span>) &#123; </span><br><span class="line">                    <span class="comment">//计算任务数组的base索引(参考WorkQueue源码).</span></span><br><span class="line">                    <span class="keyword">long</span> i = (((a.length - <span class="number">1</span>) &amp; b) &lt;&lt; ASHIFT) + ABASE;</span><br><span class="line">                    <span class="comment">//2.2数组中取出base对应task存在,base未改变的逻辑.</span></span><br><span class="line">                    <span class="keyword">if</span> ((t = ((ForkJoinTask&lt;?&gt;)</span><br><span class="line">                              U.getObjectVolatile(a, i))) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                        q.base == b) &#123;</span><br><span class="line">                        <span class="comment">//2.3 初始记录的scanState不小于0,代表存活的逻辑.</span></span><br><span class="line">                        <span class="keyword">if</span> (ss &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">//2.4尝试cas掉base处的任务,注意,一定只能从base开始,不会将任务数组中间的元素置空.</span></span><br><span class="line">                            <span class="keyword">if</span> (U.compareAndSwapObject(a, i, t, <span class="keyword">null</span>)) &#123;</span><br><span class="line">                                <span class="comment">//cas成功,更新base.</span></span><br><span class="line">                                q.base = b + <span class="number">1</span>;</span><br><span class="line">                                <span class="keyword">if</span> (n &lt; -<span class="number">1</span>) </span><br><span class="line">                                    <span class="comment">//2.5发现队列q的base到top间不止一个任务元素,则唤醒它可能存在的parker.</span></span><br><span class="line">                                    <span class="comment">//重温一下signalWork的简要逻辑,ctl后32位0且满足加worker条件,tryAddWorker,</span></span><br><span class="line">                                    <span class="comment">//条件不满足(忽略终止等判断逻辑),则计算新的scanState(使用到原ctl的后32位)和ctl(使用原ctl的前32位和q的stackPred),</span></span><br><span class="line">                                    <span class="comment">//在cas为新的ctl成功的前提下,换掉新的scanState.</span></span><br><span class="line">                                    signalWork(ws, q);</span><br><span class="line">                                <span class="comment">//2.6 只要2.4成功,返回弹出的任务.</span></span><br><span class="line">                                <span class="keyword">return</span> t;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//2.7 从scanState看已经是inactive的情况.尝试活化.</span></span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (oldSum == <span class="number">0</span> &amp;&amp;   </span><br><span class="line">                                 w.scanState &lt; <span class="number">0</span>)</span><br><span class="line">                            <span class="comment">//tryRelease前面已介绍过.尝试释放掉栈顶,显然ws[m&amp;(int)c]被视为栈顶,即ctl的后32位(严格来说似乎是后16位)代表栈顶的索引.</span></span><br><span class="line">                            <span class="comment">//释放时对ctl的增量是一个AC_UNIT.</span></span><br><span class="line">                            tryRelease(c = ctl, ws[m &amp; (<span class="keyword">int</span>)c], AC_UNIT);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//2.8 只要没有进入2.4-&gt;2.6,重置origin,k,r,校验和等参数并开启下轮,但整个2工作线用不到,进入3工作线才有用.</span></span><br><span class="line">                    <span class="keyword">if</span> (ss &lt; <span class="number">0</span>)                   <span class="comment">// refresh</span></span><br><span class="line">                        <span class="comment">//可能会有其他抢到同一个队列的worker在2.5/2.7处重活化了scanState,因此当它是inactive的情况,重刷新一次.</span></span><br><span class="line">                        ss = w.scanState;</span><br><span class="line">                    r ^= r &lt;&lt; <span class="number">1</span>; r ^= r &gt;&gt;&gt; <span class="number">3</span>; r ^= r &lt;&lt; <span class="number">10</span>;</span><br><span class="line">                    origin = k = r &amp; m;           <span class="comment">// move and rescan</span></span><br><span class="line">                    oldSum = checkSum = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//2.9校验和增加b</span></span><br><span class="line">                checkSum += b;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//3.持续迭代到稳定的逻辑.</span></span><br><span class="line">            <span class="comment">//这个表达式大概可以理解,线性的增加k,每次加1,直到发现已经从一个origin转满了一圈或n圈.</span></span><br><span class="line">            <span class="keyword">if</span> ((k = (k + <span class="number">1</span>) &amp; m) == origin) &#123;</span><br><span class="line">                <span class="comment">//条件:scanState表示活跃,或者满足当前线程工作队列w的ss未改变,oldSum依旧等于最新的checkSum(校验和未改变)</span></span><br><span class="line">                <span class="keyword">if</span> ((ss &gt;= <span class="number">0</span> || (ss == (ss = w.scanState))) &amp;&amp;</span><br><span class="line">                    oldSum == (oldSum = checkSum)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (ss &lt; <span class="number">0</span> || w.qlock &lt; <span class="number">0</span>)    <span class="comment">// already inactive</span></span><br><span class="line">                    <span class="comment">//3.1满足前面注释的条件,且w已经inactive,终止循环,返回null.</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="comment">//3.2又是这一段计算和替换的逻辑,只不过ns(new scanState)要加上非active标记.</span></span><br><span class="line">                    <span class="keyword">int</span> ns = ss | INACTIVE;       <span class="comment">// try to inactivate</span></span><br><span class="line">                    <span class="comment">//3.3尝试计算用来替换的ctl,它的后32位为ss加上非活跃标记,前32位减去一个活跃数单元.(终于到这了,参考前面分析的ctl前32后32位,验证了)</span></span><br><span class="line">                    <span class="keyword">long</span> nc = ((SP_MASK &amp; ns) |</span><br><span class="line">                               (UC_MASK &amp; ((c = ctl) - AC_UNIT)));</span><br><span class="line">                    <span class="comment">//原来ctl的后32位存给队列的stackPred.</span></span><br><span class="line">                    <span class="comment">//注意,此时w.stackPred和新的ctl的后32位都有一个共性,那就是它们的后31位都可以用来运算并计算得w在ws的索引.</span></span><br><span class="line">                    w.stackPred = (<span class="keyword">int</span>)c;         <span class="comment">// hold prev stack top</span></span><br><span class="line">                    <span class="comment">//3.4先把w的scanState换成ns,再用cas换ctl为nc.</span></span><br><span class="line">                    U.putInt(w, QSCANSTATE, ns);</span><br><span class="line">                    <span class="keyword">if</span> (U.compareAndSwapLong(<span class="keyword">this</span>, CTL, c, nc))</span><br><span class="line">                        <span class="comment">//替换ctl成功,ss直接指向ns,省去一次volatile读.</span></span><br><span class="line">                        ss = ns;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        <span class="comment">//3.5替换失败,再把w的scanState设置回ss.</span></span><br><span class="line">                        w.scanState = ss;         <span class="comment">// back out</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//3.6每发现回了一轮,校验和置0.</span></span><br><span class="line">                checkSum = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="awaitWork"><a href="#awaitWork" class="headerlink" title="awaitWork"></a>awaitWork</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字面意思,等待有工作可做.</span></span><br><span class="line"><span class="comment">//它其实可能会阻塞一个worker偷取任务的过程,如果worker应当关闭则直接返回false.</span></span><br><span class="line"><span class="comment">//如果worker已经处于非活睡在态,且引起了线程池的静寂,则检查线程池的终结态,只要当前worker</span></span><br><span class="line"><span class="comment">//不是唯一一个worker就等待一段时间.如果等待超时后ctl未改变(前32位的数量信息未变,后32位的栈信息也未变),</span></span><br><span class="line"><span class="comment">//则终止当前worker,它可能会唤醒另一个可能重复这个过程的worker</span></span><br><span class="line"><span class="comment">//参数w,调用者worker,r是一个自旋用的随机数种子,如果worker应当关闭,返回false.</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">awaitWork</span><span class="params">(WorkQueue w, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (w == <span class="keyword">null</span> || w.qlock &lt; <span class="number">0</span>)                 <span class="comment">// w is terminating</span></span><br><span class="line">        <span class="comment">//一个线程从注册入池起就有队列,如果它为空或者qlock被置为负(-1),应当终结.</span></span><br><span class="line">        <span class="comment">//前面提过,在deregisterWorker或tryTerminate时会将qlock置-1.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//初始化相关值,保留队列中保存的前一个栈,取出队列的ss,赋值自旋数.SPINS在前面分析</span></span><br><span class="line">    <span class="comment">//运行状态加锁时介绍过,它的值当前就是0,参考awaitRunState方法,在等待runState锁的时候,也可以根据它先自旋.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> pred = w.stackPred, spins = SPINS, ss;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((ss = w.scanState) &gt;= <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//1.队列的scanState大于0,回忆一下,前面介绍tryRelease和signal中计算vs的方法,其中一步是与~INACTIVE,而INACTIVE是1&lt;&lt;31</span></span><br><span class="line">            <span class="comment">//在前面的scan方法中已经遍历一轮且未找到task又未出现竞态未更改校验和的情况,会将scanState加上INACTIVE.</span></span><br><span class="line">            <span class="comment">//因此此处scanState突然不小于0,说明是经历过类似tryRelease或signal的释放唤醒动作,退出循环等待.</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (spins &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//2.当前未被活化,依旧处于INACTIVE态,则首先尝试自旋.使用r这个随机数来决定是否对自旋次数减1.</span></span><br><span class="line">            r ^= r &lt;&lt; <span class="number">6</span>; r ^= r &gt;&gt;&gt; <span class="number">21</span>; r ^= r &lt;&lt; <span class="number">7</span>;</span><br><span class="line">            <span class="keyword">if</span> (r &gt;= <span class="number">0</span> &amp;&amp; --spins == <span class="number">0</span>) &#123;         <span class="comment">// randomize spins</span></span><br><span class="line">                <span class="comment">//2.1自旋次数达到0时做了勾子操作.</span></span><br><span class="line">                WorkQueue v; WorkQueue[] ws; <span class="keyword">int</span> s, j; AtomicLong sc;</span><br><span class="line">                <span class="keyword">if</span> (pred != <span class="number">0</span> &amp;&amp; (ws = workQueues) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                    (j = pred &amp; SMASK) &lt; ws.length &amp;&amp;</span><br><span class="line">                    (v = ws[j]) != <span class="keyword">null</span> &amp;&amp;        <span class="comment">// see if pred parking</span></span><br><span class="line">                    (v.parker == <span class="keyword">null</span> || v.scanState &gt;= <span class="number">0</span>))</span><br><span class="line">                    <span class="comment">//2.2自旋次数降到0时,若满足几个条件:</span></span><br><span class="line">                    <span class="comment">//当前队列保存的栈下一个队列的索引(pred)存在,线程池队列非空,pred未溢出队列数组,</span></span><br><span class="line">                    <span class="comment">//取出pred对应的ws的队列(它其实是当前w在栈向栈底前进一个的元素,它存在说明当前w不是栈底.</span></span><br><span class="line">                    <span class="comment">//如果该元素存在,且它没有阻塞者或它还保持active,则重置自旋次数,继续自旋.</span></span><br><span class="line">                    spins = SPINS;                <span class="comment">// continue spinning</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (w.qlock &lt; <span class="number">0</span>)                     <span class="comment">// recheck after spins</span></span><br><span class="line">            <span class="comment">//3.自旋结束后,再次检查w的队列锁,看它是不是已经被终止了.(deregisterWorker或tryTerminate).</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!Thread.interrupted()) &#123;</span><br><span class="line">            <span class="comment">//4.如果当前线程还未被扰动.</span></span><br><span class="line">            <span class="comment">//目前我们只在一个地方看到过线程扰动的情况:awaitRunStateLock,即当一个线程尝试去修改池的运行时状态,它会去获取一个runState锁,</span></span><br><span class="line">            <span class="comment">//获取失败,发生竞态,也经过自旋等辅助策略无效的阶段,则会尝试使用stealCounter来当作锁加锁,unlock时也会在确认竞态的情况下去用它唤醒.</span></span><br><span class="line">            <span class="comment">//而在awaitRunStateLock中阻塞的线程如果正在进行stealCounter.wait时,wait操作被中断,则会扰动当前线程,这将去除进入此分支的可能.</span></span><br><span class="line">            <span class="comment">//此外,tryTerminate本身也有扰动其他工作线程的步骤.如果用户不在相应的实现代码(如ForkJoinTask的exec函数或CountedCompleter的compute函数)</span></span><br><span class="line">            <span class="comment">//中手动去扰动当前工作线程,可以理解awaitRunStateLock的扰动事件可能与tryTerminate有关.</span></span><br><span class="line">            <span class="keyword">long</span> c, prevctl, parkTime, deadline;</span><br><span class="line">            <span class="comment">//计算新的活跃数,它是原ctl的前16位(负)加上并行度.</span></span><br><span class="line">            <span class="keyword">int</span> ac = (<span class="keyword">int</span>)((c = ctl) &gt;&gt; AC_SHIFT) + (config &amp; SMASK);</span><br><span class="line">            <span class="keyword">if</span> ((ac &lt;= <span class="number">0</span> &amp;&amp; tryTerminate(<span class="keyword">false</span>, <span class="keyword">false</span>)) ||</span><br><span class="line">                (runState &amp; STOP) != <span class="number">0</span>)           <span class="comment">// pool terminating</span></span><br><span class="line">                <span class="comment">//5.发现活跃数已降至0,尝试调用tryTerminate,方法返回true表明已终止或正在终止;或发现runState已经进入终结程序.</span></span><br><span class="line">                <span class="comment">//这两种情况直接返回false,线程执行完毕终止.</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (ac &lt;= <span class="number">0</span> &amp;&amp; ss == (<span class="keyword">int</span>)c) &#123;        <span class="comment">// is last waiter</span></span><br><span class="line">                <span class="comment">//6.前面分析scan方法时讨论过,栈顶元素的scanState体现在ctl的最新后32位,它的stackPred则是ctl之前的后32位值.</span></span><br><span class="line">                <span class="comment">//进入6,说明当前worker是栈顶,即最后一个等待者.</span></span><br><span class="line">                <span class="comment">//用pred计算出之前的ctl.</span></span><br><span class="line">                prevctl = (UC_MASK &amp; (c + AC_UNIT)) | (SP_MASK &amp; pred);</span><br><span class="line">                <span class="comment">//取ctl的17-32位,即worker总数.</span></span><br><span class="line">                <span class="keyword">int</span> t = (<span class="keyword">short</span>)(c &gt;&gt;&gt; TC_SHIFT);  <span class="comment">// shrink excess spares</span></span><br><span class="line">                <span class="keyword">if</span> (t &gt; <span class="number">2</span> &amp;&amp; U.compareAndSwapLong(<span class="keyword">this</span>, CTL, c, prevctl))</span><br><span class="line">                    <span class="comment">//6.1如果发现线程总数大于2,将ctl回滚,返回false让线程终止.</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;                 <span class="comment">// else use timed wait</span></span><br><span class="line">                <span class="comment">//6.2计算deadLine和parkTime,用于后续的定时等待,暂不终结当前线程,而是作为parker.</span></span><br><span class="line">                <span class="comment">//IDLE_TIMEOUT最开始说过,它就是起这个作用的一个时间单位,把gc时间也考虑在内,默认为2秒.</span></span><br><span class="line">                parkTime = IDLE_TIMEOUT * ((t &gt;= <span class="number">0</span>) ? <span class="number">1</span> : <span class="number">1</span> - t);</span><br><span class="line">                deadline = System.nanoTime() + parkTime - TIMEOUT_SLOP;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">//7.存在active的worker或当前w不是栈顶.</span></span><br><span class="line">                prevctl = parkTime = deadline = <span class="number">0L</span>;</span><br><span class="line">            <span class="comment">//8.做线程停段的工作.</span></span><br><span class="line">            Thread wt = Thread.currentThread();</span><br><span class="line">            <span class="comment">//把当前线程池作为parker设置给线程,当使用LockSupport.park时,它将被当作一个参数传递(参考Thread类注释,在java方法签名处看不出来).</span></span><br><span class="line">            U.putObject(wt, PARKBLOCKER, <span class="keyword">this</span>);   <span class="comment">// emulate LockSupport</span></span><br><span class="line">            <span class="comment">//设置parker.</span></span><br><span class="line">            w.parker = wt;</span><br><span class="line">            <span class="keyword">if</span> (w.scanState &lt; <span class="number">0</span> &amp;&amp; ctl == c)      <span class="comment">// recheck before park</span></span><br><span class="line">                <span class="comment">//8.1重新检查非active.合格则停顿.</span></span><br><span class="line">                U.park(<span class="keyword">false</span>, parkTime);</span><br><span class="line">            <span class="comment">//归置.</span></span><br><span class="line">            U.putOrderedObject(w, QPARKER, <span class="keyword">null</span>);</span><br><span class="line">            U.putObject(wt, PARKBLOCKER, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (w.scanState &gt;= <span class="number">0</span>)</span><br><span class="line">                <span class="comment">//8.2停顿(或未停顿)重检查发现w被重新active,则退出循环返回true(非false代表不能终结当前线程).</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (parkTime != <span class="number">0L</span> &amp;&amp; ctl == c &amp;&amp;</span><br><span class="line">                deadline - System.nanoTime() &lt;= <span class="number">0L</span> &amp;&amp;</span><br><span class="line">                U.compareAndSwapLong(<span class="keyword">this</span>, CTL, c, prevctl))</span><br><span class="line">                <span class="comment">//8.3发现没有时间了,ctl也未在等待的时间发生变化,将ctl设置为w入栈前的结果,返回false让终结此线程(类似出栈).</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;                     <span class="comment">// shrink pool</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="helpComplete"><a href="#helpComplete" class="headerlink" title="helpComplete"></a>helpComplete</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//帮助完成,调用者可以是一个池中的工作线程,也可以是池外的.在JDK8版本中,有三处调用:</span></span><br><span class="line"><span class="comment">//1.CountedCompleter::helpComplete,该方法的调用由我们决定.</span></span><br><span class="line"><span class="comment">//2.ForkJoinPool::awaitJoin,等待结果的同时可以尝试帮助完成,只由池中线程调用,传入的队列是该线程的队列.该方法由ForkJoinTask的join/invoke/get调用.</span></span><br><span class="line"><span class="comment">//3.ForkJoinPool::externalHelpComplete,用于外部线程操作,前面在CountedCompleter的文章已粗略介绍,传入的w为ws中用一个随机数与n-1和0x007e取与运算</span></span><br><span class="line"><span class="comment">//的结果,很明显,即使w不是null,也只能是一个偶数位的元素,这意味着w不会是registerWoker时生成的带有工作线程的WorkQueue.也就是不能帮助池中线程完成自己的队列.</span></span><br><span class="line"><span class="comment">//本方法会尝试从当前的计算目标之内偷取一个任务,它使用顶层算法的变种,限制偷出来的任务必须是给定任务的后代,但是也有一些细节要注意.</span></span><br><span class="line"><span class="comment">//首先,它会尝试从自己的工作队列中找合格的任务(用前面讲过的WorkQueue::popCC),若不能找到则扫描其他队列,当发生竞态时随机移动指针,依照校验和机制决定是否放弃</span></span><br><span class="line"><span class="comment">//帮助执行(这取决于前面介绍的pollAndExecCC的返回码).参数maxTasks是对外部使用的支持参数,内部调用它会传入0,允许无界的次数(外部调用时,捕获非法的非正数).</span></span><br><span class="line"><span class="comment">//参数w,队列,在内部调用的情况下可以理解为当前线程的工作队列,参数maxTasks如果非0,指代最大的可运行的其他任务.退出时方法返回任务状态.</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">helpComplete</span><span class="params">(WorkQueue w, CountedCompleter&lt;?&gt; task,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">int</span> maxTasks)</span> </span>&#123;</span><br><span class="line">    WorkQueue[] ws; <span class="keyword">int</span> s = <span class="number">0</span>, m;</span><br><span class="line">    <span class="comment">//变量初始化和验证,队列和参数w必须非空才能进入if.</span></span><br><span class="line">    <span class="keyword">if</span> ((ws = workQueues) != <span class="keyword">null</span> &amp;&amp; (m = ws.length - <span class="number">1</span>) &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">        task != <span class="keyword">null</span> &amp;&amp; w != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//介绍popCC时曾专门强调过这个mode其实是config.</span></span><br><span class="line">        <span class="keyword">int</span> mode = w.config;                 <span class="comment">// for popCC</span></span><br><span class="line">        <span class="keyword">int</span> r = w.hint ^ w.top;              <span class="comment">// arbitrary seed for origin</span></span><br><span class="line">        <span class="keyword">int</span> origin = r &amp; m;                  <span class="comment">// first queue to scan</span></span><br><span class="line">        <span class="comment">//初始时赋h为1,在每一轮循环中,它取1代表正在正常运行,大于1代表发生了竞态,小于0将增加到校验和,代表pollAndExecCC达到了根元素.</span></span><br><span class="line">        <span class="comment">//详细参考前面论述过的pollAndExecCC.</span></span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">1</span>;                           <span class="comment">// 1:ran, &gt;1:contended, &lt;0:hash</span></span><br><span class="line">        <span class="comment">//初始化条件循环条件,记录origin的值,初始化oldSum和checkSum</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = origin, oldSum = <span class="number">0</span>, checkSum = <span class="number">0</span>;;) &#123;</span><br><span class="line">            CountedCompleter&lt;?&gt; p; WorkQueue q;</span><br><span class="line">            <span class="comment">//1.传入的任务已经是完成的,break返回s(负).</span></span><br><span class="line">            <span class="keyword">if</span> ((s = task.status) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//2.h未经过更改或经历过若干次更改,但在上一轮循环代表了pollAndExecCC成功执行task(h取1),则</span></span><br><span class="line">            <span class="comment">//在当轮循环尝试对w进行popCC,并根据mode决定从base还是top出队.</span></span><br><span class="line">            <span class="keyword">if</span> (h == <span class="number">1</span> &amp;&amp; (p = w.popCC(task, mode)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//2.1本队列有满足条件的任务,执行之.</span></span><br><span class="line">                p.doExec();                  <span class="comment">// run local task</span></span><br><span class="line">                <span class="keyword">if</span> (maxTasks != <span class="number">0</span> &amp;&amp; --maxTasks == <span class="number">0</span>)</span><br><span class="line">                    <span class="comment">//减少maxTask并在它降到0时break.(前提是传入了正数的maxTasks).</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">//2.2没降到0,把origin和校验和参数重设为循环初始化的值.</span></span><br><span class="line">                origin = k;                  <span class="comment">// reset</span></span><br><span class="line">                oldSum = checkSum = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//3.某轮循环h代表出现竞态等问题或不能使用popCC方式从本地队列出任务执行.尝试从其他队列poll执行.</span></span><br><span class="line">            <span class="keyword">else</span> &#123;                           <span class="comment">// poll other queues</span></span><br><span class="line">                <span class="comment">//3.1 找不出任务,h置0,这将使它在随后的循环中不会再进入2</span></span><br><span class="line">                <span class="keyword">if</span> ((q = ws[k]) == <span class="keyword">null</span>)</span><br><span class="line">                    h = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">//3.2尝试从q的base处poll并执行task.返回-1代表不匹配,对校验和增加h(负数).</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((h = q.pollAndExecCC(task)) &lt; <span class="number">0</span>)</span><br><span class="line">                    checkSum += h;</span><br><span class="line">                <span class="comment">//3.3 h大于0,可能是等于1但popCC未成功的情况.也可能是pollAndExecCC成功了一次或cas失败.</span></span><br><span class="line">                <span class="keyword">if</span> (h &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (h == <span class="number">1</span> &amp;&amp; maxTasks != <span class="number">0</span> &amp;&amp; --maxTasks == <span class="number">0</span>)</span><br><span class="line">                        <span class="comment">//h是1减maxTask,当它达到0终止循环.(前提是没传了正数的maxTasks)</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="comment">//h不等于1,一般是poll时cas失败,重置r,origin,checkSum等,开下一轮循环.</span></span><br><span class="line">                    r ^= r &lt;&lt; <span class="number">13</span>; r ^= r &gt;&gt;&gt; <span class="number">17</span>; r ^= r &lt;&lt; <span class="number">5</span>; <span class="comment">// xorshift</span></span><br><span class="line">                    origin = k = r &amp; m;      <span class="comment">// move and restart</span></span><br><span class="line">                    oldSum = checkSum = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//3.4前面见过类似的代码,发现已经转完了一轮,校验和未改变过(任何一个队列都未进3.2/3.3,也就是查找任何一个下标ws[k]都是null),break.</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((k = (k + <span class="number">1</span>) &amp; m) == origin) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (oldSum == (oldSum = checkSum))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="comment">//发现校验和有变更,说明有一轮循环未进入3.1,再次循环.</span></span><br><span class="line">                    checkSum = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返架退出循环是task的status.</span></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="helpStealer"><a href="#helpStealer" class="headerlink" title="helpStealer"></a>helpStealer</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字面意思:尝试帮助一个"小偷".</span></span><br><span class="line"><span class="comment">//本方法会尝试定位到task的偷盗者,并尝试执行偷盗者(可能偷盗者的偷盗者)的任务.它会追踪currentSteal(前面runTask时提过,会将参数task置为currentSteal)-&gt;</span></span><br><span class="line"><span class="comment">//currentJoin(当前队列等待的任务,后面会介绍awaitJoin方法),这样追寻一个线程在给定的task的后续工作,它会使用非空队列偷回和执行任务.方法的第一次从等待join调用</span></span><br><span class="line"><span class="comment">//通常意味着scan搜索,因为joiner没有什么更适合做的,这种做法也是ok的.本方法会在worker中留下hint标识来加速后续的调用.</span></span><br><span class="line"><span class="comment">//参数w代表caller的队列,task是要join的任务.</span></span><br><span class="line"><span class="comment">//方法共分三层循环,最外层是一个do-while循环,其内是两个for循环.</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helpStealer</span><span class="params">(WorkQueue w, ForkJoinTask&lt;?&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//初始化和进入if的条件,没什么可说的.</span></span><br><span class="line">    WorkQueue[] ws = workQueues;</span><br><span class="line">    <span class="keyword">int</span> oldSum = <span class="number">0</span>, checkSum, m;</span><br><span class="line">    <span class="keyword">if</span> (ws != <span class="keyword">null</span> &amp;&amp; (m = ws.length - <span class="number">1</span>) &gt;= <span class="number">0</span> &amp;&amp; w != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">        task != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//循环一:方法最外层的while循环.它的条件是task未完成且校验和未发生变化.</span></span><br><span class="line">        <span class="keyword">do</span> &#123;                                       <span class="comment">// restart point</span></span><br><span class="line">            <span class="comment">//每次循环一的起点,校验和重置为0.用j保存w.</span></span><br><span class="line">            checkSum = <span class="number">0</span>;                          <span class="comment">// for stability check</span></span><br><span class="line">            ForkJoinTask&lt;?&gt; subtask;</span><br><span class="line">            WorkQueue j = w, v;                    <span class="comment">// v is subtask stealer</span></span><br><span class="line">            <span class="comment">//循环二:外部for循环,subtask初始指向参数task,循环条件是subtask未完成.</span></span><br><span class="line">            <span class="comment">//在每次循环四中会校验当前小偷的队列是否空了,如果空了则换它的小偷继续偷(交给subtask指向).</span></span><br><span class="line">            descent: <span class="keyword">for</span> (subtask = task; subtask.status &gt;= <span class="number">0</span>; ) &#123;</span><br><span class="line">                <span class="comment">//循环三:内部第一个for循环,初始化变量h,用hint加上奇数位,保证从奇数索引取队列.k初始为0,每次循环结束加2.</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> h = j.hint | <span class="number">1</span>, k = <span class="number">0</span>, i; ; k += <span class="number">2</span>) &#123;</span><br><span class="line">                    <span class="comment">//1.循环三内的逻辑.</span></span><br><span class="line">                    <span class="comment">//1.1发现k已经递增到大于最大索引m了,直接终止循环二,若发现task还未完成,校验和也未更改,则进行上面的重置操作并重新开始循环二.</span></span><br><span class="line">                    <span class="keyword">if</span> (k &gt; m)                     <span class="comment">// can't find stealer</span></span><br><span class="line">                        <span class="keyword">break</span> descent;</span><br><span class="line">                    <span class="comment">//1.2i位置标记为h+k的结果与运算m,因为k每次增2,h又是奇数,故保证只取有线程主的队列.</span></span><br><span class="line">                    <span class="keyword">if</span> ((v = ws[i = (h + k) &amp; m]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (v.currentSteal == subtask) &#123;</span><br><span class="line">                            <span class="comment">//发现偷取currentSteal的worker v,将它的索引i交给j(初始为w,在2内会更改为"等待队列"的元素,在while循环中会重置为w)的hint,</span></span><br><span class="line">                            <span class="comment">//方便下一次再进入循环三时的查找.并终止循环三,进入循环四的判断入口.</span></span><br><span class="line">                            j.hint = i;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//1.3存在非空v,但是v未偷取subtask,将v的base加给校验和.这将影响到循环一的判真条件.显然从循环三退出循环二,或后续循环四退出循环二</span></span><br><span class="line">                        <span class="comment">//将导致循环一也一并因while条件不满而退出.</span></span><br><span class="line">                        checkSum += v.base;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//循环四:迭代subtask的循环,它必须经循环三中的1.2走出.</span></span><br><span class="line">                <span class="comment">//2.到达循环四,一定已经在循环三中找到了一个v,此处会尝试帮助v或者它的产生的"后裔".</span></span><br><span class="line">                <span class="keyword">for</span> (;;) &#123;                         <span class="comment">// help v or descend</span></span><br><span class="line">                    ForkJoinTask&lt;?&gt;[] a; <span class="keyword">int</span> b;</span><br><span class="line">                    <span class="comment">//2.1类似1.3的逻辑,校验和增加v.base,初始化next,增加校验和意味着,只要从循环四退出了循环二,则最外的循环一的while条件将不满足.</span></span><br><span class="line">                    checkSum += (b = v.base);</span><br><span class="line">                    <span class="comment">//next取v的currentJoin.</span></span><br><span class="line">                    ForkJoinTask&lt;?&gt; next = v.currentJoin;</span><br><span class="line">                    <span class="keyword">if</span> (subtask.status &lt; <span class="number">0</span> || j.currentJoin != subtask ||</span><br><span class="line">                        v.currentSteal != subtask) <span class="comment">// stale</span></span><br><span class="line">                        <span class="comment">//2.2如果subtask已是完成态,或发现竞态等情况造成数据已脏,如发现本轮循环中j的当前join已不是当前subtask,</span></span><br><span class="line">                        <span class="comment">//或v的当前steal不是subtask,说明出现了脏数据,直接终止循环二,重新进入while循环重初始化jv.</span></span><br><span class="line">                        <span class="keyword">break</span> descent;</span><br><span class="line">                    <span class="comment">//2.3发现队列v已空的逻辑.</span></span><br><span class="line">                    <span class="keyword">if</span> (b - v.top &gt;= <span class="number">0</span> || (a = v.array) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> ((subtask = next) == <span class="keyword">null</span>)</span><br><span class="line">                            <span class="comment">//2.3.1 v已空,且不存在next,即"等待队列"已空,退出循环二,重新while判定循环条件,重初始化jv.</span></span><br><span class="line">                            <span class="keyword">break</span> descent;</span><br><span class="line">                        <span class="comment">//2.3.2 还有next,将subtask指向next的同时,用v替换掉j.这是明显的迭代语句.</span></span><br><span class="line">                        <span class="comment">//在前面的代码中可以看出,循环一就是为subtask找出小偷v的,关系是v.currentSteal=subtask.同时j.currentJoin=subtask.</span></span><br><span class="line">                        <span class="comment">//因为next=v.currentJoin,将v赋给j后,仍旧满足j.currentJoin=next=subtask,此时break掉循环四,重新开启循环二的新一轮</span></span><br><span class="line">                        <span class="comment">//正好对v进行重新初始化,而找到v的条件又是v.currentSteal=subtask,也即等于j.currentJoin.</span></span><br><span class="line">                        <span class="comment">//此处break掉的循环四将导致循环二的下轮将在循环三处重新为新的j找到v(v.currentSteal==subtask).</span></span><br><span class="line">                        j = v;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//2.4未进入2.3.1/2.3.2的情况,显然进入这两者会break到循环一或二.</span></span><br><span class="line">                    <span class="comment">//取出base索引位置i和相应的任务元素.</span></span><br><span class="line">                    <span class="keyword">int</span> i = (((a.length - <span class="number">1</span>) &amp; b) &lt;&lt; ASHIFT) + ABASE;</span><br><span class="line">                    ForkJoinTask&lt;?&gt; t = ((ForkJoinTask&lt;?&gt;)</span><br><span class="line">                                         U.getObjectVolatile(a, i));</span><br><span class="line">                    <span class="comment">//2.5,接2.4,判断竞态,v.base!=b说明已经被别的线程将base元素出队.这种情况下直接进入下一轮的循环二.</span></span><br><span class="line">                    <span class="keyword">if</span> (v.base == b) &#123;</span><br><span class="line">                        <span class="comment">//2.5.1 取出任务t,发现空为脏数据,从while循环重新初始化.</span></span><br><span class="line">                        <span class="keyword">if</span> (t == <span class="keyword">null</span>)             <span class="comment">// stale</span></span><br><span class="line">                            <span class="keyword">break</span> descent;</span><br><span class="line">                        <span class="comment">//2.5.2,将t出队并进行后续流程.</span></span><br><span class="line">                        <span class="keyword">if</span> (U.compareAndSwapObject(a, i, t, <span class="keyword">null</span>)) &#123;</span><br><span class="line">                            <span class="comment">//2.5.3首先将v的base增1.</span></span><br><span class="line">                            v.base = b + <span class="number">1</span>;</span><br><span class="line">                            <span class="comment">//2.5.4取出w(方法参数,当前worker)的currentSteal保存到ps.</span></span><br><span class="line">                            ForkJoinTask&lt;?&gt; ps = w.currentSteal;</span><br><span class="line">                            <span class="keyword">int</span> top = w.top;</span><br><span class="line">                            <span class="keyword">do</span> &#123;</span><br><span class="line">                                <span class="comment">//2.5.5此循环不和循环一至四一块罗列,因为它本质上只是任务的出队与执行.</span></span><br><span class="line">                                <span class="comment">//首先会尝试将w队列的currentSteal置为刚刚从v的任务数组中出队的t</span></span><br><span class="line">                                U.putOrderedObject(w, QCURRENTSTEAL, t);</span><br><span class="line">                                <span class="comment">//执行t.执行后顺带循环处理自己刚压入队列w的任务.执行后,也跳出当前while循环的情况下会在下次重新判断2.3,</span></span><br><span class="line">                                <span class="comment">//非空继续找base(i),为空则迭代v为next(2.3.2).</span></span><br><span class="line">                                t.doExec();        <span class="comment">// clear local tasks too</span></span><br><span class="line">                            <span class="comment">//2.5.6循环条件,只要参数task还未完成,w新压入了任务,则依次尝试从w中pop元素,和前面的t一样按序执行(此处顺带执行自己的任务).</span></span><br><span class="line">                            &#125; <span class="keyword">while</span> (task.status &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">                                     w.top != top &amp;&amp;</span><br><span class="line">                                     (t = w.pop()) != <span class="keyword">null</span>);</span><br><span class="line">                            <span class="comment">//2.5.7偷了小偷v的base任务并执行成功,则恢复w的currentSteal.</span></span><br><span class="line">                            U.putOrderedObject(w, QCURRENTSTEAL, ps);</span><br><span class="line">                            <span class="keyword">if</span> (w.base != w.top)</span><br><span class="line">                                <span class="comment">//2.5.8偷完并执行完当前v的base任务或者某一轮的等待队列上的元素v的base任务后,发现自己的队列非空了,就不再帮助对方,方法return.</span></span><br><span class="line">                                <span class="comment">//可以参考awaitJoin方法,因为helpStealer只在awaitJoin中调用,调用的前提就是w.base==w.top.</span></span><br><span class="line">                                <span class="comment">//这显然与2.5.6有所纠结(尽管一个判断top,一个判断top和base的相等),只要到了2.5.8,队列非空将返回.</span></span><br><span class="line">                                <span class="keyword">return</span>;            <span class="comment">// can't further help</span></span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//出队失败同2.5.1一样,竞态失败重新循环二,但在下一轮循环中会在2.5.1break回while循环.</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">//最外层的while循环条件,task未完成,校验和未发生更改.</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (task.status &gt;= <span class="number">0</span> &amp;&amp; oldSum != (oldSum = checkSum));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="tryCompensate"><a href="#tryCompensate" class="headerlink" title="tryCompensate"></a>tryCompensate</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字面意思:尝试补偿.</span></span><br><span class="line"><span class="comment">//方法会尝试减少活跃数(有时是隐式的)并可能会因阻塞释放或创建一个补偿worker.</span></span><br><span class="line"><span class="comment">//在出现竞态,发现脏数据,不稳定,终止的情况下返回false,并可重试.参数w代表调用者.</span></span><br><span class="line"><span class="comment">//方法实现比较简单,为简单的if else模式,只有一个分支可以执行.</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">tryCompensate</span><span class="params">(WorkQueue w)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//canBlock为返回值.</span></span><br><span class="line">    <span class="keyword">boolean</span> canBlock;</span><br><span class="line">    WorkQueue[] ws; <span class="keyword">long</span> c; <span class="keyword">int</span> m, pc, sp;</span><br><span class="line">    <span class="comment">//1.发现调用者终止了,线程池队列数组为空,或者禁用了并行度,则返回false.</span></span><br><span class="line">    <span class="keyword">if</span> (w == <span class="keyword">null</span> || w.qlock &lt; <span class="number">0</span> ||           <span class="comment">// caller terminating</span></span><br><span class="line">        (ws = workQueues) == <span class="keyword">null</span> || (m = ws.length - <span class="number">1</span>) &lt;= <span class="number">0</span> ||</span><br><span class="line">        (pc = config &amp; SMASK) == <span class="number">0</span>)           <span class="comment">// parallelism disabled</span></span><br><span class="line">        canBlock = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//2.发现当前ctl表示有worker正等待任务(空闲,位于scan),则尝试释放它,让它回来工作.</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((sp = (<span class="keyword">int</span>)(c = ctl)) != <span class="number">0</span>)      <span class="comment">// release idle worker</span></span><br><span class="line">        canBlock = tryRelease(c, ws[sp &amp; m], <span class="number">0L</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//3.当前所有worker都在忙碌.</span></span><br><span class="line">        <span class="comment">//3.1计算活跃数,总数,计算方法前面已经论述多次.</span></span><br><span class="line">        <span class="keyword">int</span> ac = (<span class="keyword">int</span>)(c &gt;&gt; AC_SHIFT) + pc;</span><br><span class="line">        <span class="keyword">int</span> tc = (<span class="keyword">short</span>)(c &gt;&gt; TC_SHIFT) + pc;</span><br><span class="line">        <span class="comment">//记录nbusy,注释表示用于验证饱合度.</span></span><br><span class="line">        <span class="keyword">int</span> nbusy = <span class="number">0</span>;                        <span class="comment">// validate saturation</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; ++i) &#123;        <span class="comment">// two passes of odd indices</span></span><br><span class="line">            WorkQueue v;</span><br><span class="line">            <span class="comment">//3.2nbusy的计算方法,遍历线程池的队列数组(每次增1),验证则以1-3-5这个顺序开始,发现有处于SCANNING态的,就停掉循环,否则加1.</span></span><br><span class="line">            <span class="keyword">if</span> ((v = ws[((i &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>) &amp; m]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((v.scanState &amp; SCANNING) != <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                ++nbusy;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.3如果非稳态(饱合度不是tc的2倍),或者ctl脏读,则返回false.</span></span><br><span class="line">        <span class="keyword">if</span> (nbusy != (tc &lt;&lt; <span class="number">1</span>) || ctl != c)</span><br><span class="line">            canBlock = <span class="keyword">false</span>;                 <span class="comment">// unstable or stale</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (tc &gt;= pc &amp;&amp; ac &gt; <span class="number">1</span> &amp;&amp; w.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">//3.4处于稳态且ctl还有效,总worker数大于并行度且活跃数大于1而且当前w又是空的.尝试将ctl减去一个活跃位.</span></span><br><span class="line">            <span class="keyword">long</span> nc = ((AC_MASK &amp; (c - AC_UNIT)) |</span><br><span class="line">                       (~AC_MASK &amp; c));       <span class="comment">// uncompensated 反补偿,初看莫名其妙,调用者会在之后增加ac.</span></span><br><span class="line">            <span class="comment">//返回值为cas是否成功.</span></span><br><span class="line">            canBlock = U.compareAndSwapLong(<span class="keyword">this</span>, CTL, c, nc);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (tc &gt;= MAX_CAP ||</span><br><span class="line">                 (<span class="keyword">this</span> == common &amp;&amp; tc &gt;= pc + commonMaxSpares))</span><br><span class="line">            <span class="comment">//3.5普通ForkJoinPool,总worker数达到MAX_CAP,或common池,总worker数量达到并行度+commonMaxSpares(默认256),抛出拒绝异常.</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(</span><br><span class="line">                <span class="string">"Thread limit exceeded replacing blocked worker"</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;                                <span class="comment">// similar to tryAddWorker</span></span><br><span class="line">            <span class="keyword">boolean</span> add = <span class="keyword">false</span>; <span class="keyword">int</span> rs;      <span class="comment">// CAS within lock</span></span><br><span class="line">            <span class="comment">//3.6.计算新的ctl,增加一个总worker数.</span></span><br><span class="line">            <span class="keyword">long</span> nc = ((AC_MASK &amp; c) |</span><br><span class="line">                       (TC_MASK &amp; (c + TC_UNIT)));</span><br><span class="line">            <span class="comment">//加运行状态锁,池未进入终止态的情况下,进行cas,随后解锁.</span></span><br><span class="line">            <span class="keyword">if</span> (((rs = lockRunState()) &amp; STOP) == <span class="number">0</span>)</span><br><span class="line">                add = U.compareAndSwapLong(<span class="keyword">this</span>, CTL, c, nc);</span><br><span class="line">            unlockRunState(rs, rs &amp; ~RSLOCK);</span><br><span class="line">            <span class="comment">//cas成功,则创建worker</span></span><br><span class="line">            canBlock = add &amp;&amp; createWorker(); <span class="comment">// throws on exception</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> canBlock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="awaitJoin"><a href="#awaitJoin" class="headerlink" title="awaitJoin"></a>awaitJoin</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前面提过它很多次了,awaitJoin方法会在指定任务完成或者超时前尝试帮助或阻塞自身.</span></span><br><span class="line"><span class="comment">//参数w代表调用者,task为目标任务,参数deadline是超时目标(非0).它会返回退出时的任务状态.</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">awaitJoin</span><span class="params">(WorkQueue w, ForkJoinTask&lt;?&gt; task, <span class="keyword">long</span> deadline)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//返回值.</span></span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (task != <span class="keyword">null</span> &amp;&amp; w != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//1.若未进入if必然返回0,进入条件是提供了task和w.</span></span><br><span class="line">        <span class="comment">//保存currentJoin</span></span><br><span class="line">        ForkJoinTask&lt;?&gt; prevJoin = w.currentJoin;</span><br><span class="line">        <span class="comment">//将w的currentJoin暂时设置为task.</span></span><br><span class="line">        U.putOrderedObject(w, QCURRENTJOIN, task);</span><br><span class="line">        <span class="comment">//如果task是CountedCompleter类型,转化并存放到cc.</span></span><br><span class="line">        CountedCompleter&lt;?&gt; cc = (task <span class="keyword">instanceof</span> CountedCompleter) ?</span><br><span class="line">            (CountedCompleter&lt;?&gt;)task : <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//2.循环.</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((s = task.status) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="comment">//2.1目标task已完成,返回task的status.</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (cc != <span class="keyword">null</span>)</span><br><span class="line">                <span class="comment">//2.2目标task是CountedCompleter,调用前面介绍过的helpComplete方法,maxTasks不限(0).</span></span><br><span class="line">                helpComplete(w, cc, <span class="number">0</span>);</span><br><span class="line">            <span class="comment">//2.3否则发现队列w已空,或者非空,则尝试从w中移除并执行task,若出现队列w是空且任务不知道是否完成的情况(t.doExec只是执行,不等结果),</span></span><br><span class="line">            <span class="comment">//此处也会拿到一个true,则调用前面介绍过的helpStealer去帮助小偷.</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (w.base == w.top || w.tryRemoveAndExec(task))</span><br><span class="line">                helpStealer(w, task);</span><br><span class="line">            <span class="comment">//2.4.帮助需要时间,double check,同2.1.</span></span><br><span class="line">            <span class="keyword">if</span> ((s = task.status) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//2.5计算deadline有关的停顿时间ms.</span></span><br><span class="line">            <span class="keyword">long</span> ms, ns;</span><br><span class="line">            <span class="keyword">if</span> (deadline == <span class="number">0L</span>)</span><br><span class="line">                ms = <span class="number">0L</span>;<span class="comment">//未指定deadline,ms为0</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((ns = deadline - System.nanoTime()) &lt;= <span class="number">0L</span>)</span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">//要指定的deadline已经早于当前时间了,break返回上面的status</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((ms = TimeUnit.NANOSECONDS.toMillis(ns)) &lt;= <span class="number">0L</span>)</span><br><span class="line">                ms = <span class="number">1L</span>;<span class="comment">//用上面的ns计算ms发现负数,重置ms为1</span></span><br><span class="line">            <span class="comment">//2.6,调用上面提到过的tryCompensate方法,传入当前worker,如果得到true的返回值,等待超时,</span></span><br><span class="line">            <span class="comment">//超时结束增加一个活跃位(前面提到tryCompensate方法最后加增加tc并创建worker,不增加ac,或者莫名其妙地减去了一个ac).</span></span><br><span class="line">            <span class="keyword">if</span> (tryCompensate(w)) &#123;</span><br><span class="line">                task.internalWait(ms);</span><br><span class="line">                U.getAndAddLong(<span class="keyword">this</span>, CTL, AC_UNIT);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.最后恢复原来的currentJoin.</span></span><br><span class="line">        U.putOrderedObject(w, QCURRENTJOIN, prevJoin);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="findNonEmptyStealQueue"><a href="#findNonEmptyStealQueue" class="headerlink" title="findNonEmptyStealQueue"></a>findNonEmptyStealQueue</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//简单的方法,尝试找一个非空的偷盗队列.使用类似简化的scan的方式查取,可能返回null.</span></span><br><span class="line"><span class="comment">//如果调用者想要尝试使用队列,必须在得到空后多次尝试.</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> WorkQueue <span class="title">findNonEmptyStealQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    WorkQueue[] ws; <span class="keyword">int</span> m;  </span><br><span class="line">    <span class="comment">//随机数r</span></span><br><span class="line">    <span class="keyword">int</span> r = ThreadLocalRandom.nextSecondarySeed();</span><br><span class="line">    <span class="comment">//线程池不具备队列,直接返回null.</span></span><br><span class="line">    <span class="keyword">if</span> ((ws = workQueues) != <span class="keyword">null</span> &amp;&amp; (m = ws.length - <span class="number">1</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//循环开始.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> origin = r &amp; m, k = origin, oldSum = <span class="number">0</span>, checkSum = <span class="number">0</span>;;) &#123;</span><br><span class="line">            WorkQueue q; <span class="keyword">int</span> b;</span><br><span class="line">            <span class="keyword">if</span> ((q = ws[k]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((b = q.base) - q.top &lt; <span class="number">0</span>)</span><br><span class="line">                    <span class="comment">//查到q这个WorkQueue,并且q非空,则将q返回.</span></span><br><span class="line">                    <span class="keyword">return</span> q;</span><br><span class="line">                <span class="comment">//查到了空队列q,则校验和加上q的base.</span></span><br><span class="line">                checkSum += b;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//前面多次见过的判断进入第二轮的办法.发现ws从头到尾都是null则break返回null,否则出现非null的空队列则将校验和置0继续循环.</span></span><br><span class="line">            <span class="keyword">if</span> ((k = (k + <span class="number">1</span>) &amp; m) == origin) &#123;</span><br><span class="line">                <span class="keyword">if</span> (oldSum == (oldSum = checkSum))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                checkSum = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="helpQuiescePool"><a href="#helpQuiescePool" class="headerlink" title="helpQuiescePool"></a>helpQuiescePool</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//运行任务,直到isQuiescent,本方法顺带维护ctl中的活跃数,但是全过程不会在任务不能找到的情况下</span></span><br><span class="line"><span class="comment">//进行阻塞,而是进行重新扫描,直到所有其他worker的队列中都不能找出任务为止.</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">helpQuiescePool</span><span class="params">(WorkQueue w)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//保存当前偷取的任务.</span></span><br><span class="line">    ForkJoinTask&lt;?&gt; ps = w.currentSteal; <span class="comment">// save context</span></span><br><span class="line">    <span class="comment">//循环开始,active置true.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">boolean</span> active = <span class="keyword">true</span>;;) &#123;</span><br><span class="line">        <span class="keyword">long</span> c; WorkQueue q; ForkJoinTask&lt;?&gt; t; <span class="keyword">int</span> b;</span><br><span class="line">        <span class="comment">//1.先把本地任务执行完毕(每次循环扫描).</span></span><br><span class="line">        w.execLocalTasks();   </span><br><span class="line">        <span class="comment">//2.查找到非空队列的情况,除了2以外的34在cas成功的情况下都会终止循环.</span></span><br><span class="line">        <span class="keyword">if</span> ((q = findNonEmptyStealQueue()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//2.1经过3中成功减少了活跃数的情况,下一次循环又扫描到了新的非空队列,需要重激活.</span></span><br><span class="line">            <span class="keyword">if</span> (!active) &#123;      </span><br><span class="line">                active = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">//活跃数重新加1.</span></span><br><span class="line">                U.getAndAddLong(<span class="keyword">this</span>, CTL, AC_UNIT);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//2.2再次判断队列非空,并从队列内部数组的base起取出task</span></span><br><span class="line">            <span class="keyword">if</span> ((b = q.base) - q.top &lt; <span class="number">0</span> &amp;&amp; (t = q.pollAt(b)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//将task置于currentSteal</span></span><br><span class="line">                U.putOrderedObject(w, QCURRENTSTEAL, t);</span><br><span class="line">                <span class="comment">//执行task</span></span><br><span class="line">                t.doExec();</span><br><span class="line">                <span class="comment">//如果w的偷取任务数溢出,转到池中.</span></span><br><span class="line">                <span class="keyword">if</span> (++w.nsteals &lt; <span class="number">0</span>)</span><br><span class="line">                    w.transferStealCount(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.仍旧保持active的情况.</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (active) &#123; </span><br><span class="line">            <span class="comment">//3.1能进到这里,肯定本轮循环未能进入2,说明未能发现非空队列,计算新的ctl即nc,它是原ctl减去一个活跃单位.  </span></span><br><span class="line">            <span class="keyword">long</span> nc = (AC_MASK &amp; ((c = ctl) - AC_UNIT)) | (~AC_MASK &amp; c);</span><br><span class="line">            <span class="keyword">if</span> ((<span class="keyword">int</span>)(nc &gt;&gt; AC_SHIFT) + (config &amp; SMASK) &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="comment">//3.2新的活跃数加上并行度还不大于0,即不能溢出,说明没有活跃数,不进行cas了,直接break.</span></span><br><span class="line">                <span class="comment">//很明显,上面计算nc的方法,首先ctl正常本身是负,若上面表达式为正,唯一的解释是线程池有活跃线程(前面讲过,活跃一个加一个活跃单元,直到并行度为止)</span></span><br><span class="line">                <span class="comment">//因为两个表达式分别是前16位(在前面再补上16个1)和后16位求和.</span></span><br><span class="line">                <span class="keyword">break</span>;  </span><br><span class="line">            <span class="comment">//3.3未能从3.2退出,说明nc表示当前有活跃数存在,进行cas,成功后active置false,不退出循环.</span></span><br><span class="line">            <span class="comment">//若下轮循环发现新的非空队列,会在2.1处增加回来.若未能发现,会在4处加回来.       </span></span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapLong(<span class="keyword">this</span>, CTL, c, nc))</span><br><span class="line">                active = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4.前一轮循环进了3.3,当前循环未能进入2.1的情况,判断当前ctl活跃数加上并行度是非正,说明再创建并行度个数的worker也不能溢出.则再加回一个活跃数.</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="keyword">int</span>)((c = ctl) &gt;&gt; AC_SHIFT) + (config &amp; SMASK) &lt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">                 U.compareAndSwapLong(<span class="keyword">this</span>, CTL, c, c + AC_UNIT))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//5.重新恢复currentSteal</span></span><br><span class="line">    U.putOrderedObject(w, QCURRENTSTEAL, ps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="nextTaskFor"><a href="#nextTaskFor" class="headerlink" title="nextTaskFor"></a>nextTaskFor</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取并移除一个本地或偷来的任务.</span></span><br><span class="line"><span class="keyword">final</span> ForkJoinTask&lt;?&gt; nextTaskFor(WorkQueue w) &#123;</span><br><span class="line">    <span class="keyword">for</span> (ForkJoinTask&lt;?&gt; t;;) &#123;</span><br><span class="line">        WorkQueue q; <span class="keyword">int</span> b;</span><br><span class="line">        <span class="comment">//首先尝试nextLocalTask本地任务.</span></span><br><span class="line">        <span class="keyword">if</span> ((t = w.nextLocalTask()) != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        <span class="comment">//获取不到本地任务,尝试从其他队列获取非空队列,获取不到非空队列,返回null.</span></span><br><span class="line">        <span class="keyword">if</span> ((q = findNonEmptyStealQueue()) == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//获取到了非空队列,从base处取任务,非空则返回,为空则重复循环.</span></span><br><span class="line">        <span class="keyword">if</span> ((b = q.base) - q.top &lt; <span class="number">0</span> &amp;&amp; (t = q.pollAt(b)) != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="tryTerminate"><a href="#tryTerminate" class="headerlink" title="tryTerminate"></a>tryTerminate</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前面不止一次提到过tryTerminate,说过它会尝试终止或完成终止.</span></span><br><span class="line"><span class="comment">//参数now如果设置为true,则表示在runState进入SHUTDOWN关闭态(负)时无条件终止,否则需要在进入SHUTDOWN同时没有work也没有活跃worker的情况下终止.</span></span><br><span class="line"><span class="comment">//如果设置enable为true,则下次调用时runState为负,可直接进入关闭流程(如果有now为true,则立即关).</span></span><br><span class="line"><span class="comment">//如果当前线程池进入终止流程或已终止,返回true.</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">tryTerminate</span><span class="params">(<span class="keyword">boolean</span> now, <span class="keyword">boolean</span> enable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rs;</span><br><span class="line">    <span class="comment">//common池不可关.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == common)                       <span class="comment">// cannot shut down</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//1.runState拦截和处理.</span></span><br><span class="line">    <span class="keyword">if</span> ((rs = runState) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!enable)</span><br><span class="line">            <span class="comment">//1.1对于当前runState非负的情况,如果没有指定enable,返回false.</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//1.2如果指定了enable,将加运行状态锁并更新runState的首位为1,即runState下次进入时为负.不再进入1的拦截处理流程.</span></span><br><span class="line">        rs = lockRunState();                 </span><br><span class="line">        unlockRunState(rs, (rs &amp; ~RSLOCK) | SHUTDOWN);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.终止的处理流程.</span></span><br><span class="line">    <span class="keyword">if</span> ((rs &amp; STOP) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//2.1.没有指定即刻关闭,检查是否线程池已进入静寂态.</span></span><br><span class="line">        <span class="keyword">if</span> (!now) &#123; </span><br><span class="line">            <span class="comment">//循环重复直到稳态.初始化校验和机制.                          </span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">long</span> oldSum = <span class="number">0L</span>;;) &#123;        </span><br><span class="line">                WorkQueue[] ws; WorkQueue w; <span class="keyword">int</span> m, b; <span class="keyword">long</span> c;</span><br><span class="line">                <span class="keyword">long</span> checkSum = ctl;<span class="comment">//校验和取ctl</span></span><br><span class="line">                <span class="keyword">if</span> ((<span class="keyword">int</span>)(checkSum &gt;&gt; AC_SHIFT) + (config &amp; SMASK) &gt; <span class="number">0</span>)</span><br><span class="line">                    <span class="comment">//2.1.1当前线程池还有活跃的worker(前面解释过).此时应返回false</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;            </span><br><span class="line">                <span class="keyword">if</span> ((ws = workQueues) == <span class="keyword">null</span> || (m = ws.length - <span class="number">1</span>) &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="comment">//2.1.2线程池已经没有队列,直接break进入后续流程.</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">//2.1.3从0开始遍历到ws的最后一个队列. </span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((w = ws[i]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> ((b = w.base) != w.top || w.scanState &gt;= <span class="number">0</span> ||</span><br><span class="line">                            w.currentSteal != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="comment">//只要发现任何一个队列非空,或队列未进入非活跃态(负)或队列仍有偷来的任务未完成.</span></span><br><span class="line">                            <span class="comment">//尝试释放栈顶worker并增加一个活跃数.并返回false,可以据此重新检查.</span></span><br><span class="line">                            tryRelease(c = ctl, ws[m &amp; (<span class="keyword">int</span>)c], AC_UNIT);</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">false</span>;   </span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//队列非null但是空队列,给校验和增加base.</span></span><br><span class="line">                        checkSum += b;</span><br><span class="line">                        <span class="keyword">if</span> ((i &amp; <span class="number">1</span>) == <span class="number">0</span>)</span><br><span class="line">                            <span class="comment">//发现非worker的队列,直接让外部禁用.</span></span><br><span class="line">                            w.qlock = -<span class="number">1</span>;    </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//2.1.4校验和一轮不变,break掉进入后置流程.即2.1.3中每一次取ws[i]都是null.</span></span><br><span class="line">                <span class="keyword">if</span> (oldSum == (oldSum = checkSum))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2.2.到这一步,已经保证了所有的关闭条件.若还没有给运行状态锁加上stop标记,</span></span><br><span class="line">        <span class="comment">//则给它加上标记.此时再有其他线程去尝试关闭,会进不来2这个分支.</span></span><br><span class="line">        <span class="keyword">if</span> ((runState &amp; STOP) == <span class="number">0</span>) &#123;</span><br><span class="line">            rs = lockRunState();              <span class="comment">// enter STOP phase</span></span><br><span class="line">            unlockRunState(rs, (rs &amp; ~RSLOCK) | STOP);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.经过前面的阶段,已完成预处理或now检查,可进入后置流程.</span></span><br><span class="line">    <span class="keyword">int</span> pass = <span class="number">0</span>;                             <span class="comment">// 3 passes to help terminate</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> oldSum = <span class="number">0L</span>;;) &#123;                <span class="comment">// or until done or stable</span></span><br><span class="line">        WorkQueue[] ws; WorkQueue w; ForkJoinWorkerThread wt; <span class="keyword">int</span> m;</span><br><span class="line">        <span class="keyword">long</span> checkSum = ctl;</span><br><span class="line">        <span class="comment">//3.1前面解释过这个状态表示当前无活跃worker.</span></span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">short</span>)(checkSum &gt;&gt;&gt; TC_SHIFT) + (config &amp; SMASK) &lt;= <span class="number">0</span> ||</span><br><span class="line">            (ws = workQueues) == <span class="keyword">null</span> || (m = ws.length - <span class="number">1</span>) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((runState &amp; TERMINATED) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//在确保无worker活跃的情况,直接将线程池置为TERMINATED.并唤醒所有等待终结的线程.</span></span><br><span class="line">                rs = lockRunState();       </span><br><span class="line">                unlockRunState(rs, (rs &amp; ~RSLOCK) | TERMINATED);</span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123; notifyAll(); &#125; </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//到此一定是终结态了,退出循环,结束方法返回true.</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.2内循环处理存在活跃worker的情况.从第一个队列开始遍历.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((w = ws[i]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//3.2.1对每个非null队列,增加一次校验和并禁用队列.</span></span><br><span class="line">                checkSum += w.base;</span><br><span class="line">                w.qlock = -<span class="number">1</span>;               </span><br><span class="line">                <span class="keyword">if</span> (pass &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//3.2.2内循环初次pass为0不能进入.</span></span><br><span class="line">                    <span class="comment">//pass大于0,取消队列上的所有任务,清理队列.</span></span><br><span class="line">                    w.cancelAll();  </span><br><span class="line">                    <span class="keyword">if</span> (pass &gt; <span class="number">1</span> &amp;&amp; (wt = w.owner) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">//3.2.3 pass大于1并且队列当前存在owner,扰动它.</span></span><br><span class="line">                        <span class="keyword">if</span> (!wt.isInterrupted()) &#123;</span><br><span class="line">                            <span class="keyword">try</span> &#123;           </span><br><span class="line">                                wt.interrupt();</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (Throwable ignore) &#123;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (w.scanState &lt; <span class="number">0</span>)</span><br><span class="line">                            <span class="comment">//3.2.4如果w代表的worker正在等待任务,让它取消停顿,进入结束流程.</span></span><br><span class="line">                            U.unpark(wt); </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.3如果校验和在几轮(最大为3或m的最大值)循环中改变过,说明并未进入稳态.将oldSum赋值为新的checkSum并重置pass为0.</span></span><br><span class="line">        <span class="keyword">if</span> (checkSum != oldSum) &#123;   </span><br><span class="line">            oldSum = checkSum;</span><br><span class="line">            pass = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.4pass从未被归置为0,稳态增加到大于3且大于m的情况,不能再帮助了,退出循环返回true.</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pass &gt; <span class="number">3</span> &amp;&amp; pass &gt; m) </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//3.5pass未到临界值,加1.</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (++pass &gt; <span class="number">1</span>) &#123; </span><br><span class="line">            <span class="keyword">long</span> c; <span class="keyword">int</span> j = <span class="number">0</span>, sp;</span><br><span class="line">            <span class="comment">//每一次进入3.5都会执行一次循环.如果ctl表示有worker正在scan,最多m次尝试release掉栈顶worker.</span></span><br><span class="line">            <span class="comment">//因为最多只有m个worker在栈中阻塞.因此3.4是合理的.</span></span><br><span class="line">            <span class="keyword">while</span> (j++ &lt;= m &amp;&amp; (sp = (<span class="keyword">int</span>)(c = ctl)) != <span class="number">0</span>)</span><br><span class="line">                tryRelease(c, ws[sp &amp; m], AC_UNIT);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="externalSubmit"><a href="#externalSubmit" class="headerlink" title="externalSubmit"></a>externalSubmit</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字面意思,从外面提交一任务入池.有前面的基础后,此方法很容易理解.</span></span><br><span class="line"><span class="comment">//此方法会处理一些不常见的case,比如辅助进行池的一些初始化过程(首次提交任务),</span></span><br><span class="line"><span class="comment">//如果发现是首次外部线程提交任务,在ws的目标索引位置为空或者出现竞态,它会尝试创建新的共享队列.</span></span><br><span class="line"><span class="comment">//参数task是目标任务,调用者必须保证非空.</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">externalSubmit</span><span class="params">(ForkJoinTask&lt;?&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r; </span><br><span class="line">    <span class="comment">//初始化一个用于定位的随机数r,前面曾简单介绍过它和localInit,许多公司的分布式id也是有它的成份.     </span></span><br><span class="line">    <span class="comment">//而这个随机数与线程相当于绑定在了一起,因此,可以使用它表示一个线程特有的东西.                             </span></span><br><span class="line">    <span class="keyword">if</span> ((r = ThreadLocalRandom.getProbe()) == <span class="number">0</span>) &#123;</span><br><span class="line">        ThreadLocalRandom.localInit();</span><br><span class="line">        r = ThreadLocalRandom.getProbe();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//循环尝试压入任务.</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        WorkQueue[] ws; WorkQueue q; <span class="keyword">int</span> rs, m, k;</span><br><span class="line">        <span class="keyword">boolean</span> move = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> ((rs = runState) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//1.发现此时线程池的运行状态已经进入SHUTDOWN,帮助终止线程池,并抛出拒绝异常.</span></span><br><span class="line">            tryTerminate(<span class="keyword">false</span>, <span class="keyword">false</span>);     <span class="comment">// help terminate</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2.发现线程池还未初始化,辅助初始化.STARTED为第三位.</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((rs &amp; STARTED) == <span class="number">0</span> ||     <span class="comment">// initialize</span></span><br><span class="line">                 ((ws = workQueues) == <span class="keyword">null</span> || (m = ws.length - <span class="number">1</span>) &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">int</span> ns = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//加锁.</span></span><br><span class="line">            rs = lockRunState();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//double check并尝试初台化stealCounter.它在awaitRunStateLock(尝试加锁)的时候会用来wait,</span></span><br><span class="line">                <span class="comment">//同时也处理了初始化阶段的竞态,还记得在awaitRunStateLock方法中发现stealCounter为null时的注释(初始化竞态)吗?</span></span><br><span class="line">                <span class="keyword">if</span> ((rs &amp; STARTED) == <span class="number">0</span>) &#123;</span><br><span class="line">                    U.compareAndSwapObject(<span class="keyword">this</span>, STEALCOUNTER, <span class="keyword">null</span>,</span><br><span class="line">                                           <span class="keyword">new</span> AtomicLong());</span><br><span class="line">                    <span class="comment">//创建workQueues数组,大小是2的幂.并保证至少有两个插槽(语义理解,如果是4个的话,两个share两个独有).</span></span><br><span class="line">                    <span class="keyword">int</span> p = config &amp; SMASK;</span><br><span class="line">                    <span class="comment">//下面这个比较好理解,总之,最小的情况下,n也会是(1+1)&lt;&lt;1=4,这样保证有两个位置给SHARE两个位置给工作线程.</span></span><br><span class="line">                    <span class="comment">//n的初始值取决于并行度.</span></span><br><span class="line">                    <span class="keyword">int</span> n = (p &gt; <span class="number">1</span>) ? p - <span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">                    n |= n &gt;&gt;&gt; <span class="number">1</span>; n |= n &gt;&gt;&gt; <span class="number">2</span>;  n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">                    n |= n &gt;&gt;&gt; <span class="number">8</span>; n |= n &gt;&gt;&gt; <span class="number">16</span>; n = (n + <span class="number">1</span>) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">                    workQueues = <span class="keyword">new</span> WorkQueue[n];</span><br><span class="line">                    <span class="comment">//新的运行状态.</span></span><br><span class="line">                    ns = STARTED;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//完成了辅助初始化,则解锁,并置runState加上STARTED标识.</span></span><br><span class="line">                unlockRunState(rs, (rs &amp; ~RSLOCK) | ns);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.某轮循环发现早已完成初始化,使用本线程的随机数r计算索引,发现ws[k]存在.说明已被别的线程在此初始化了一个队列.</span></span><br><span class="line">        <span class="comment">//注意索引k的值的计算,它与m进行与运算,保证不大于m,同时与SQMASK,即share-queue mask,它的值是0X007e,前面说过,</span></span><br><span class="line">        <span class="comment">//很明显,它是整数的2至7位,保证了共享队列只能放在ws的偶数位.</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((q = ws[k = r &amp; m &amp; SQMASK]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//3.1对队列加锁.</span></span><br><span class="line">            <span class="keyword">if</span> (q.qlock == <span class="number">0</span> &amp;&amp; U.compareAndSwapInt(q, QLOCK, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="comment">//取队列的数组和top</span></span><br><span class="line">                ForkJoinTask&lt;?&gt;[] a = q.array;</span><br><span class="line">                <span class="keyword">int</span> s = q.top;</span><br><span class="line">                <span class="comment">//初始化提交或者扩容.</span></span><br><span class="line">                <span class="keyword">boolean</span> submitted = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;                      <span class="comment">// locked version of push</span></span><br><span class="line">                    <span class="comment">//||左边的语句指符合添加元素的条件,右边表示如果不符合添加条件,则进行扩容.</span></span><br><span class="line">                    <span class="keyword">if</span> ((a != <span class="keyword">null</span> &amp;&amp; a.length &gt; s + <span class="number">1</span> - q.base) ||</span><br><span class="line">                        (a = q.growArray()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">//符合添加条件或扩容成功,取top对应的索引j.</span></span><br><span class="line">                        <span class="keyword">int</span> j = (((a.length - <span class="number">1</span>) &amp; s) &lt;&lt; ASHIFT) + ABASE;</span><br><span class="line">                        <span class="comment">//向top放入task.</span></span><br><span class="line">                        U.putOrderedObject(a, j, task);</span><br><span class="line">                        <span class="comment">//给top加1.</span></span><br><span class="line">                        U.putOrderedInt(q, QTOP, s + <span class="number">1</span>);</span><br><span class="line">                        <span class="comment">//标记为已提交.</span></span><br><span class="line">                        submitted = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">//释放qlock.</span></span><br><span class="line">                    U.compareAndSwapInt(q, QLOCK, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (submitted) &#123;</span><br><span class="line">                    <span class="comment">//如果提交成功,则尝试唤醒top或创建一个worker(如果太少).并返回.</span></span><br><span class="line">                    signalWork(ws, q);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//竞态失败,标记move</span></span><br><span class="line">            move = <span class="keyword">true</span>;                   <span class="comment">// move on failure</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.2计算出的位置没有queue,且runState未锁,创建一个新的.</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (((rs = runState) &amp; RSLOCK) == <span class="number">0</span>) &#123; <span class="comment">// create new queue</span></span><br><span class="line">            <span class="comment">//共享队列没有owner.</span></span><br><span class="line">            q = <span class="keyword">new</span> WorkQueue(<span class="keyword">this</span>, <span class="keyword">null</span>);</span><br><span class="line">            <span class="comment">//随机数就用线程的随机数r.</span></span><br><span class="line">            q.hint = r;</span><br><span class="line">            <span class="comment">//config的第32位置1表示共享队列</span></span><br><span class="line">            q.config = k | SHARED_QUEUE;</span><br><span class="line">            <span class="comment">//队列的scanState直接置为INACTIVE,很明显,参考前面的描述,</span></span><br><span class="line">            <span class="comment">//它没有工作线程,也不会参与活化和scan阻塞的过程,也不会将自己的scanState压入ctl后32位做栈元素.</span></span><br><span class="line">            q.scanState = INACTIVE;</span><br><span class="line">            <span class="comment">//加锁.</span></span><br><span class="line">            rs = lockRunState();         </span><br><span class="line">            <span class="keyword">if</span> (rs &gt; <span class="number">0</span> &amp;&amp;  (ws = workQueues) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                k &lt; ws.length &amp;&amp; ws[k] == <span class="keyword">null</span>)</span><br><span class="line">                <span class="comment">//仍旧符合添加条件,池未终结,将q赋给ws[k],否则的话,可能在下一轮循环进入1帮助终止,</span></span><br><span class="line">                <span class="comment">//也可能进入2用现成的队列内的任务数组添加元素到top.也可能在4处发现竞态,并最终导致5处重初始化r并重新循环找索引.</span></span><br><span class="line">                ws[k] = q;                 <span class="comment">// else terminated</span></span><br><span class="line">            unlockRunState(rs, rs &amp; ~RSLOCK);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4.标记繁忙.</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            move = <span class="keyword">true</span>;                   <span class="comment">// move if busy</span></span><br><span class="line">        <span class="comment">//5.本轮循环经历2的竞态失败或4的繁忙,重新初始化一个r供下轮循环使用.</span></span><br><span class="line">        <span class="keyword">if</span> (move)</span><br><span class="line">            r = ThreadLocalRandom.advanceProbe(r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="externalPush"><a href="#externalPush" class="headerlink" title="externalPush"></a>externalPush</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//尝试将给定的task添加到一个提交者当前的队列中,如果还需要额外的初始化操作等,使用上面的externalSubmit.</span></span><br><span class="line"><span class="comment">//我们知道,绝大多数的情况下,不需要初始化线程池的任务数组(整个线程池就一次),不需要初始化一个工作队列(每个ws一个位置只一次).</span></span><br><span class="line"><span class="comment">//因此它相当于先尝试用最简单直接的办法将任务压入队列,如果ws存在而队列需要初始化,或者池本身就没有完成初始化,再使用externalSubmit.</span></span><br><span class="line"><span class="comment">//参数task是要提交的任务,调用者本身必须保证它非空.</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">externalPush</span><span class="params">(ForkJoinTask&lt;?&gt; task)</span> </span>&#123;</span><br><span class="line">    WorkQueue[] ws; WorkQueue q; <span class="keyword">int</span> m;</span><br><span class="line">    <span class="comment">//老办法,初始的随机数.运行状态.</span></span><br><span class="line">    <span class="keyword">int</span> r = ThreadLocalRandom.getProbe();</span><br><span class="line">    <span class="keyword">int</span> rs = runState;</span><br><span class="line">    <span class="comment">//快速压入的代码分支,条件是队列数组ws已分配,非空,且根据r计算出来索引位取出的队列</span></span><br><span class="line">    <span class="comment">//存在且已完成初始化,线程池未进入SHUTDOWN,并且能够对队列进行加锁.</span></span><br><span class="line">    <span class="keyword">if</span> ((ws = workQueues) != <span class="keyword">null</span> &amp;&amp; (m = (ws.length - <span class="number">1</span>)) &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (q = ws[m &amp; r &amp; SQMASK]) != <span class="keyword">null</span> &amp;&amp; r != <span class="number">0</span> &amp;&amp; rs &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        U.compareAndSwapInt(q, QLOCK, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="comment">//快速入队.</span></span><br><span class="line">        ForkJoinTask&lt;?&gt;[] a; <span class="keyword">int</span> am, n, s;</span><br><span class="line">        <span class="keyword">if</span> ((a = q.array) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">            <span class="comment">//第二个条件是没有到扩容条件.</span></span><br><span class="line">            (am = a.length - <span class="number">1</span>) &gt; (n = (s = q.top) - q.base)) &#123;</span><br><span class="line">            <span class="comment">//计算出top的索引j,并将当前任务放入,将top加1</span></span><br><span class="line">            <span class="keyword">int</span> j = ((am &amp; s) &lt;&lt; ASHIFT) + ABASE;</span><br><span class="line">            U.putOrderedObject(a, j, task);</span><br><span class="line">            U.putOrderedInt(q, QTOP, s + <span class="number">1</span>);</span><br><span class="line">            U.putIntVolatile(q, QLOCK, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (n &lt;= <span class="number">1</span>)</span><br><span class="line">                <span class="comment">//发现原来的队列长度很短,有可能有worker正在scan,尝试唤醒一个worker或添加一个worker</span></span><br><span class="line">                signalWork(ws, q);</span><br><span class="line">            <span class="comment">//只要成功压入,返回.</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后解锁.</span></span><br><span class="line">        U.compareAndSwapInt(q, QLOCK, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//未能成功压栈,原因可能是线程池未初始化,工作队列未初始化,队列达到扩容阈值等.使用externalSubmit进行.</span></span><br><span class="line">    externalSubmit(task);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="tryExternalUnpush"><a href="#tryExternalUnpush" class="headerlink" title="tryExternalUnpush"></a>tryExternalUnpush</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//尝试弹出外部提交者的任务,找到队列,非空时加锁,最后调整top,每次进行都会检查失败,尽管很少失败.</span></span><br><span class="line"><span class="comment">//在前面ForkJoinTask和CountedCompleter等文章中曾引用过相关方法,此方法可以令等待任务的线程</span></span><br><span class="line"><span class="comment">//自行将任务出队并执行,而不是在池内线程还忙碌的情况下干等.但是该队列可能被其他外部线程放置了新的栈顶</span></span><br><span class="line"><span class="comment">//且看内部方法实现,当且仅当task是栈顶才有用.</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryExternalUnpush</span><span class="params">(ForkJoinTask&lt;?&gt; task)</span> </span>&#123;</span><br><span class="line">    WorkQueue[] ws; WorkQueue w; ForkJoinTask&lt;?&gt;[] a; <span class="keyword">int</span> m, s;</span><br><span class="line">    <span class="comment">//当前线程生成随机数r.</span></span><br><span class="line">    <span class="keyword">int</span> r = ThreadLocalRandom.getProbe();</span><br><span class="line">    <span class="keyword">if</span> ((ws = workQueues) != <span class="keyword">null</span> &amp;&amp; (m = ws.length - <span class="number">1</span>) &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (w = ws[m &amp; r &amp; SQMASK]) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">        (a = w.array) != <span class="keyword">null</span> &amp;&amp; (s = w.top) != w.base) &#123;</span><br><span class="line">        <span class="comment">//进入if的条件.线程池已初始化,ws存在,w存在且w非空队列.注意,仍旧取的偶数索引.</span></span><br><span class="line">        <span class="comment">//计算当前最顶部元素的索引j</span></span><br><span class="line">        <span class="keyword">long</span> j = (((a.length - <span class="number">1</span>) &amp; (s - <span class="number">1</span>)) &lt;&lt; ASHIFT) + ABASE;</span><br><span class="line">        <span class="comment">//尝试加锁qlock,加锁成功进入.</span></span><br><span class="line">        <span class="keyword">if</span> (U.compareAndSwapInt(w, QLOCK, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="comment">//进一步check队列w的top和w的array未变.</span></span><br><span class="line">            <span class="keyword">if</span> (w.top == s &amp;&amp; w.array == a &amp;&amp;</span><br><span class="line">                <span class="comment">//队列w的顶部元素就是参数task</span></span><br><span class="line">                U.getObject(a, j) == task &amp;&amp;</span><br><span class="line">                <span class="comment">//成功将task出队</span></span><br><span class="line">                U.compareAndSwapObject(a, j, task, <span class="keyword">null</span>)) &#123;</span><br><span class="line">                <span class="comment">//将top减1并释放锁,返回true.</span></span><br><span class="line">                U.putOrderedInt(w, QTOP, s - <span class="number">1</span>);</span><br><span class="line">                U.putOrderedInt(w, QLOCK, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//加锁前已有更改或者task本身就不是顶部任务,直接解锁.返回false.</span></span><br><span class="line">            U.compareAndSwapInt(w, QLOCK, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//默认返回fasle</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="externalHelpComplete"><a href="#externalHelpComplete" class="headerlink" title="externalHelpComplete"></a>externalHelpComplete</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//外部提交者helpComplete.介绍CountedCompleter提过此方法.</span></span><br><span class="line"><span class="comment">//当目标任务task是CountedCompleter类型时可以手动调用CountedCompleter::helpComplete,它会调用此处,ForkJoinTask::get也有调用.</span></span><br><span class="line"><span class="comment">//此方法可以令外部线程在等待task时帮助completer栈链上它的子孙任务完成,从而加速task的完成.</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">externalHelpComplete</span><span class="params">(CountedCompleter&lt;?&gt; task, <span class="keyword">int</span> maxTasks)</span> </span>&#123;</span><br><span class="line">    WorkQueue[] ws; <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> r = ThreadLocalRandom.getProbe();</span><br><span class="line">    <span class="keyword">return</span> ((ws = workQueues) == <span class="keyword">null</span> || (n = ws.length) == <span class="number">0</span>) ? <span class="number">0</span> :</span><br><span class="line">        <span class="comment">//ws未初始化,返回0,否则返回helpComplete的结果,取w的方式不变.</span></span><br><span class="line">        helpComplete(ws[(n - <span class="number">1</span>) &amp; r &amp; SQMASK], task, maxTasks);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="invoke-2"><a href="#invoke-2" class="headerlink" title="invoke"></a>invoke</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//invoke方法会尝试将task压入池,但也会立即join等待,压入池的方法即前面介绍过的externalPush,同样join方法也可能会</span></span><br><span class="line"><span class="comment">//导致当前线程自身完成了任务(池中工作线程忙碌而当前线程立即从队列中获取了该任务).</span></span><br><span class="line"><span class="comment">//执行结束后返回该任务的执行结果,当出现异常时,直接重新抛出.但也可能抛出拒绝异常(拒绝入队).</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">invoke</span><span class="params">(ForkJoinTask&lt;T&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    externalPush(task);</span><br><span class="line">    <span class="keyword">return</span> task.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="execute-1"><a href="#execute-1" class="headerlink" title="execute"></a>execute</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//安排给定任务的执行,异步进行.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(ForkJoinTask&lt;?&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    externalPush(task);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="execute-2"><a href="#execute-2" class="headerlink" title="execute"></a>execute</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//继承自AbstractExecutorService的方法列表</span></span><br><span class="line"><span class="comment">//execute方法,传入runnable,使用前面文章介绍的ForkJoinTask.RunnableExecuteAction适配器.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    ForkJoinTask&lt;?&gt; job;</span><br><span class="line">    <span class="keyword">if</span> (task <span class="keyword">instanceof</span> ForkJoinTask&lt;?&gt;) <span class="comment">// avoid re-wrap</span></span><br><span class="line">        job = (ForkJoinTask&lt;?&gt;) task;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        job = <span class="keyword">new</span> ForkJoinTask.RunnableExecuteAction(task);</span><br><span class="line">    externalPush(job);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="submit-1"><a href="#submit-1" class="headerlink" title="submit"></a>submit</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对callable的适配,前面也提过.</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">ForkJoinTask&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span> </span>&#123;</span><br><span class="line">    ForkJoinTask&lt;T&gt; job = <span class="keyword">new</span> ForkJoinTask.AdaptedCallable&lt;T&gt;(task);</span><br><span class="line">    externalPush(job);</span><br><span class="line">    <span class="keyword">return</span> job;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对task和result的适配.</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">ForkJoinTask&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span> </span>&#123;</span><br><span class="line">    ForkJoinTask&lt;T&gt; job = <span class="keyword">new</span> ForkJoinTask.AdaptedRunnable&lt;T&gt;(task, result);</span><br><span class="line">    externalPush(job);</span><br><span class="line">    <span class="keyword">return</span> job;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对submit一个Runnable的适配.避免重复包装.因为ForkJoinTask也可以实现runnable.</span></span><br><span class="line"><span class="comment">//典型的场景,先submit一个runnable,得到返回的job,再将job给submit进去.</span></span><br><span class="line"><span class="keyword">public</span> ForkJoinTask&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    ForkJoinTask&lt;?&gt; job;</span><br><span class="line">    <span class="keyword">if</span> (task <span class="keyword">instanceof</span> ForkJoinTask&lt;?&gt;) <span class="comment">// avoid re-wrap</span></span><br><span class="line">        job = (ForkJoinTask&lt;?&gt;) task;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        job = <span class="keyword">new</span> ForkJoinTask.AdaptedRunnableAction(task);</span><br><span class="line">    externalPush(job);</span><br><span class="line">    <span class="keyword">return</span> job;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="invokeAll-1"><a href="#invokeAll-1" class="headerlink" title="invokeAll"></a>invokeAll</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行所有任务.一样先入队再执行,可能出现本外部线程又偷回来执行的情况.</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks) &#123;</span><br><span class="line"></span><br><span class="line">    ArrayList&lt;Future&lt;T&gt;&gt; futures = <span class="keyword">new</span> ArrayList&lt;&gt;(tasks.size());</span><br><span class="line">    <span class="comment">//标记是否有异常.</span></span><br><span class="line">    <span class="keyword">boolean</span> done = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Callable&lt;T&gt; t : tasks) &#123;</span><br><span class="line">            ForkJoinTask&lt;T&gt; f = <span class="keyword">new</span> ForkJoinTask.AdaptedCallable&lt;T&gt;(t);</span><br><span class="line">            <span class="comment">//把所有任务包成适配器并加入futures列表.</span></span><br><span class="line">            futures.add(f);</span><br><span class="line">            <span class="comment">//压入池.</span></span><br><span class="line">            externalPush(f);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = futures.size(); i &lt; size; i++)</span><br><span class="line">            <span class="comment">//对每一个任务进行静默等待.</span></span><br><span class="line">            ((ForkJoinTask&lt;?&gt;)futures.get(i)).quietlyJoin();</span><br><span class="line">        <span class="comment">//上面的循环成功退出,置true返回.</span></span><br><span class="line">        done = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> futures;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!done)</span><br><span class="line">            <span class="comment">//发现是异常退出,则依次取消任务.</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = futures.size(); i &lt; size; i++)</span><br><span class="line">                futures.get(i).cancel(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="getRunningThreadCount"><a href="#getRunningThreadCount" class="headerlink" title="getRunningThreadCount"></a>getRunningThreadCount</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//估计当前线程池中正在运行(偷任务或运行任务)的线程,也就是未阻塞等待任务的线程.它会过度估计正在运行的线程数.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRunningThreadCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rc = <span class="number">0</span>;</span><br><span class="line">    WorkQueue[] ws; WorkQueue w;</span><br><span class="line">    <span class="keyword">if</span> ((ws = workQueues) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; ws.length; i += <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((w = ws[i]) != <span class="keyword">null</span> &amp;&amp; w.isApparentlyUnblocked())</span><br><span class="line">                <span class="comment">//只取ws奇数索引的worker,只要它isApparentlyUnblocked,即未进入waiting,blocking,wating_timed.</span></span><br><span class="line">                ++rc;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="getActiveThreadCount"><a href="#getActiveThreadCount" class="headerlink" title="getActiveThreadCount"></a>getActiveThreadCount</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//估计当前正在进行偷取或执行任务的线程(未阻塞等待任务),此方法也会过度估计.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getActiveThreadCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//很明显,根据前面我们研究了好久的逻辑,每release/signal的worker都会增加一个活跃数单元,</span></span><br><span class="line">    <span class="comment">//初始添加的worker也会增加一个活跃数单元和总数,显然只要有active的,那么r必然是一个溢出的正数.</span></span><br><span class="line">    <span class="keyword">int</span> r = (config &amp; SMASK) + (<span class="keyword">int</span>)(ctl &gt;&gt; AC_SHIFT);</span><br><span class="line">    <span class="keyword">return</span> (r &lt;= <span class="number">0</span>) ? <span class="number">0</span> : r; <span class="comment">//忽略负值.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="isQuiescent"><a href="#isQuiescent" class="headerlink" title="isQuiescent"></a>isQuiescent</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断线程池此刻是否已经进入静寂态,所谓的静寂态是指当前线程池中所有worker都已经阻塞在等待任务了,</span></span><br><span class="line"><span class="comment">//因为没有任何任务可供他们偷取或执行,也没有任何挂起的提交入池的任务.此方法相对保守,并不是所有线程都空闲的情况下</span></span><br><span class="line"><span class="comment">//立即会返回true,只有在他们减少了活跃数之后.(也就是保持空闲一段时间)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isQuiescent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//前面分析过,显然这个表达式不大于0即为不溢出的情况,回忆前面关于scan时,终止时等的降低活跃数.</span></span><br><span class="line">    <span class="keyword">return</span> (config &amp; SMASK) + (<span class="keyword">int</span>)(ctl &gt;&gt; AC_SHIFT) &lt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown"></a>shutdown</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此方法的执行参数,注意,now传false,enable传true.</span></span><br><span class="line"><span class="comment">//它的执行结果很简单(可以参考前面的tryTerminate).</span></span><br><span class="line"><span class="comment">//1.此前已经调用过tryTerminate并enable,或者调过shutdown,那会导致一次终结.</span></span><br><span class="line"><span class="comment">//2.初次调用,前面提交过的任务继续执行,但不会接受新的任务(因为runState首位置1了).</span></span><br><span class="line"><span class="comment">//3.commonPool不许关.</span></span><br><span class="line"><span class="comment">//4.已关的,调用了也没什么效果.但第二次调用时,已经在过程中的任务可能受此影响取消.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    checkPermission();</span><br><span class="line">    tryTerminate(<span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="shutdownNow"><a href="#shutdownNow" class="headerlink" title="shutdownNow"></a>shutdownNow</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//它会尝试立即取消和停止所有的任务,拒绝后续提交的任务.如果是common池则无效果.</span></span><br><span class="line"><span class="comment">//如果已经关闭,再调用无影响.正在被提交入池或正在执行的任务(在调用此方法执行时)可能会被取消,也可能不会(取决于时机,可能早于取消过程而完成执行).</span></span><br><span class="line"><span class="comment">//它会取消掉已存在的任务或未执行的任务.方法总会返回一个空的list.(与其他executor不同)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    checkPermission();</span><br><span class="line">    tryTerminate(<span class="keyword">true</span>, <span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="isTerminated"><a href="#isTerminated" class="headerlink" title="isTerminated"></a>isTerminated</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//很好理解,runState的31位是1,而仅有在shutdown方法中所有worker都已闲置或ws为空才会加上此位.显然此时所有任务都已完成.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isTerminated</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (runState &amp; TERMINATED) != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="isTerminating"><a href="#isTerminating" class="headerlink" title="isTerminating"></a>isTerminating</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isTerminating</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rs = runState;</span><br><span class="line">    <span class="keyword">return</span> (rs &amp; STOP) != <span class="number">0</span> &amp;&amp; (rs &amp; TERMINATED) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="isShutdown"><a href="#isShutdown" class="headerlink" title="isShutdown"></a>isShutdown</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//已SHUTDOWN,首位标记,显然只要shutdown方法调用并传enable为true一定会有此结果.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isShutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (runState &amp; SHUTDOWN) != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="awaitTermination"><a href="#awaitTermination" class="headerlink" title="awaitTermination"></a>awaitTermination</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//等待一个shutdown请求后所有的任务完成或者发生超时,或者当前线程被扰动(第一优先级).</span></span><br><span class="line"><span class="comment">//因为common池永远不会随程序调用shutdown而终止,因此使用commonPool调用此方法时,</span></span><br><span class="line"><span class="comment">//会直接等效于awaitQuiescence,而且永远会返回false.</span></span><br><span class="line"><span class="comment">//返回true,代表当前线程池终止了,false代表超时了.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">awaitTermination</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="comment">//1.当前线程中断,抛出异常.</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == common) &#123;</span><br><span class="line">        <span class="comment">//2.common池等效于awaitQuiescence并返回false.</span></span><br><span class="line">        awaitQuiescence(timeout, unit);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">    <span class="keyword">if</span> (isTerminated())</span><br><span class="line">        <span class="comment">//3.发现所有任务已完成返回true.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>)</span><br><span class="line">        <span class="comment">//4.已超时返回false.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//5.计算deadline并进入循环等待逻辑.</span></span><br><span class="line">    <span class="keyword">long</span> deadline = System.nanoTime() + nanos;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isTerminated())</span><br><span class="line">                <span class="comment">//5.1循环中发现已达到完成态,返回true.</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>)</span><br><span class="line">                <span class="comment">//5.2循环时发现超时,false.</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//5.3循环时减少时间并等待.</span></span><br><span class="line">            <span class="keyword">long</span> millis = TimeUnit.NANOSECONDS.toMillis(nanos);</span><br><span class="line">            wait(millis &gt; <span class="number">0L</span> ? millis : <span class="number">1L</span>);</span><br><span class="line">            nanos = deadline - System.nanoTime();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="awaitQuiescence"><a href="#awaitQuiescence" class="headerlink" title="awaitQuiescence"></a>awaitQuiescence</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//等待静寂.如果当前线程是池内线程,等效于ForkJoinTask::helpQuiesce方法,否则只是等待.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">awaitQuiescence</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">    ForkJoinWorkerThread wt;</span><br><span class="line">    Thread thread = Thread.currentThread();</span><br><span class="line">    <span class="keyword">if</span> ((thread <span class="keyword">instanceof</span> ForkJoinWorkerThread) &amp;&amp;</span><br><span class="line">        (wt = (ForkJoinWorkerThread)thread).pool == <span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">//1.线程是ForkJoinWorkerThread,帮助静寂.返回true.</span></span><br><span class="line">        helpQuiescePool(wt.workQueue);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.不是池内线程,准备计时,初始化若干变量.</span></span><br><span class="line">    <span class="keyword">long</span> startTime = System.nanoTime();</span><br><span class="line">    WorkQueue[] ws;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">0</span>, m;</span><br><span class="line">    <span class="keyword">boolean</span> found = <span class="keyword">true</span>;<span class="comment">//代表发现任务.</span></span><br><span class="line">    <span class="comment">//3.循环等待静寂或超时.</span></span><br><span class="line">    <span class="keyword">while</span> (!isQuiescent() &amp;&amp; (ws = workQueues) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">           (m = ws.length - <span class="number">1</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//3.1有趣的地方,只有本轮没找到任务才会进行超时判断.</span></span><br><span class="line">        <span class="keyword">if</span> (!found) &#123;</span><br><span class="line">            <span class="comment">//3.1.1判断超时了,返回false.</span></span><br><span class="line">            <span class="keyword">if</span> ((System.nanoTime() - startTime) &gt; nanos)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//3.1.2没超时,放弃执行权一段时间,不能阻塞在此.</span></span><br><span class="line">            Thread.yield(); <span class="comment">// cannot block</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//改为false.</span></span><br><span class="line">        found = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//4.内循环从数组中间开始,一直递减到0.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = (m + <span class="number">1</span>) &lt;&lt; <span class="number">2</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">            ForkJoinTask&lt;?&gt; t; WorkQueue q; <span class="keyword">int</span> b, k;</span><br><span class="line">            <span class="comment">//4.1取队列从0开始,只要取出了ws的非空队列成员,进入逻辑.</span></span><br><span class="line">            <span class="keyword">if</span> ((k = r++ &amp; m) &lt;= m &amp;&amp; k &gt;= <span class="number">0</span> &amp;&amp; (q = ws[k]) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                (b = q.base) - q.top &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//4.2 found标记true</span></span><br><span class="line">                found = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">if</span> ((t = q.pollAt(b)) != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="comment">//4.3尝试从底部取出任务并执行.相当于帮助静寂</span></span><br><span class="line">                    t.doExec();</span><br><span class="line">                <span class="comment">//进入4.1,即break掉内循环,可能凑巧,执行完一个任务就静寂了.</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//能从while循环break出来或者循环条件为假退出,说明达到静寂.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ManagedBlocker"><a href="#ManagedBlocker" class="headerlink" title="ManagedBlocker"></a>ManagedBlocker</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MangedBlocker接口.它是一个为运行在ForkJoinPool中的任务维护并行度的接口</span></span><br><span class="line"><span class="comment">//我们可以通过拓展它来实现在ForkJoinPool中运行的任务的并行度管理.它只有两个方法.</span></span><br><span class="line"><span class="comment">//isReleasable方法会在没有必要阻塞时一定返回true,block方法会在必要时阻塞当前线程,</span></span><br><span class="line"><span class="comment">//它内部可以调用isReleasable.而这个调度需要使用ForkJoinPool#managedBlock(ManagedBlocker)</span></span><br><span class="line"><span class="comment">//它会尝试去调度,避免长期的阻塞,它允许更灵活的内部处理.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">interface</span> <span class="title">ManagedBlocker</span> </span>&#123;</span><br><span class="line">    <span class="comment">//可能会阻塞一个线程,比如等待监视器,当返回true时表示认为当前没有必要继续block.</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">block</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回true表示认为没有必要block.</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isReleasable</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//运行给定的阻塞任务,当在ForkJoinPool运行ForkJoinTask时,此方法在当前线程阻塞的情况下(调用blocker.block),</span></span><br><span class="line"><span class="comment">//认为需要保持必要并行度时安排一个备用线程,方法内重复调用blocker.isReleasable和blocker.block.且前者必在后者前,</span></span><br><span class="line"><span class="comment">//它返回false时才会有后者.如果没运行在ForkJoinPool内,那么方法的行为等效于下面这段代码:</span></span><br><span class="line"><span class="comment">//while(!blocker.isReleasable())&#123;if(blocker.block() break;&#125;</span></span><br><span class="line"><span class="comment">//参数blocker是上面的接口的实现类,在前面的文章CompletableFuture和响应式编程中曾见到一个实现类.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">managedBlock</span><span class="params">(ManagedBlocker blocker)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    ForkJoinPool p;</span><br><span class="line">    ForkJoinWorkerThread wt;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">//1.当前是ForkJoinPool池内线程时的逻辑.</span></span><br><span class="line">    <span class="keyword">if</span> ((t <span class="keyword">instanceof</span> ForkJoinWorkerThread) &amp;&amp;</span><br><span class="line">        (p = (wt = (ForkJoinWorkerThread)t).pool) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        WorkQueue w = wt.workQueue;</span><br><span class="line">        <span class="comment">//1.1取出工作队列,进行循环,blocker.isReleasable判断当前并非没有必要加锁时进入.</span></span><br><span class="line">        <span class="keyword">while</span> (!blocker.isReleasable()) &#123;</span><br><span class="line">            <span class="comment">//1.2要加锁,尝试补偿,它会在此时唤醒一个空闲的线程或创建一个新的线程来补偿当前线程的阻塞.</span></span><br><span class="line">            <span class="keyword">if</span> (p.tryCompensate(w)) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//1.3当前线程阻塞等待.</span></span><br><span class="line">                    <span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (!blocker.isReleasable() &amp;&amp;</span><br><span class="line">                                 !blocker.block());</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    U.getAndAddLong(p, CTL, AC_UNIT);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.非池内线程的逻辑.同上面的阻塞逻辑.</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (!blocker.isReleasable() &amp;&amp;</span><br><span class="line">                     !blocker.block());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/image/hexo/image-20200719101018337.png&quot; alt=&quot;image-20200719101018337&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/image/hexo/image-20200719102418252.pn
      
    
    </summary>
    
    
      <category term="JAVA" scheme="https://blog.huhdcc.top/categories/JAVA/"/>
    
      <category term="多线程" scheme="https://blog.huhdcc.top/categories/JAVA/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="JAVA" scheme="https://blog.huhdcc.top/tags/JAVA/"/>
    
      <category term="多线程" scheme="https://blog.huhdcc.top/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="源码深入" scheme="https://blog.huhdcc.top/tags/%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>多线程高阶-51-StampedLock详解</title>
    <link href="https://blog.huhdcc.top/2020/07/18/50320/hub/"/>
    <id>https://blog.huhdcc.top/2020/07/18/50320/hub/</id>
    <published>2020-07-18T05:16:43.000Z</published>
    <updated>2020-07-18T13:16:24.009Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/image/hexo/image-20200718131809394.png" alt="image-20200718131809394"></p><h2 id="StampedLock相关API"><a href="#StampedLock相关API" class="headerlink" title="StampedLock相关API"></a>StampedLock相关API</h2><p>&emsp;&emsp;<strong>StampedLock</strong>是在JDK8新增的，主要针对<code>读写锁</code>进行了一些增强，并且支持读写锁之间的转换，更细粒度的控制并发，它的内部也不是基于<code>AQS</code>实现的。支持三种模式：<code>写模式</code>、<code>读模式</code>、<code>乐观读模式</code>（适合读多写少的业务场景）。</p><h3 id="类声明"><a href="#类声明" class="headerlink" title="类声明"></a>类声明</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StampedLock</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造函数</span></span><br><span class="line">StampedLock stampedLock = <span class="keyword">new</span> StampedLock();</span><br></pre></td></tr></table></figure><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h4 id="writeLock"><a href="#writeLock" class="headerlink" title="writeLock"></a>writeLock</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//writeLock</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1.获取写入锁</span></span><br><span class="line"><span class="comment"> * 2.获取失败则回阻塞当前线程、直到成功获取锁</span></span><br><span class="line"><span class="comment"> * 3.返回值：可以用来解锁或转换模式的戳记</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">stampedLock.writeLock();</span><br></pre></td></tr></table></figure><h4 id="tryWriteLock"><a href="#tryWriteLock" class="headerlink" title="tryWriteLock"></a>tryWriteLock</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//tryWriteLock</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1.没有锁存在的情况下获取写入锁</span></span><br><span class="line"><span class="comment"> * 2.否则返回0</span></span><br><span class="line"><span class="comment"> * 3.可以设置等待超时时间</span></span><br><span class="line"><span class="comment"> * 4.返回值：可以用来解锁或转换模式的戳记</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">stampedLock.tryWriteLock();</span><br><span class="line">stampedLock.tryWriteLock(<span class="number">1</span>, TimeUnit.MILLISECONDS);</span><br></pre></td></tr></table></figure><h4 id="writeLockInterruptibly"><a href="#writeLockInterruptibly" class="headerlink" title="writeLockInterruptibly"></a>writeLockInterruptibly</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//writeLockInterruptibly</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1.获取写锁</span></span><br><span class="line"><span class="comment"> * 2.成功返回状态值，失败返回0，或抛出InterruptedException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">stampedLock.writeLockInterruptibly();</span><br></pre></td></tr></table></figure><h4 id="readLock"><a href="#readLock" class="headerlink" title="readLock"></a>readLock</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//readLock</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1.获取读取锁（悲观、非独占）</span></span><br><span class="line"><span class="comment"> * 2.获取不到则会陷入阻塞直到成功获取到读取锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">stampedLock.readLock();</span><br></pre></td></tr></table></figure><h4 id="tryReadLock"><a href="#tryReadLock" class="headerlink" title="tryReadLock"></a>tryReadLock</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//tryReadLock</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1.立即获得读取锁</span></span><br><span class="line"><span class="comment"> * 2.否则返回0</span></span><br><span class="line"><span class="comment"> * 3.可以设置等待超时时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">stampedLock.tryReadLock();</span><br><span class="line">stampedLock.tryReadLock(<span class="number">1</span>, TimeUnit.MILLISECONDS);</span><br></pre></td></tr></table></figure><h4 id="tryOptimisticRead"><a href="#tryOptimisticRead" class="headerlink" title="tryOptimisticRead"></a>tryOptimisticRead</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//tryOptimisticRead</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1.获取乐观读取锁</span></span><br><span class="line"><span class="comment"> * 2.返回邮戳stamp</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">stampedLock.tryOptimisticRead();</span><br></pre></td></tr></table></figure><h4 id="validate"><a href="#validate" class="headerlink" title="validate"></a>validate</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//validate</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1.验证邮戳（tryOptimisticRead方法调用前后）有没有写锁占用锁资源</span></span><br><span class="line"><span class="comment"> * 2.占用：返回false</span></span><br><span class="line"><span class="comment"> * 3.未占用：返回true</span></span><br><span class="line"><span class="comment"> * 4.stamp == 0:返回false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">stampedLock.validate(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><h4 id="unlockWrite"><a href="#unlockWrite" class="headerlink" title="unlockWrite"></a>unlockWrite</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//unlockWrite</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1.state和stamp匹配释放写入锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">stampedLock.unlockWrite(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><h4 id="unlockRead"><a href="#unlockRead" class="headerlink" title="unlockRead"></a>unlockRead</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//unlockRead</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1.state和stamp匹配释放读取锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">stampedLock.unlockRead(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><h4 id="unlock"><a href="#unlock" class="headerlink" title="unlock"></a>unlock</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//unlock</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1.state匹配stamp时,释放一个读锁或写锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">stampedLock.unlock(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><h4 id="tryConvertToWriteLock"><a href="#tryConvertToWriteLock" class="headerlink" title="tryConvertToWriteLock"></a>tryConvertToWriteLock</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//tryConvertToWriteLock</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1.进行state匹配stamp</span></span><br><span class="line"><span class="comment"> * 2.stamp如果已经持有写锁，直接返回</span></span><br><span class="line"><span class="comment"> * 3.读模式，但是没有更多的读取者，并返回一个写锁stamp</span></span><br><span class="line"><span class="comment"> * 4.有一个乐观读锁，只在即时可用的前提下返回一个写锁stamp</span></span><br><span class="line"><span class="comment"> * 5.其他情况都返回0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">stampedLock.tryConvertToWriteLock(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><h4 id="tryConvertToReadLock"><a href="#tryConvertToReadLock" class="headerlink" title="tryConvertToReadLock"></a>tryConvertToReadLock</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//tryConvertToReadLock</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1.进行state匹配stamp</span></span><br><span class="line"><span class="comment"> * 2.stamp如果持有写锁，释放写锁，并持有读锁</span></span><br><span class="line"><span class="comment"> * 3.stamp如果表示持有读锁 ，返回该读锁</span></span><br><span class="line"><span class="comment"> * 4.有一个乐观读锁，只在即时可用的前提下返回一个读锁stamp</span></span><br><span class="line"><span class="comment"> * 5.其他情况都返回0，表示失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">stampedLock.tryConvertToReadLock(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><h4 id="tryConvertToOptimisticRead"><a href="#tryConvertToOptimisticRead" class="headerlink" title="tryConvertToOptimisticRead"></a>tryConvertToOptimisticRead</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//tryConvertToOptimisticRead</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1.将其他锁转换为乐观锁</span></span><br><span class="line"><span class="comment"> * 2.stamp如果持有读或写锁，则直接释放读写锁</span></span><br><span class="line"><span class="comment"> * 3.stamp如果持有乐观锁，若乐观锁stamp有效，则返回观察者stamp</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">stampedLock.tryConvertToOptimisticRead(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><h4 id="tryUnlockWrite"><a href="#tryUnlockWrite" class="headerlink" title="tryUnlockWrite"></a>tryUnlockWrite</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//tryUnlockWrite</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1.如果持有写锁，释放写锁</span></span><br><span class="line"><span class="comment"> * 2.可以用于发生错误后的恢复</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">stampedLock.tryUnlockWrite();</span><br></pre></td></tr></table></figure><h4 id="tryUnlockRead"><a href="#tryUnlockRead" class="headerlink" title="tryUnlockRead"></a>tryUnlockRead</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//tryUnlockRead</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1.如果持有读锁，释放读锁</span></span><br><span class="line"><span class="comment"> * 2.可以用于发生错误后的恢复</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">stampedLock.tryUnlockRead();</span><br></pre></td></tr></table></figure><h4 id="isWriteLocked"><a href="#isWriteLocked" class="headerlink" title="isWriteLocked"></a>isWriteLocked</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//isWriteLocked</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1.持有写锁返回true</span></span><br><span class="line"><span class="comment"> * 2.不持有返回false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">System.out.println(stampedLock.isWriteLocked());</span><br></pre></td></tr></table></figure><h4 id="isReadLocked"><a href="#isReadLocked" class="headerlink" title="isReadLocked"></a>isReadLocked</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//isReadLocked</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1.持有读锁返回true</span></span><br><span class="line"><span class="comment"> * 2.不持有返回false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">System.out.println(stampedLock.isReadLocked());</span><br></pre></td></tr></table></figure><h4 id="getReadLockCount"><a href="#getReadLockCount" class="headerlink" title="getReadLockCount"></a>getReadLockCount</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//getReadLockCount</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1.返回持有读锁的线程数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">System.out.println(stampedLock.getReadLockCount());</span><br></pre></td></tr></table></figure><h4 id="asWriteLock"><a href="#asWriteLock" class="headerlink" title="asWriteLock"></a>asWriteLock</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//asWriteLock</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1.返回一个WriteLock视图</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">stampedLock.asWriteLock();</span><br></pre></td></tr></table></figure><h4 id="asReadLock"><a href="#asReadLock" class="headerlink" title="asReadLock"></a>asReadLock</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//asReadLock</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1.返回一个ReadLock视图</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">stampedLock.asReadLock();</span><br></pre></td></tr></table></figure><h4 id="asReadWriteLock"><a href="#asReadWriteLock" class="headerlink" title="asReadWriteLock"></a>asReadWriteLock</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//asReadWriteLock</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1.返回一个ReadWriteLock视图</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">stampedLock.asReadWriteLock();</span><br></pre></td></tr></table></figure><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><h3 id="悲观读取"><a href="#悲观读取" class="headerlink" title="悲观读取"></a>悲观读取</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StampedLockTest1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> StampedLock stampedLock = <span class="keyword">new</span> StampedLock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> List&lt;Long&gt; DATA = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ExecutorService executor = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        Runnable read = () -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (; ; ) &#123;read();&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Runnable write = () -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (; ; ) &#123;write();&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        executor.submit(read);</span><br><span class="line">        executor.submit(read);</span><br><span class="line">        executor.submit(read);</span><br><span class="line">        executor.submit(read);</span><br><span class="line">        executor.submit(read);</span><br><span class="line">        executor.submit(read);</span><br><span class="line">        executor.submit(read);</span><br><span class="line">        executor.submit(read);</span><br><span class="line">        executor.submit(read);</span><br><span class="line"></span><br><span class="line">        executor.submit(write);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> stamped = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            stamped = stampedLock.writeLock();</span><br><span class="line">            <span class="keyword">long</span> value = System.currentTimeMillis();</span><br><span class="line">            System.out.println(<span class="string">"The Thread:"</span> + Thread.currentThread().getName() + <span class="string">" write value:"</span> + value);</span><br><span class="line">            DATA.add(value);</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            stampedLock.unlockWrite(stamped);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> stamped = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            stamped = stampedLock.readLock();</span><br><span class="line">            Optional.of(DATA.stream()</span><br><span class="line">                    .map(String::valueOf)</span><br><span class="line">                    .collect(Collectors.joining(<span class="string">"#"</span>, <span class="string">"R-"</span>, <span class="string">""</span>)))</span><br><span class="line">                    .ifPresent(System.out::println);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            stampedLock.unlockRead(stamped);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="乐观读取"><a href="#乐观读取" class="headerlink" title="乐观读取"></a>乐观读取</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StampedLockTest2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> StampedLock stampedLock = <span class="keyword">new</span> StampedLock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> List&lt;Long&gt; DATA = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Runnable read = () -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">                read();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Runnable write = () -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">                write();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        IntStream.range(<span class="number">0</span>, <span class="number">1</span>).boxed().forEach(i -&gt; <span class="keyword">new</span> Thread(write).start());</span><br><span class="line">        IntStream.range(<span class="number">0</span>, <span class="number">200</span>).boxed().forEach(i -&gt; <span class="keyword">new</span> Thread(read).start());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> stamped = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            stamped = stampedLock.writeLock();</span><br><span class="line">            <span class="keyword">long</span> value = System.currentTimeMillis();</span><br><span class="line">            System.out.println(<span class="string">"The Thread:"</span> + Thread.currentThread().getName() + <span class="string">" write value:"</span> + value);</span><br><span class="line">            DATA.add(value);</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            stampedLock.unlockWrite(stamped);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> stamp = stampedLock.tryOptimisticRead();</span><br><span class="line">        <span class="keyword">if</span> (stampedLock.validate(stamp)) &#123;</span><br><span class="line">            <span class="keyword">long</span> stamped = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                stamped = stampedLock.readLock();</span><br><span class="line">                System.out.println(<span class="string">"stamped："</span> + stamped);</span><br><span class="line">                Optional.of(DATA.stream()</span><br><span class="line">                        .map(String::valueOf)</span><br><span class="line">                        .collect(Collectors.joining(<span class="string">"#"</span>, <span class="string">"R-"</span>, <span class="string">""</span>)))</span><br><span class="line">                        .ifPresent(System.out::println);</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                stampedLock.unlock(stamped);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="部分源码解析"><a href="#部分源码解析" class="headerlink" title="部分源码解析"></a>部分源码解析</h2><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取服务器CPU核数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NCPU = Runtime.getRuntime().availableProcessors();</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程入队列前自旋次数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SPINS = (NCPU &gt; <span class="number">1</span>) ? <span class="number">1</span> &lt;&lt; <span class="number">6</span> : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//队列头结点自旋获取锁最大失败次数后再次进入队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HEAD_SPINS = (NCPU &gt; <span class="number">1</span>) ? <span class="number">1</span> &lt;&lt; <span class="number">10</span> : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Maximum number of retries before re-blocking */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_HEAD_SPINS = (NCPU &gt; <span class="number">1</span>) ? <span class="number">1</span> &lt;&lt; <span class="number">16</span> : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** The period for yielding when waiting for overflow spinlock */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OVERFLOW_YIELD_RATE = <span class="number">7</span>; <span class="comment">// must be power 2 - 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** The number of bits to use for reader count before overflowing */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LG_READERS = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Values for lock state and stamp operations</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> RUNIT = <span class="number">1L</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> WBIT  = <span class="number">1L</span> &lt;&lt; LG_READERS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> RBITS = WBIT - <span class="number">1L</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> RFULL = RBITS - <span class="number">1L</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> ABITS = RBITS | WBIT;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> SBITS = ~RBITS; <span class="comment">// note overlap with ABITS</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//锁state初始值，第9位为1，避免算术时和0冲突</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> ORIGIN = WBIT &lt;&lt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Special value from cancelled acquire methods so caller can throw IE</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> INTERRUPTED = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Values for node status; order matters</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WAITING   = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Modes for nodes (int not boolean to allow arithmetic)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RMODE = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WMODE = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//标识状态的含义</span></span><br><span class="line">RUNIT: == <span class="number">1</span>，更新读锁状态会用到的常量，<span class="string">"next = s + RUNIT"</span>一个新线程获取获取到了读锁那么state将增加<span class="number">1</span>.</span><br><span class="line"></span><br><span class="line">ABITS:== <span class="number">255</span>，计算写锁状态时会用到的常量，位运算<span class="string">"((s = state) &amp; ABITS)"</span>来取state的低<span class="number">8</span>位。</span><br><span class="line"></span><br><span class="line">WBIT:== <span class="number">123</span>，更新写锁状态会用到的常量，<span class="string">"next = s + WBIT"</span>一个线程获取到写锁就将state属性加<span class="number">128</span>。</span><br><span class="line"></span><br><span class="line">RBITS:== <span class="number">127</span>，计算读锁状态会到的常量，<span class="string">"s &amp; RBITS"</span>用来取state的低<span class="number">7</span>位。</span><br><span class="line"></span><br><span class="line">RFULL:== <span class="number">126</span>，获取到读锁的最大线程数，<span class="string">"(readers = s &amp; RBITS) &gt;= RFULL"</span>。</span><br><span class="line"></span><br><span class="line">SBITS:计算写锁变化量会用到的常量，<span class="string">"(s &amp; SBITS)"</span>将s的低<span class="number">7</span>位全部置<span class="number">0</span>，只关注s的高<span class="number">25</span>位。</span><br><span class="line"></span><br><span class="line">ORIGIN:state的初始值，二进制形式只有第<span class="number">9</span>位为<span class="number">1</span>，其他位全为<span class="number">0</span>。主要是不让statet等于<span class="number">0</span>，只有尝试获取锁失败时，state才能为<span class="number">0</span>.</span><br><span class="line">state:<span class="number">1</span>表示持有写锁，<span class="number">0</span>表示没持有写锁</span><br></pre></td></tr></table></figure><h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//等待队列头节点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> WNode whead; </span><br><span class="line"><span class="comment">//等待队列尾节点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> WNode wtail; </span><br><span class="line"></span><br><span class="line"><span class="comment">//读锁视图</span></span><br><span class="line"><span class="keyword">transient</span> ReadLockView readLockView; </span><br><span class="line"><span class="comment">//写锁视图</span></span><br><span class="line"><span class="keyword">transient</span> WriteLockView writeLockView;</span><br><span class="line"><span class="comment">//读写锁视图</span></span><br><span class="line"><span class="keyword">transient</span> ReadWriteLockView readWriteLockView;</span><br><span class="line"></span><br><span class="line"><span class="comment">//锁状态</span></span><br><span class="line"><span class="comment">//高24位存储版本号、低7位存储读锁被获取的次数、第8位存储写锁被获取的次数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">long</span> state; </span><br><span class="line"><span class="comment">//读锁线程数超过RFULL时，额外记录超出的的线程数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> readerOverflow;</span><br></pre></td></tr></table></figure><h3 id="writeLock-1"><a href="#writeLock-1" class="headerlink" title="writeLock"></a>writeLock</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取写入锁、失败会陷入阻塞、直到获取锁成功</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">writeLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> s, next;</span><br><span class="line">    <span class="comment">// ABITS = 255 = 1111 1111</span></span><br><span class="line">    <span class="comment">// WBITS = 128 = 1000 0000</span></span><br><span class="line">    <span class="comment">//如果stat和ABITS==0，进行cas更新state=state+WBIT</span></span><br><span class="line">    <span class="comment">//更新成功则返回更新后的值</span></span><br><span class="line">    <span class="comment">//更新失败进入acquireWrite</span></span><br><span class="line">    <span class="keyword">return</span> ((((s = state) &amp; ABITS) == <span class="number">0L</span> &amp;&amp;</span><br><span class="line">             U.compareAndSwapLong(<span class="keyword">this</span>, STATE, s, next = s + WBIT)) ?</span><br><span class="line">            next : acquireWrite(<span class="keyword">false</span>, <span class="number">0L</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">acquireWrite</span><span class="params">(<span class="keyword">boolean</span> interruptible, <span class="keyword">long</span> deadline)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//node新增节点、p尾节点</span></span><br><span class="line">    WNode node = <span class="keyword">null</span>, p;</span><br><span class="line">    <span class="comment">//开始进行第一次自旋</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> spins = -<span class="number">1</span>;;) </span><br><span class="line">        <span class="keyword">long</span> m, s, ns;</span><br><span class="line">    <span class="comment">//尝试获取锁</span></span><br><span class="line">        <span class="keyword">if</span> ((m = (s = state) &amp; ABITS) == <span class="number">0L</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapLong(<span class="keyword">this</span>, STATE, s, ns = s + WBIT))</span><br><span class="line">                <span class="keyword">return</span> ns;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (spins &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//1.自旋次数&lt;0 计算自旋次数</span></span><br><span class="line">            <span class="comment">//2.有写锁并且队列中没有元素，那么代表快轮到自己了，接着自旋</span></span><br><span class="line">            <span class="comment">//3.自旋完了还没轮到则入队操作</span></span><br><span class="line">            <span class="comment">//4.自旋次数尾SPINS常量、否则为0</span></span><br><span class="line">            spins = (m == WBIT &amp;&amp; wtail == whead) ? SPINS : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (spins &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//若是自旋次数&gt;0，当前自旋次数-1</span></span><br><span class="line">            <span class="keyword">if</span> (LockSupport.nextSecondarySeed() &gt;= <span class="number">0</span>)</span><br><span class="line">                --spins;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((p = wtail) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果队列未进行初始化操作</span></span><br><span class="line">            <span class="comment">//新建一个Node节点</span></span><br><span class="line">            WNode hd = <span class="keyword">new</span> WNode(WMODE, <span class="keyword">null</span>);</span><br><span class="line">            <span class="comment">//初始化头部和尾部节点</span></span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapObject(<span class="keyword">this</span>, WHEAD, <span class="keyword">null</span>, hd))</span><br><span class="line">                wtail = hd;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">//如果新增节点没有初始化、构建一个新增节点并且它的前置节点是尾节点</span></span><br><span class="line">            node = <span class="keyword">new</span> WNode(WMODE, p);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (node.prev != p)</span><br><span class="line">            <span class="comment">//如果尾节点发生变化、则需要更新新增节点的前置节点尾新的尾节点</span></span><br><span class="line">            node.prev = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapObject(<span class="keyword">this</span>, WTAIL, p, node)) &#123;</span><br><span class="line">            <span class="comment">//CAS尝试更新新的尾节点、并且退出循环</span></span><br><span class="line">            p.next = node;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//进入第二次自旋操作</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> spins = -<span class="number">1</span>;;) &#123;</span><br><span class="line">        <span class="comment">//h:头部节点</span></span><br><span class="line">        <span class="comment">//np:新增节点的前置节点</span></span><br><span class="line">        <span class="comment">//pp:前前置节点</span></span><br><span class="line">        <span class="comment">//ps:前置节点的状态</span></span><br><span class="line">        WNode h, np, pp; <span class="keyword">int</span> ps;</span><br><span class="line">        <span class="comment">//如果头部节点 == 前置节点（快轮到自己了）</span></span><br><span class="line">        <span class="keyword">if</span> ((h = whead) == p) &#123;</span><br><span class="line">            <span class="keyword">if</span> (spins &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="comment">//自旋次数&lt;0，初始化自旋次数</span></span><br><span class="line">                spins = HEAD_SPINS;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (spins &lt; MAX_HEAD_SPINS)</span><br><span class="line">                <span class="comment">//增加自旋次数（自旋次数&lt;最大自旋次数）</span></span><br><span class="line">                spins &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//开始第三次自旋、不断尝试获取锁</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = spins;;) &#123;</span><br><span class="line">                <span class="keyword">long</span> s, ns;</span><br><span class="line">                <span class="keyword">if</span> (((s = state) &amp; ABITS) == <span class="number">0L</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (U.compareAndSwapLong(<span class="keyword">this</span>, STATE, s,</span><br><span class="line">                                             ns = s + WBIT)) &#123;</span><br><span class="line">                        <span class="comment">//获取锁成功，设置node为新头部节点</span></span><br><span class="line">                        whead = node;</span><br><span class="line">                        <span class="comment">//清除前置节点gc</span></span><br><span class="line">                        node.prev = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">return</span> ns;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//随机立减自旋次数、如果自旋次数减为0跳出循环再次重试</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (LockSupport.nextSecondarySeed() &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">                         --k &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (h != <span class="keyword">null</span>) &#123; </span><br><span class="line">            <span class="comment">//一般情况很少会触发该逻辑</span></span><br><span class="line">            <span class="comment">//主要用于协助唤醒读节点</span></span><br><span class="line">            WNode c; Thread w;</span><br><span class="line">            <span class="comment">//如果头节点的cowait不为空、则唤醒里面的所有节点</span></span><br><span class="line">            <span class="keyword">while</span> ((c = h.cowait) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapObject(h, WCOWAIT, c, c.cowait) &amp;&amp;</span><br><span class="line">                    (w = c.thread) != <span class="keyword">null</span>)</span><br><span class="line">                    U.unpark(w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果头部节点没有发生变化</span></span><br><span class="line">        <span class="keyword">if</span> (whead == h) &#123;</span><br><span class="line">            <span class="comment">//尾部节点发生变化、进行更新操作</span></span><br><span class="line">            <span class="keyword">if</span> ((np = node.prev) != p) &#123;</span><br><span class="line">                <span class="keyword">if</span> (np != <span class="keyword">null</span>)</span><br><span class="line">                    (p = np).next = node;   <span class="comment">// stale</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((ps = p.status) == <span class="number">0</span>)</span><br><span class="line">                <span class="comment">//如果尾部节点的状态为0，更新为WAITING</span></span><br><span class="line">                U.compareAndSwapInt(p, WSTATUS, <span class="number">0</span>, WAITING);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ps == CANCELLED) &#123;</span><br><span class="line">                <span class="comment">//如果尾部节点的状态为CANCELLED，则从链表中删除</span></span><br><span class="line">                <span class="keyword">if</span> ((pp = p.prev) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    node.prev = pp;</span><br><span class="line">                    pp.next = node;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//超时时间处理</span></span><br><span class="line">                <span class="keyword">long</span> time; </span><br><span class="line">                <span class="keyword">if</span> (deadline == <span class="number">0L</span>)</span><br><span class="line">                    time = <span class="number">0L</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((time = deadline - System.nanoTime()) &lt;= <span class="number">0L</span>)</span><br><span class="line">                    <span class="comment">//超时、剔除当前节点</span></span><br><span class="line">                    <span class="keyword">return</span> cancelWaiter(node, node, <span class="keyword">false</span>);</span><br><span class="line">                <span class="comment">//获取当前线程</span></span><br><span class="line">                Thread wt = Thread.currentThread();</span><br><span class="line">                U.putObject(wt, PARKBLOCKER, <span class="keyword">this</span>);</span><br><span class="line">                <span class="comment">//将node的线程指向了当前的线程</span></span><br><span class="line">                node.thread = wt;</span><br><span class="line">                <span class="keyword">if</span> (p.status &lt; <span class="number">0</span> &amp;&amp; (p != h || (state &amp; ABITS) != <span class="number">0L</span>) &amp;&amp;</span><br><span class="line">                    whead == h &amp;&amp; node.prev == p)</span><br><span class="line">                    <span class="comment">//阻塞当前线程</span></span><br><span class="line">                    U.park(<span class="keyword">false</span>, time);  <span class="comment">// emulate LockSupport.park</span></span><br><span class="line">                <span class="comment">//节点唤醒后、清除线程</span></span><br><span class="line">                node.thread = <span class="keyword">null</span>;</span><br><span class="line">                U.putObject(wt, PARKBLOCKER, <span class="keyword">null</span>);</span><br><span class="line">                <span class="comment">//如果线程被中断、则取消当前节点</span></span><br><span class="line">                <span class="keyword">if</span> (interruptible &amp;&amp; Thread.interrupted())</span><br><span class="line">                    <span class="keyword">return</span> cancelWaiter(node, node, <span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;1.第一次自旋操作：(入队操作)</p><p>&emsp;&emsp;&emsp;&emsp;(1)头节点 == 尾节点，说明此时没有其他的线程进行排队，那么进行自旋、尝试性的获取锁。</p><p>&emsp;&emsp;&emsp;&emsp;(2)否则：自旋次数 == 0，直接进行入队操作。</p><p>&emsp;&emsp;2.第二、三次自旋操作：（阻塞并且等待被唤醒、第三次自旋目的在于不断尝试获取锁）</p><p>&emsp;&emsp;&emsp;&emsp;(1)头节点 == 前置节点，进入第三次自旋（处于第二次自旋的内部），尝试获取锁。</p><p>&emsp;&emsp;&emsp;&emsp;(2)否则：尝试唤醒头节点中等待的读线程</p><p>&emsp;&emsp;&emsp;&emsp;(3)如果线程一直不能获取到锁、则阻塞当前线程。</p><h3 id="unlockWrite-1"><a href="#unlockWrite-1" class="headerlink" title="unlockWrite"></a>unlockWrite</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlockWrite</span><span class="params">(<span class="keyword">long</span> stamp)</span> </span>&#123;</span><br><span class="line">    WNode h;</span><br><span class="line">    <span class="comment">//检测版本号</span></span><br><span class="line">    <span class="keyword">if</span> (state != stamp || (stamp &amp; WBIT) == <span class="number">0L</span>)</span><br><span class="line">        <span class="comment">//抛出异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="comment">//1.更新版本号</span></span><br><span class="line">    <span class="comment">//2.释放写入锁</span></span><br><span class="line">    state = (stamp += WBIT) == <span class="number">0L</span> ? ORIGIN : stamp;</span><br><span class="line">    <span class="comment">//如果头节点不为空并且状态不为0、release唤醒下一个节点</span></span><br><span class="line">    <span class="keyword">if</span> ((h = whead) != <span class="keyword">null</span> &amp;&amp; h.status != <span class="number">0</span>)</span><br><span class="line">        release(h);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">(WNode h)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (h != <span class="keyword">null</span>) &#123;</span><br><span class="line">        WNode q; Thread w;</span><br><span class="line">        <span class="comment">//设置状态为0</span></span><br><span class="line">        U.compareAndSwapInt(h, WSTATUS, WAITING, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">//如果头节点的下一个节点为空或其状态为CANCELLED</span></span><br><span class="line">        <span class="keyword">if</span> ((q = h.next) == <span class="keyword">null</span> || q.status == CANCELLED) &#123;</span><br><span class="line">            <span class="comment">//从尾部往前进行遍历寻找一个可用的节点</span></span><br><span class="line">            <span class="keyword">for</span> (WNode t = wtail; t != <span class="keyword">null</span> &amp;&amp; t != h; t = t.prev)</span><br><span class="line">                <span class="keyword">if</span> (t.status &lt;= <span class="number">0</span>)</span><br><span class="line">                    q = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//唤醒q处节点的线程</span></span><br><span class="line">        <span class="keyword">if</span> (q != <span class="keyword">null</span> &amp;&amp; (w = q.thread) != <span class="keyword">null</span>)</span><br><span class="line">            U.unpark(w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;1.更新<code>state</code>的值、释放写入锁</p><p>&emsp;&emsp;2.版本号+1</p><p>&emsp;&emsp;3.唤醒下一个等待的节点</p><h3 id="readLock-1"><a href="#readLock-1" class="headerlink" title="readLock"></a>readLock</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">readLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> s = state, next;</span><br><span class="line">    <span class="comment">//1.如果写入锁被占用、并且读取所得获取次数并没有达到最大值</span></span><br><span class="line">    <span class="comment">//2.cas尝试更新读取锁被获取的次数+1</span></span><br><span class="line">    <span class="comment">//3.如果更新成功则返回、否则进入acquireRead方法</span></span><br><span class="line">    <span class="keyword">return</span> ((whead == wtail &amp;&amp; (s &amp; ABITS) &lt; RFULL &amp;&amp;</span><br><span class="line">             U.compareAndSwapLong(<span class="keyword">this</span>, STATE, s, next = s + RUNIT)) ?</span><br><span class="line">            next : acquireRead(<span class="keyword">false</span>, <span class="number">0L</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">acquireRead</span><span class="params">(<span class="keyword">boolean</span> interruptible, <span class="keyword">long</span> deadline)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//node:为新增节点</span></span><br><span class="line">    <span class="comment">//p:尾节点</span></span><br><span class="line">    WNode node = <span class="keyword">null</span>, p;</span><br><span class="line">    <span class="comment">//第一次自旋</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> spins = -<span class="number">1</span>;;) &#123;</span><br><span class="line">        <span class="comment">//头节点</span></span><br><span class="line">        WNode h;</span><br><span class="line">        <span class="comment">//如果头节点 == 尾节点、没有排队的线程、尝试自旋获取锁</span></span><br><span class="line">        <span class="keyword">if</span> ((h = whead) == (p = wtail)) &#123;</span><br><span class="line">            <span class="comment">//第二次自旋操作</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">long</span> m, s, ns;;) &#123;</span><br><span class="line">                <span class="comment">//尝试获取锁、成功则返回版本号ns</span></span><br><span class="line">                <span class="keyword">if</span> ((m = (s = state) &amp; ABITS) &lt; RFULL ?</span><br><span class="line">                    U.compareAndSwapLong(<span class="keyword">this</span>, STATE, s, ns = s + RUNIT) :</span><br><span class="line">                    (m &lt; WBIT &amp;&amp; (ns = tryIncReaderOverflow(s)) != <span class="number">0L</span>))</span><br><span class="line">                    <span class="comment">//如果读线程个数达到了最大值、会造成溢出返回0</span></span><br><span class="line">                    <span class="keyword">return</span> ns;</span><br><span class="line">                <span class="comment">//表示有其他的线程先行一步获取到了写入锁</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (m &gt;= WBIT) &#123;</span><br><span class="line">                    <span class="comment">//自旋数&gt;0则进行自旋数-1</span></span><br><span class="line">                    <span class="keyword">if</span> (spins &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (LockSupport.nextSecondarySeed() &gt;= <span class="number">0</span>)</span><br><span class="line">                            --spins;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">//如果自旋数 == 0 、检验是否退出循环</span></span><br><span class="line">                        <span class="keyword">if</span> (spins == <span class="number">0</span>) &#123;</span><br><span class="line">                            WNode nh = whead, np = wtail;</span><br><span class="line">                            <span class="keyword">if</span> ((nh == h &amp;&amp; np == p) || (h = nh) != (p = np))</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//更新自旋数</span></span><br><span class="line">                        spins = SPINS;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果尾节点为空、进行初始化头部和尾部节点操作</span></span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span>) &#123; <span class="comment">// initialize queue</span></span><br><span class="line">            WNode hd = <span class="keyword">new</span> WNode(WMODE, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapObject(<span class="keyword">this</span>, WHEAD, <span class="keyword">null</span>, hd))</span><br><span class="line">                wtail = hd;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">//如果新增新增节点为空、进行初始化操作</span></span><br><span class="line">            node = <span class="keyword">new</span> WNode(RMODE, p);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (h == p || p.mode != RMODE) &#123;</span><br><span class="line">            <span class="comment">//如果头节点 == 尾节点 或者 尾节点不是读取模式</span></span><br><span class="line">            <span class="comment">//当前节点入队</span></span><br><span class="line">            <span class="keyword">if</span> (node.prev != p)</span><br><span class="line">                node.prev = p;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapObject(<span class="keyword">this</span>, WTAIL, p, node)) &#123;</span><br><span class="line">                p.next = node;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!U.compareAndSwapObject(p, WCOWAIT,</span><br><span class="line">                                         node.cowait = p.cowait, node))</span><br><span class="line">            <span class="comment">//尾节点尾读模式当前节点加入尾节点的cowait</span></span><br><span class="line">            node.cowait = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//开始第三段自旋</span></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                WNode pp, c; Thread w;</span><br><span class="line">                <span class="comment">//头节点不为空并且cowait不为空、唤醒其中等待的读线程</span></span><br><span class="line">                <span class="keyword">if</span> ((h = whead) != <span class="keyword">null</span> &amp;&amp; (c = h.cowait) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                    U.compareAndSwapObject(h, WCOWAIT, c, c.cowait) &amp;&amp;</span><br><span class="line">                    (w = c.thread) != <span class="keyword">null</span>) <span class="comment">// help release</span></span><br><span class="line">                    U.unpark(w);</span><br><span class="line">                <span class="comment">//头部节点的前置节点或者前置节点或者前置节点为空</span></span><br><span class="line">                <span class="keyword">if</span> (h == (pp = p.prev) || h == p || pp == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">long</span> m, s, ns;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        <span class="comment">//开启第四段自旋</span></span><br><span class="line">                        <span class="keyword">if</span> ((m = (s = state) &amp; ABITS) &lt; RFULL ?</span><br><span class="line">                            U.compareAndSwapLong(<span class="keyword">this</span>, STATE, s,</span><br><span class="line">                                                 ns = s + RUNIT) :</span><br><span class="line">                            (m &lt; WBIT &amp;&amp;</span><br><span class="line">                             (ns = tryIncReaderOverflow(s)) != <span class="number">0L</span>))</span><br><span class="line">                            <span class="keyword">return</span> ns;</span><br><span class="line">                        <span class="comment">//只有当前时刻没有其他线程占有写入锁就不断尝试</span></span><br><span class="line">                    &#125; <span class="keyword">while</span> (m &lt; WBIT);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果头部节点未曾改变且前前置节点为没发生改变、阻塞当前线程</span></span><br><span class="line">                <span class="keyword">if</span> (whead == h &amp;&amp; p.prev == pp) &#123;</span><br><span class="line">                    <span class="keyword">long</span> time;</span><br><span class="line">                    <span class="comment">//如果前前置节点为空、或者头节点 == 前置节点、或者前置节点已经取消</span></span><br><span class="line">                    <span class="comment">//进入第一个for开始重试</span></span><br><span class="line">                    <span class="keyword">if</span> (pp == <span class="keyword">null</span> || h == p || p.status &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        node = <span class="keyword">null</span>; <span class="comment">// throw away</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//超时检测机制</span></span><br><span class="line">                    <span class="keyword">if</span> (deadline == <span class="number">0L</span>)</span><br><span class="line">                        time = <span class="number">0L</span>;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> ((time = deadline - System.nanoTime()) &lt;= <span class="number">0L</span>)</span><br><span class="line">                        <span class="comment">//超时：取消当前节点</span></span><br><span class="line">                        <span class="keyword">return</span> cancelWaiter(node, p, <span class="keyword">false</span>);</span><br><span class="line">                    <span class="comment">//获取当前节点</span></span><br><span class="line">                    Thread wt = Thread.currentThread();</span><br><span class="line">                    U.putObject(wt, PARKBLOCKER, <span class="keyword">this</span>);</span><br><span class="line">                    <span class="comment">//将nede的线程指向当前线程</span></span><br><span class="line">                    node.thread = wt;</span><br><span class="line">                    <span class="comment">//检测之前的条件没有发生改变</span></span><br><span class="line">                    <span class="keyword">if</span> ((h != pp || (state &amp; ABITS) == WBIT) &amp;&amp;</span><br><span class="line">                        whead == h &amp;&amp; p.prev == pp)</span><br><span class="line">                        <span class="comment">//阻塞当前线程</span></span><br><span class="line">                        U.park(<span class="keyword">false</span>, time);</span><br><span class="line">                    <span class="comment">//唤醒线程并清除线程</span></span><br><span class="line">                    node.thread = <span class="keyword">null</span>;</span><br><span class="line">        U.putObject(wt, PARKBLOCKER, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">//线程中断取消当前节点</span></span><br><span class="line">                    <span class="keyword">if</span> (interruptible &amp;&amp; Thread.interrupted())</span><br><span class="line">                        <span class="keyword">return</span> cancelWaiter(node, p, <span class="keyword">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//开启第五次自旋（只有第一个读线程才会走到这里）单独有一个自旋针对第一个读的线程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> spins = -<span class="number">1</span>;;) &#123;</span><br><span class="line">        WNode h, np, pp; <span class="keyword">int</span> ps;</span><br><span class="line">        <span class="comment">//如果头节点 == 尾节点（快轮到自己了）</span></span><br><span class="line">        <span class="keyword">if</span> ((h = whead) == p) &#123;</span><br><span class="line">            <span class="keyword">if</span> (spins &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="comment">//自旋次数&lt;0,设置自旋次数</span></span><br><span class="line">                spins = HEAD_SPINS;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (spins &lt; MAX_HEAD_SPINS)</span><br><span class="line">                <span class="comment">//自旋次数初始化完成后-1</span></span><br><span class="line">                spins &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//开始第六次自旋</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = spins;;) &#123; <span class="comment">// spin at head</span></span><br><span class="line">                <span class="keyword">long</span> m, s, ns;</span><br><span class="line">                <span class="comment">//不断的尝试获取锁</span></span><br><span class="line">                <span class="keyword">if</span> ((m = (s = state) &amp; ABITS) &lt; RFULL ?</span><br><span class="line">                    U.compareAndSwapLong(<span class="keyword">this</span>, STATE, s, ns = s + RUNIT) :</span><br><span class="line">                    (m &lt; WBIT &amp;&amp; (ns = tryIncReaderOverflow(s)) != <span class="number">0L</span>)) &#123;</span><br><span class="line">                    <span class="comment">//获取到了读取锁</span></span><br><span class="line">                    WNode c; Thread w;</span><br><span class="line">                    whead = node;</span><br><span class="line">                    node.prev = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="comment">//唤醒当前节点中所有的等待的读线程</span></span><br><span class="line">                    <span class="comment">//当前节点是第一个读的节点、其他的读节点都是挂在当前节点的cowait中</span></span><br><span class="line">                    <span class="keyword">while</span> ((c = node.cowait) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (U.compareAndSwapObject(node, WCOWAIT,</span><br><span class="line">                                                   c, c.cowait) &amp;&amp;</span><br><span class="line">                            (w = c.thread) != <span class="keyword">null</span>)</span><br><span class="line">                            U.unpark(w);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//返回版本号</span></span><br><span class="line">                    <span class="keyword">return</span> ns;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果当前有其他线程占有了写入锁、并且没有自旋次数、跳出循环</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (m &gt;= WBIT &amp;&amp;</span><br><span class="line">                         LockSupport.nextSecondarySeed() &gt;= <span class="number">0</span> &amp;&amp; --k &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (h != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">//如果头节点不等于尾部节点不为空并且其为读取模式、唤醒里面的读线程</span></span><br><span class="line">            WNode c; Thread w;</span><br><span class="line">            <span class="keyword">while</span> ((c = h.cowait) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapObject(h, WCOWAIT, c, c.cowait) &amp;&amp;</span><br><span class="line">                    (w = c.thread) != <span class="keyword">null</span>)</span><br><span class="line">                    U.unpark(w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//头节点没有发生变化</span></span><br><span class="line">        <span class="keyword">if</span> (whead == h) &#123;</span><br><span class="line">            <span class="comment">//更新前置节点以及状态</span></span><br><span class="line">            <span class="keyword">if</span> ((np = node.prev) != p) &#123;</span><br><span class="line">                <span class="keyword">if</span> (np != <span class="keyword">null</span>)</span><br><span class="line">                    (p = np).next = node;   <span class="comment">// stale</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((ps = p.status) == <span class="number">0</span>)</span><br><span class="line">                U.compareAndSwapInt(p, WSTATUS, <span class="number">0</span>, WAITING);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ps == CANCELLED) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((pp = p.prev) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    node.prev = pp;</span><br><span class="line">                    pp.next = node;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//第一个节点即将开始进入阻塞</span></span><br><span class="line">                <span class="keyword">long</span> time;</span><br><span class="line">                <span class="comment">//设置超时</span></span><br><span class="line">                <span class="keyword">if</span> (deadline == <span class="number">0L</span>)</span><br><span class="line">                    time = <span class="number">0L</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((time = deadline - System.nanoTime()) &lt;= <span class="number">0L</span>)</span><br><span class="line">                    <span class="comment">//超时则取消当前节点</span></span><br><span class="line">                    <span class="keyword">return</span> cancelWaiter(node, node, <span class="keyword">false</span>);</span><br><span class="line">                Thread wt = Thread.currentThread();</span><br><span class="line">                U.putObject(wt, PARKBLOCKER, <span class="keyword">this</span>);</span><br><span class="line">                node.thread = wt;</span><br><span class="line">                <span class="keyword">if</span> (p.status &lt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">                    (p != h || (state &amp; ABITS) == WBIT) &amp;&amp;</span><br><span class="line">                    whead == h &amp;&amp; node.prev == p)</span><br><span class="line">                    <span class="comment">//阻塞第一个线程并等待被唤醒</span></span><br><span class="line">                    U.park(<span class="keyword">false</span>, time);</span><br><span class="line">                node.thread = <span class="keyword">null</span>;</span><br><span class="line">                U.putObject(wt, PARKBLOCKER, <span class="keyword">null</span>);</span><br><span class="line">                <span class="keyword">if</span> (interruptible &amp;&amp; Thread.interrupted())</span><br><span class="line">                    <span class="keyword">return</span> cancelWaiter(node, node, <span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;1.头节点 == 尾节点，表示已经快轮到自己了、尝试获取锁、成功则返回</p><p>&emsp;&emsp;2.头节点 != 尾节点，当前节点入队</p><p>&emsp;&emsp;3.首个读节点入队：排队到整个队尾的尾部、跳出第一次自旋、进入第五次自旋</p><p>&emsp;&emsp;4.非首个读节点入队：进入首个读节点的cowait栈中</p><p>&emsp;&emsp;5.检测头节点是否等于尾节点：相等则会不断的尝试获取锁，不相等：当前线程进入阻塞等待被唤醒</p><p>&emsp;&emsp;6.首个读节点表示连续的读线程中的首个、若是两个读线程之间存在了一个写人线程，那么也会进行排队</p><h3 id="unlockRead-1"><a href="#unlockRead-1" class="headerlink" title="unlockRead"></a>unlockRead</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlockRead</span><span class="params">(<span class="keyword">long</span> stamp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> s, m; WNode h;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//检测版本号</span></span><br><span class="line">        <span class="keyword">if</span> (((s = state) &amp; SBITS) != (stamp &amp; SBITS) ||</span><br><span class="line">            (stamp &amp; ABITS) == <span class="number">0L</span> || (m = s &amp; ABITS) == <span class="number">0L</span> || m == WBIT)</span><br><span class="line">            <span class="comment">//抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">        <span class="comment">//判断读线程的个数</span></span><br><span class="line">        <span class="keyword">if</span> (m &lt; RFULL) &#123;</span><br><span class="line">            <span class="comment">//释放一次读取锁</span></span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapLong(<span class="keyword">this</span>, STATE, s, s - RUNIT)) &#123;</span><br><span class="line">                <span class="comment">//如果线程全部已经被释放了、头节点不为空并且状态不为0、release方法唤醒下一个节点</span></span><br><span class="line">                <span class="keyword">if</span> (m == RUNIT &amp;&amp; (h = whead) != <span class="keyword">null</span> &amp;&amp; h.status != <span class="number">0</span>)</span><br><span class="line">                    release(h);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (tryDecReaderOverflow(s) != <span class="number">0L</span>)</span><br><span class="line">            <span class="comment">//读取线程个数溢出</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">(WNode h)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (h != <span class="keyword">null</span>) &#123;</span><br><span class="line">        WNode q; Thread w;</span><br><span class="line">        <span class="comment">//设置状态为0</span></span><br><span class="line">        U.compareAndSwapInt(h, WSTATUS, WAITING, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">//如果头节点的下一个节点为空或其状态为CANCELLED</span></span><br><span class="line">        <span class="keyword">if</span> ((q = h.next) == <span class="keyword">null</span> || q.status == CANCELLED) &#123;</span><br><span class="line">            <span class="comment">//从尾部往前进行遍历寻找一个可用的节点</span></span><br><span class="line">            <span class="keyword">for</span> (WNode t = wtail; t != <span class="keyword">null</span> &amp;&amp; t != h; t = t.prev)</span><br><span class="line">                <span class="keyword">if</span> (t.status &lt;= <span class="number">0</span>)</span><br><span class="line">                    q = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//唤醒q处节点的线程</span></span><br><span class="line">        <span class="keyword">if</span> (q != <span class="keyword">null</span> &amp;&amp; (w = q.thread) != <span class="keyword">null</span>)</span><br><span class="line">            U.unpark(w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="tryOptimisticRead-1"><a href="#tryOptimisticRead-1" class="headerlink" title="tryOptimisticRead"></a>tryOptimisticRead</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果没有写锁，就返回state的高25位</span></span><br><span class="line"><span class="comment">//写所在位置一起返回,为了后面检测数据有没有被写过</span></span><br><span class="line"><span class="comment">//乐观读</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">tryOptimisticRead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> s;</span><br><span class="line">    <span class="keyword">return</span> (((s = state) &amp; WBIT) == <span class="number">0L</span>) ? (s &amp; SBITS) : <span class="number">0L</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="validate-1"><a href="#validate-1" class="headerlink" title="validate"></a>validate</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//检测乐观读版本号是否变化</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validate</span><span class="params">(<span class="keyword">long</span> stamp)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 强制加入内存屏障，刷新数据</span></span><br><span class="line">    U.loadFence();</span><br><span class="line">    <span class="keyword">return</span> (stamp &amp; SBITS) == (state &amp; SBITS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="变异的CLH队列"><a href="#变异的CLH队列" class="headerlink" title="变异的CLH队列"></a>变异的CLH队列</h3><p><img src="/image/hexo/image-20200718204935119.png" alt="image-20200718204935119"></p><h2 id="运行示例分析"><a href="#运行示例分析" class="headerlink" title="运行示例分析"></a>运行示例分析</h2><p><a href="https://segmentfault.com/a/1190000015808032" target="_blank" rel="noopener">来源</a></p><blockquote><p><code>//Thread_A 获取写锁</code><br><code>//Thread_B 获取读锁</code><br><code>//Thread_C 获取读锁</code><br><code>//Thread_D 获取写锁</code><br><code>//Thread_E 获取读锁</code></p></blockquote><h3 id="Thread-A-writeLock"><a href="#Thread-A-writeLock" class="headerlink" title="Thread_A(writeLock)"></a>Thread_A(writeLock)</h3><p><img src="/image/hexo/image-20200718205455857.png" alt="image-20200718205455857"></p><p>StampedLock中大量运用了位运算，这里<code>(s = state) &amp; ABITS == 0L</code> 表示读锁和写锁都未被使用，这里写锁可以立即获取成功，然后CAS操作更新同步状态值State。</p><p>操作完成后，等待队列的结构如下：</p><p><img src="/image/hexo/image-20200718205419032.png" alt="image-20200718205419032"></p><blockquote><p>注意：StampedLock中，等待队列的结点要比AQS中简单些，仅仅三种状态。<br>0：初始状态<br>-1：等待中<br>1：取消</p></blockquote><p>另外，结点的定义中有个<code>cowait</code>字段，该字段指向一个栈，用于保存读线程。</p><h3 id="Thread-B-readLock"><a href="#Thread-B-readLock" class="headerlink" title="Thread_B(readLock)"></a>Thread_B(readLock)</h3><p><img src="/image/hexo/image-20200718205552104.png" alt="image-20200718205552104"></p><p>由于<code>Thread_A</code>线程持有了写锁、那么此时获取锁失败，进入<code>acquireRead</code>方法。</p><p><img src="/image/hexo/image-20200718205703751.png" alt="image-20200718205703751"></p><p><img src="/image/hexo/image-20200718205724877.png" alt="image-20200718205724877"></p><p><img src="/image/hexo/image-20200718205731522.png" alt="image-20200718205731522"></p><h3 id="Thread-C-readLock"><a href="#Thread-C-readLock" class="headerlink" title="Thread_C(readLock)"></a>Thread_C(readLock)</h3><p>这个过程和<code>Thread_B</code>获取读锁一样，区别在于<code>Thread_C</code>被包装成结点加入等待队列后，是链接到<code>Thread_B</code>结点的栈指针中的。调用完下面这段代码后，<code>Thread_C</code>会链接到以<code>Thread_B</code>为栈顶指针的栈中：</p><p><img src="/image/hexo/image-20200718205839240.png" alt="image-20200718205839240"></p><p><img src="/image/hexo/image-20200718205856220.png" alt="image-20200718205856220"></p><p>可以看到，此时<code>Thread_C</code>结点并没有把它的前驱的等待状态置为-1，因为<code>Thread_C</code>是链接到栈中的，当写锁释放的时候，会从栈底元素开始，唤醒栈中所有读结点。</p><h3 id="Thread-D-writeLock"><a href="#Thread-D-writeLock" class="headerlink" title="Thread_D(writeLock)"></a>Thread_D(writeLock)</h3><p><code>Thread_D</code>调用<strong>writeLock</strong>方法获取写锁失败后（<code>Thread_A</code>依然占用着写锁），会调用<strong>acquireWrite</strong>方法，该方法整体逻辑和<strong>acquireRead</strong>差不多，首先自旋的尝试获取写锁，获取成功后，就直接返回；否则，会将当前线程包装成一个写结点，插入到等待队列。</p><p><img src="/image/hexo/image-20200718205934160.png" alt="image-20200718205934160"></p><p><img src="/image/hexo/image-20200718210007566.png" alt="image-20200718210007566"></p><p><img src="/image/hexo/image-20200718210018123.png" alt="image-20200718210018123"></p><h3 id="Thead-E-readLock"><a href="#Thead-E-readLock" class="headerlink" title="Thead_E(readLock)"></a>Thead_E(readLock)</h3><p>同样，由于写锁被<code>Thread_A</code>占用着，所以最终会调用<strong>acquireRead</strong>方法，在该方法的第一个自旋中，会将<code>Thread_E</code>加入等待队列:</p><p><img src="/image/hexo/image-20200718210103657.png" alt="image-20200718210103657"></p><p><img src="/image/hexo/image-20200718210116706.png" alt="image-20200718210116706"></p><h3 id="Thread-A-unlockWrite"><a href="#Thread-A-unlockWrite" class="headerlink" title="Thread_A(unlockWrite)"></a>Thread_A(unlockWrite)</h3><p>通过CAS操作，修改State成功后，会调用<strong>release</strong>方法唤醒等待队列的队首结点：</p><p><img src="/image/hexo/image-20200718210206473.png" alt="image-20200718210206473"></p><p><strong>release</strong>方法非常简单，先将头结点的等待状态置为0，表示即将唤醒后继结点，然后立即唤醒队首结点：</p><p><img src="/image/hexo/image-20200718210221536.png" alt="image-20200718210221536"></p><p><img src="/image/hexo/image-20200718210229864.png" alt="image-20200718210229864"></p><h3 id="Thread-B-unlockRead-gt-next"><a href="#Thread-B-unlockRead-gt-next" class="headerlink" title="Thread_B(unlockRead-&gt;next)"></a>Thread_B(unlockRead-&gt;next)</h3><p><img src="/image/hexo/image-20200718210309090.png" alt="image-20200718210309090"></p><p>第二次自旋时，<code>Thread_B</code>发现写锁未被占用，则成功获取到读锁，然后从栈顶（<code>Thread_B</code>的cowait指针指向的结点）开始唤醒栈中所有线程，<br>最后返回：</p><p><img src="/image/hexo/image-20200718210321715.png" alt="image-20200718210321715"></p><p><img src="/image/hexo/image-20200718210328781.png" alt="image-20200718210328781"></p><h3 id="Thread-C-unlockRead-gt-next"><a href="#Thread-C-unlockRead-gt-next" class="headerlink" title="Thread_C(unlockRead-&gt;next)"></a>Thread_C(unlockRead-&gt;next)</h3><p><code>Thread_C</code>被唤醒后，继续执行，并进入下一次自旋，下一次自旋时，会成功获取到读锁。</p><p><img src="/image/hexo/69274006-5b5de694a90ad_articlex.png" alt="69274006-5b5de694a90ad_articlex"></p><p>注意，此时<code>Thread_B</code>和<code>Thread_C</code>已经拿到了读锁，<code>Thread_D</code>（写线程）和<code>Thread_E</code>（读线程）依然阻塞中，原来<code>Thread_C</code>对应的结点是个孤立结点，会被GC回收。</p><p><img src="/image/hexo/image-20200718210625568.png" alt="image-20200718210625568"></p><h3 id="Thread-B和Thread-C释放读锁"><a href="#Thread-B和Thread-C释放读锁" class="headerlink" title="Thread_B和Thread_C释放读锁"></a>Thread_B和Thread_C释放读锁</h3><p><code>Thread_B</code>和<code>Thread_C</code>调用<strong>unlockRead</strong>方法释放读锁，CAS操作State将读锁数量减1：</p><p><img src="/image/hexo/image-20200718210714617.png" alt="image-20200718210714617"></p><p>注意，当读锁的数量变为0时才会调用<strong>release</strong>方法，唤醒队首结点：</p><p><img src="/image/hexo/image-20200718210728941.png" alt="image-20200718210728941"></p><p><img src="/image/hexo/image-20200718210735960.png" alt="image-20200718210735960"></p><h3 id="Thread-D被唤醒后继续向下执行"><a href="#Thread-D被唤醒后继续向下执行" class="headerlink" title="Thread_D被唤醒后继续向下执行"></a>Thread_D被唤醒后继续向下执行</h3><p><code>Thread_D</code>会从原阻塞处继续向下执行，并在下一次自旋中获取到写锁，然后返回:</p><p><img src="/image/hexo/4207167806-5b5de717b34bc_articlex.png" alt="4207167806-5b5de717b34bc_articlex"></p><p><img src="/image/hexo/image-20200718210843887.png" alt="image-20200718210843887"></p><h3 id="Thread-D调用unlockWrite释放写锁"><a href="#Thread-D调用unlockWrite释放写锁" class="headerlink" title="Thread_D调用unlockWrite释放写锁"></a>Thread_D调用unlockWrite释放写锁</h3><p><code>Thread_D</code>释放写锁，会调用<strong>unlockWrite</strong>唤醒队首结点（<code>Thread_E</code>）。</p><p><img src="/image/hexo/image-20200718210935053.png" alt="image-20200718210935053"></p><p><code>Thread_E</code>被唤醒后会从原阻塞处继续向下执行，但由于<code>Thread_E</code>是个读结点，所以同时会唤醒cowait栈中的所有读结点。最终，等待队列的结构如下：</p><p><img src="/image/hexo/image-20200718211018901.png" alt="image-20200718211018901"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>StampedLock</strong>的等待队列与<strong>RRW</strong>的<strong>CLH</strong>队列相比，有以下特点：</p><ol><li>当入队一个线程时，如果队尾是读结点，不会直接链接到队尾，而是链接到该读结点的cowait链中，cowait链本质是一个栈；</li><li>当入队一个线程时，如果队尾是写结点，则直接链接到队尾；</li><li>唤醒线程的规则和<strong>AQS</strong>类似，都是首先唤醒队首结点。区别是<strong>StampedLock</strong>中，当唤醒的结点是读结点时，会唤醒该读结点的cowait链中的所有读结点（顺序和入栈顺序相反，也就是后进先出）。</li></ol><p>另外，<strong>StampedLock</strong>使用时要特别小心，避免锁重入的操作，在使用乐观读锁时也需要遵循相应的调用模板，防止出现数据不一致的问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/image/hexo/image-20200718131809394.png&quot; alt=&quot;image-20200718131809394&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;StampedLock相关API&quot;&gt;&lt;a href=&quot;#StampedLock相关AP
      
    
    </summary>
    
    
      <category term="JAVA" scheme="https://blog.huhdcc.top/categories/JAVA/"/>
    
      <category term="多线程" scheme="https://blog.huhdcc.top/categories/JAVA/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="JAVA" scheme="https://blog.huhdcc.top/tags/JAVA/"/>
    
      <category term="多线程" scheme="https://blog.huhdcc.top/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="源码深入" scheme="https://blog.huhdcc.top/tags/%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>多线程高阶-50-Condition详解</title>
    <link href="https://blog.huhdcc.top/2020/07/17/39136/hub/"/>
    <id>https://blog.huhdcc.top/2020/07/17/39136/hub/</id>
    <published>2020-07-17T09:18:44.000Z</published>
    <updated>2020-07-17T14:28:49.145Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/image/hexo/image-20200717222649206.png" alt="image-20200717222649206"></p><h2 id="Condition相关API"><a href="#Condition相关API" class="headerlink" title="Condition相关API"></a>Condition相关API</h2><h3 id="类声明"><a href="#类声明" class="headerlink" title="类声明"></a>类声明</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Condition</span></span></span><br></pre></td></tr></table></figure><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ReentrantLock.newCondition</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sync.newCondition();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p><img src="/image/hexo/image-20200717203303414.png" alt="image-20200717203303414"></p><h4 id="await"><a href="#await" class="headerlink" title="await"></a>await</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//await</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1.当前线程进入等待状态</span></span><br><span class="line"><span class="comment"> * 2.线程中断或者signal</span></span><br><span class="line"><span class="comment"> * 3.支持设置超时时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">condition.await();</span><br><span class="line">condition.await(<span class="number">10</span>, TimeUnit.MILLISECONDS);</span><br></pre></td></tr></table></figure><h4 id="awaitNanos"><a href="#awaitNanos" class="headerlink" title="awaitNanos"></a>awaitNanos</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//awaitNanos</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1.当前线程进入等待状态</span></span><br><span class="line"><span class="comment"> * 2.线程中断或者signal</span></span><br><span class="line"><span class="comment"> * 3.超时</span></span><br><span class="line"><span class="comment"> * 4.返回值表示剩余超时时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">condition.awaitNanos(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><h4 id="awaitUninterruptibly"><a href="#awaitUninterruptibly" class="headerlink" title="awaitUninterruptibly"></a>awaitUninterruptibly</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//awaitUninterruptibly</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1.当前线程进入等待状态</span></span><br><span class="line"><span class="comment"> * 2.只能等待通知</span></span><br><span class="line"><span class="comment"> * 3.不响应中断</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">condition.awaitUninterruptibly();</span><br></pre></td></tr></table></figure><h4 id="awaitUntil"><a href="#awaitUntil" class="headerlink" title="awaitUntil"></a>awaitUntil</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//awaitUntil</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1.当前线程进入等待状态</span></span><br><span class="line"><span class="comment"> * 2.通知、线程中断、执行操作退出</span></span><br><span class="line"><span class="comment"> * 3.若是在时间范围内被通知返回true,否则false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">condition.awaitUntil(<span class="keyword">new</span> Date());</span><br></pre></td></tr></table></figure><h4 id="signal"><a href="#signal" class="headerlink" title="signal"></a>signal</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//signal</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 1.唤醒一个在Condition等待的线程</span></span><br><span class="line"><span class="comment"> * 2.必须获得Condition相关联的锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">condition.signal();</span><br></pre></td></tr></table></figure><h4 id="signalAll"><a href="#signalAll" class="headerlink" title="signalAll"></a>signalAll</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//signalAll</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1.唤醒所有在Condition等待的线程</span></span><br><span class="line"><span class="comment"> * 2.必须获得Condition相关联的锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">condition.signalAll();</span><br></pre></td></tr></table></figure><h2 id="案例（Condition构建多生产者与消费者）"><a href="#案例（Condition构建多生产者与消费者）" class="headerlink" title="案例（Condition构建多生产者与消费者）"></a>案例（Condition构建多生产者与消费者）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionTest1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生产者</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> Condition PRODUCE = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消费者</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> Condition CONSUMER = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 任务队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> LinkedList&lt;Integer&gt; QUEUE = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> Integer MAX_QUEUE_SIZE = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> Random random = <span class="keyword">new</span> Random(System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        IntStream.range(<span class="number">0</span>, <span class="number">6</span>).boxed().forEach(ConditionTest1::startProduce);</span><br><span class="line">        IntStream.range(<span class="number">0</span>, <span class="number">10</span>).boxed().forEach(ConditionTest1::startConsumer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">startProduce</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">           <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">               produce();</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">               &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;, <span class="string">"P-"</span> + i).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">startConsumer</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">                consumer();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"C-"</span> + i).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span> 生产</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>  sanmengccc</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>   2020/7/17 20:48</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">while</span> (QUEUE.size() &gt; MAX_QUEUE_SIZE) &#123;</span><br><span class="line">                PRODUCE.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> value = random.nextInt(<span class="number">1000</span>);</span><br><span class="line">            System.out.println(<span class="string">"The "</span> + Thread.currentThread().getName() + <span class="string">" produce:"</span> + value);</span><br><span class="line">            QUEUE.addLast(value);</span><br><span class="line">            CONSUMER.signalAll();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span> 消费</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>  sanmengcc</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>   2020/7/17 20:49</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">while</span> (QUEUE.isEmpty()) &#123;</span><br><span class="line">                CONSUMER.await();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"The "</span> + Thread.currentThread().getName() + <span class="string">" consumer:"</span> + QUEUE.removeFirst());</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            PRODUCE.signalAll();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/image/hexo/image-20200717212332776.png" alt="image-20200717212332776"></p><h2 id="部分源码解析"><a href="#部分源码解析" class="headerlink" title="部分源码解析"></a>部分源码解析</h2><h3 id="ConditionObject"><a href="#ConditionObject" class="headerlink" title="ConditionObject"></a>ConditionObject</h3><p>&emsp;&emsp;<strong>Condition</strong>只是一个接口，而真正的实现还是<code>AQS</code>内部的<strong>ConditionObject</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sync.newCondition();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> ConditionObject <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ConditionObject();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;<strong>ConditionObject</strong>主要维护了一个等待队列（<code>FIFO</code>）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//条件队首节点指针</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Node firstWaiter;</span><br><span class="line"><span class="comment">//条件队尾节点指针</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Node lastWaiter;</span><br></pre></td></tr></table></figure><p><img src="/image/hexo/image-20200717212729676.png" alt="image-20200717212729676"></p><h3 id="await-1"><a href="#await-1" class="headerlink" title="await"></a>await</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用该方法必须获取到锁资源（同步队列中的首节点）</span></span><br><span class="line"><span class="comment">//将当前线程加入等待队列、并且释放同步状态、唤醒同步队列中的后继节点</span></span><br><span class="line"><span class="comment">//当前线程进入等待状态</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="comment">//线程中断抛出异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="comment">//包装当前线程、加入条件队列</span></span><br><span class="line">    Node node = addConditionWaiter();</span><br><span class="line">    <span class="comment">//释放锁、返回同步状态（调用此方法前此线程占有锁）</span></span><br><span class="line">    <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">    <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//判断当前节点是否在等待队列中</span></span><br><span class="line">    <span class="comment">//不在：表示没有竞争锁的资格、继续等待，直到加入队列（singal）</span></span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//唤醒后重新竞争锁资源、失败则继续沉睡、再次等待唤醒开始下一次竞争</span></span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>) <span class="comment">// clean up if cancelled</span></span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">    <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加入等待队列</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addConditionWaiter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//队尾节点</span></span><br><span class="line">    Node t = lastWaiter;</span><br><span class="line">    <span class="comment">//尾节点不是CONDITION状态则表示该节点不处于等待状态，清理该节点</span></span><br><span class="line">    <span class="keyword">if</span> (t != <span class="keyword">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">        t = lastWaiter;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将当前线程进行包装成Node,状态为CONDITION</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), Node.CONDITION);</span><br><span class="line">    <span class="comment">//加入队尾节点</span></span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>)</span><br><span class="line">        firstWaiter = node;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        t.nextWaiter = node;</span><br><span class="line">    lastWaiter = node;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//释放同步状态</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">fullyRelease</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//获取同步状态</span></span><br><span class="line">        <span class="keyword">int</span> savedState = getState();</span><br><span class="line">        <span class="comment">//释放锁</span></span><br><span class="line">        <span class="keyword">if</span> (release(savedState)) &#123;</span><br><span class="line">            failed = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> savedState;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            node.waitStatus = Node.CANCELLED;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自省检查节点是否还存在于同步队列</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isOnSyncQueue</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判断节点状态：CONDITION或者前驱动节点为null则返回false</span></span><br><span class="line">    <span class="keyword">if</span> (node.waitStatus == Node.CONDITION || node.prev == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//后继节点不为null、那么当前线程处理同步队列</span></span><br><span class="line">    <span class="keyword">if</span> (node.next != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> findNodeFromTail(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//清理节点</span></span><br><span class="line"><span class="comment">//1.节点不处于同步队列：挂起当前线程</span></span><br><span class="line"><span class="comment">//2.节点处于同步队列（获取了同步状态）：unlinkCancelledWaiters去清理节点</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unlinkCancelledWaiters</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node t = firstWaiter;</span><br><span class="line">    Node trail = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Node next = t.nextWaiter;</span><br><span class="line">        <span class="keyword">if</span> (t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">            t.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (trail == <span class="keyword">null</span>)</span><br><span class="line">                firstWaiter = next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                trail.nextWaiter = next;</span><br><span class="line">            <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">                lastWaiter = trail;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            trail = t;</span><br><span class="line">        t = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="signal-1"><a href="#signal-1" class="headerlink" title="signal"></a>signal</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判断当前线程是否获取到了锁资源</span></span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">        <span class="comment">//抛出Monitor异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="comment">//唤醒等待队列中的首节点</span></span><br><span class="line">    Node first = firstWaiter;</span><br><span class="line">    <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">        doSignal(first);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSignal</span><span class="params">(Node first)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">//移除等待队列的首节点</span></span><br><span class="line">        <span class="keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="keyword">null</span>)</span><br><span class="line">            lastWaiter = <span class="keyword">null</span>;</span><br><span class="line">        first.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (!transferForSignal(first) &amp;&amp;</span><br><span class="line">             (first = firstWaiter) != <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//主要操作：节点移动（移动到同步队列）</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferForSignal</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//尝试将该节点状态从CONDITION修改为0、CAS操作</span></span><br><span class="line">    <span class="keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将当前节点加入同步队尾、并且返回该节点的前驱节点</span></span><br><span class="line">    Node p = enq(node);</span><br><span class="line">    <span class="keyword">int</span> ws = p.waitStatus;</span><br><span class="line">    <span class="comment">//如果前驱节点的状态为：CANCEL或者CAS修改waitStatus失败，则唤醒当前线程</span></span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</span><br><span class="line">        LockSupport.unpark(node.thread);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;成功唤醒的线程，则退出<code>await</code>中的循环，通过<code>acquireQueued</code>再次进行锁资源的竞争。成功获取锁后，唤醒的线程从<code>await</code>方法中返回。</p><p>&emsp;&emsp;<code>signalAll</code>方法主要是对等待队列中的每一个节点去执行了一次<code>signal</code>将等待队列中的所有节点全部移动到了同步队列中。</p><p><img src="/image/hexo/image-20200717212745900.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/image/hexo/image-20200717222649206.png&quot; alt=&quot;image-20200717222649206&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Condition相关API&quot;&gt;&lt;a href=&quot;#Condition相关API&quot; c
      
    
    </summary>
    
    
      <category term="JAVA" scheme="https://blog.huhdcc.top/categories/JAVA/"/>
    
      <category term="多线程" scheme="https://blog.huhdcc.top/categories/JAVA/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="JAVA" scheme="https://blog.huhdcc.top/tags/JAVA/"/>
    
      <category term="多线程" scheme="https://blog.huhdcc.top/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="源码深入" scheme="https://blog.huhdcc.top/tags/%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>多线程高阶-49-ReadWriteLock-ReentrantReadWriteLock详解</title>
    <link href="https://blog.huhdcc.top/2020/07/13/4168/hub/"/>
    <id>https://blog.huhdcc.top/2020/07/13/4168/hub/</id>
    <published>2020-07-13T12:14:30.000Z</published>
    <updated>2020-07-13T13:43:56.310Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/image/hexo/image-20200713202103876.png" alt="image-20200713202103876"></p><p>&emsp;&emsp;<strong>ReentrantReadWriteLock</strong>主要是针对<strong>ReentrantLock</strong>进行了再一次的封装，是一种<strong>读写锁</strong>的实现。也实现了<strong>独占锁</strong>、<strong>共享锁</strong>的特性，其实它的内部也是基于<strong>AQS</strong>去实现核心功能。</p><p>&emsp;&emsp;1.读锁：没有其他线程进入写锁,没有写入请求或者调用线程和持有锁的线程是同一个。</p><p>&emsp;&emsp;2.写锁：没有其他线程的读写锁。</p><p>&emsp;&emsp;3.基于<strong>ReentrantLock</strong>也支持了公平策略，默认非公平策略。</p><p>&emsp;&emsp;4.读写锁均支持重入。</p><p>&emsp;&emsp;5.支持锁降级操作：遵循获取写锁、读锁、释放写锁的顺序，写锁能够降级为读锁。</p><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><h3 id="不加锁"><a href="#不加锁" class="headerlink" title="不加锁"></a>不加锁</h3><h4 id="定义共享数据DataRecourseFree"><a href="#定义共享数据DataRecourseFree" class="headerlink" title="定义共享数据DataRecourseFree"></a>定义共享数据DataRecourseFree</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataRecourseFree</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Map&lt;String ,String&gt; dataMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key, String value)</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" 正在执行写入操作.......["</span>+key+<span class="string">":"</span>+value+<span class="string">"]"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        dataMap.put(key, value);</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" 正在执行写入操作执行完毕......."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" 正在执行读取操作......."</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" 正在执行读取操作执行完毕.......:["</span>+key+<span class="string">":"</span>+dataMap.get(key)+<span class="string">"]"</span>);</span><br><span class="line">        <span class="keyword">return</span> dataMap.get(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试运行"><a href="#测试运行" class="headerlink" title="测试运行"></a>测试运行</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DataRecourseFree dataRecourseFree = <span class="keyword">new</span> DataRecourseFree();</span><br><span class="line">        IntStream.range(<span class="number">0</span>,<span class="number">10</span>)</span><br><span class="line">                .forEach(i-&gt;&#123;</span><br><span class="line">                    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                        dataRecourseFree.put(String.valueOf(i), String.valueOf(i));</span><br><span class="line">                    &#125;, String.valueOf(i)).start();</span><br><span class="line">                &#125;);</span><br><span class="line">        IntStream.range(<span class="number">0</span>,<span class="number">10</span>)</span><br><span class="line">                .forEach(i-&gt;&#123;</span><br><span class="line">                    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                        dataRecourseFree.get(String.valueOf(i));</span><br><span class="line"></span><br><span class="line">                    &#125;, String.valueOf(i)).start();</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/image/hexo/image-20200713210916750.png" alt="image-20200713210916750"></p><p><img src="/image/hexo/image-20200713210932415.png" alt="image-20200713210932415"></p><p>&emsp;&emsp;毫无疑问线程安全问题无法避免。那么下面采用加锁的方式来解决线程不安全的问题。</p><h3 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h3><h4 id="重新定义DataRecource"><a href="#重新定义DataRecource" class="headerlink" title="重新定义DataRecource"></a>重新定义DataRecource</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataRecourse</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    ReentrantReadWriteLock lock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Map&lt;String ,String&gt; dataMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key, String value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.writeLock().lock();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" 正在执行写入操作.......["</span>+key+<span class="string">":"</span>+value+<span class="string">"]"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            dataMap.put(key, value);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" 正在执行写入操作执行完毕......."</span>);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.writeLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.readLock().lock();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" 正在执行读取操作......."</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" 正在执行读取操作执行完毕.......:["</span>+key+<span class="string">":"</span>+dataMap.get(key)+<span class="string">"]"</span>);</span><br><span class="line">            <span class="keyword">return</span> dataMap.get(key);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试运行-1"><a href="#测试运行-1" class="headerlink" title="测试运行"></a>测试运行</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DataRecourse dataRecourseFree = <span class="keyword">new</span> DataRecourse();</span><br><span class="line">        IntStream.range(<span class="number">0</span>,<span class="number">10</span>)</span><br><span class="line">                .forEach(i-&gt;&#123;</span><br><span class="line">                    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                        dataRecourseFree.put(String.valueOf(i), String.valueOf(i));</span><br><span class="line">                    &#125;, String.valueOf(i)).start();</span><br><span class="line">                &#125;);</span><br><span class="line">        IntStream.range(<span class="number">0</span>,<span class="number">10</span>)</span><br><span class="line">                .forEach(i-&gt;&#123;</span><br><span class="line">                    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                        dataRecourseFree.get(String.valueOf(i));</span><br><span class="line"></span><br><span class="line">                    &#125;, String.valueOf(i)).start();</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/image/hexo/image-20200713211447063.png" alt="image-20200713211447063"></p><p>&emsp;&emsp;使用读写锁自然是能够解决上面的线程不安全的问题。</p><h2 id="ReentranReadWriteLock相关API"><a href="#ReentranReadWriteLock相关API" class="headerlink" title="ReentranReadWriteLock相关API"></a>ReentranReadWriteLock相关API</h2><h3 id="类声明"><a href="#类声明" class="headerlink" title="类声明"></a>类声明</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantReadWriteLock</span> <span class="keyword">implements</span> <span class="title">ReadWriteLock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造函数</span></span><br><span class="line">ReentrantReadWriteLock r1 = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"><span class="comment">//可以通过构造函数指定公平策略</span></span><br><span class="line">ReentrantReadWriteLock r2 = <span class="keyword">new</span> ReentrantReadWriteLock(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h4 id="getQueueLength"><a href="#getQueueLength" class="headerlink" title="getQueueLength"></a>getQueueLength</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ReentrantReadWriteLock reentrantLock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line"><span class="comment">//getQueueLength</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1.返回等待获取读取或写入锁定的线程数的估计</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">System.out.println(reentrantLock.getQueueLength());</span><br></pre></td></tr></table></figure><h4 id="getReadHoldCount"><a href="#getReadHoldCount" class="headerlink" title="getReadHoldCount"></a>getReadHoldCount</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//getReadHoldCount</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1.查询当前线程对此锁的可重入读取保留数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">System.out.println(reentrantLock.getReadHoldCount());</span><br></pre></td></tr></table></figure><h4 id="getReadLockCount"><a href="#getReadLockCount" class="headerlink" title="getReadLockCount"></a>getReadLockCount</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//getReadLockCount</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1.查询为此锁持有的读取锁的数量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">System.out.println(reentrantLock.getReadLockCount());</span><br></pre></td></tr></table></figure><h4 id="getWaitQueueLength"><a href="#getWaitQueueLength" class="headerlink" title="getWaitQueueLength"></a>getWaitQueueLength</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//getWaitQueueLength</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1.返回与写入锁相关联的给定条件等待的线程数的估计</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">System.out.println(reentrantLock.getWaitQueueLength(<span class="keyword">null</span>));</span><br></pre></td></tr></table></figure><h4 id="getWriteHoldCount"><a href="#getWriteHoldCount" class="headerlink" title="getWriteHoldCount"></a>getWriteHoldCount</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//getWriteHoldCount</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1.查询当前线程对此锁的可重入写入数量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">System.out.println(reentrantLock.getWriteHoldCount());</span><br></pre></td></tr></table></figure><h4 id="hasQueuedThread"><a href="#hasQueuedThread" class="headerlink" title="hasQueuedThread"></a>hasQueuedThread</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//hasQueuedThread</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1.查询给定线程是否等待获取读取或写入锁定</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">System.out.println(reentrantLock.hasQueuedThread(Thread.currentThread()));</span><br></pre></td></tr></table></figure><h4 id="hasQueuedThreads"><a href="#hasQueuedThreads" class="headerlink" title="hasQueuedThreads"></a>hasQueuedThreads</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//hasQueuedThreads</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1.查询是否有任何线程正在等待获取读取或写入锁定</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">System.out.println(reentrantLock.hasQueuedThreads());</span><br></pre></td></tr></table></figure><h4 id="hasWaiters"><a href="#hasWaiters" class="headerlink" title="hasWaiters"></a>hasWaiters</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//hasWaiters</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1.查询任何线程是否等待与写锁相关联的给定条件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">System.out.println(reentrantLock.hasWaiters(<span class="keyword">null</span>));</span><br></pre></td></tr></table></figure><h4 id="isFair"><a href="#isFair" class="headerlink" title="isFair"></a>isFair</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//isFair</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1.如果此锁的公平设置为true，则返回 true</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">System.out.println(reentrantLock.isFair());</span><br></pre></td></tr></table></figure><h4 id="isWriteLocked"><a href="#isWriteLocked" class="headerlink" title="isWriteLocked"></a>isWriteLocked</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//isWriteLocked</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1.查询写锁是否由任何线程持有</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">System.out.println(reentrantLock.isWriteLocked());</span><br></pre></td></tr></table></figure><h4 id="isWriteLockedByCurrentThread"><a href="#isWriteLockedByCurrentThread" class="headerlink" title="isWriteLockedByCurrentThread"></a>isWriteLockedByCurrentThread</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//isWriteLockedByCurrentThread</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1.查询写锁是否由当前线程持有</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">System.out.println(reentrantLock.isWriteLockedByCurrentThread());</span><br></pre></td></tr></table></figure><h4 id="readLock"><a href="#readLock" class="headerlink" title="readLock"></a>readLock</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//readLock</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1.返回用于阅读的锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">System.out.println(reentrantLock.readLock());</span><br></pre></td></tr></table></figure><h4 id="writeLock"><a href="#writeLock" class="headerlink" title="writeLock"></a>writeLock</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//writeLock</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1.返回用于写入的锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">System.out.println(reentrantLock.writeLock());</span><br></pre></td></tr></table></figure><h2 id="部分源码解析"><a href="#部分源码解析" class="headerlink" title="部分源码解析"></a>部分源码解析</h2><p><img src="/image/hexo/image-20200713213045415.png" alt="image-20200713213045415"></p><h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读取锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock.ReadLock readerLock;</span><br><span class="line"><span class="comment">//写入</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock.WriteLock writerLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Sync sync;</span><br></pre></td></tr></table></figure><h3 id="WriteLock-lock"><a href="#WriteLock-lock" class="headerlink" title="WriteLock#lock"></a>WriteLock#lock</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;可以发现从这时开始以及是基于<strong>ReentrantLock</strong>的范畴了。所以针对<strong>ReentrantReadWriteLock</strong>就不在重复的再去分析了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/image/hexo/image-20200713202103876.png&quot; alt=&quot;image-20200713202103876&quot;&gt;&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;&lt;strong&gt;ReentrantReadWriteLock&lt;/stro
      
    
    </summary>
    
    
      <category term="JAVA" scheme="https://blog.huhdcc.top/categories/JAVA/"/>
    
      <category term="多线程" scheme="https://blog.huhdcc.top/categories/JAVA/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="JAVA" scheme="https://blog.huhdcc.top/tags/JAVA/"/>
    
      <category term="多线程" scheme="https://blog.huhdcc.top/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="源码深入" scheme="https://blog.huhdcc.top/tags/%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>多线程高阶-48-ReentrantLock详解</title>
    <link href="https://blog.huhdcc.top/2020/07/12/29479/hub/"/>
    <id>https://blog.huhdcc.top/2020/07/12/29479/hub/</id>
    <published>2020-07-12T06:03:40.000Z</published>
    <updated>2020-07-12T14:40:13.673Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/image/hexo/image-20200712140726035.png" alt="image-20200712140726035"></p><p>&emsp;&emsp;<strong>ReentrantLock</strong>是一种<strong>可重入</strong>的<strong>独占锁</strong>，实现了<strong>Lock</strong>接口。</p><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><h3 id="案例一（常规争夺锁）"><a href="#案例一（常规争夺锁）" class="headerlink" title="案例一（常规争夺锁）"></a>案例一（常规争夺锁）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                reentrantLock.lock();</span><br><span class="line">                System.out.println(<span class="string">"A get lock."</span>);</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                reentrantLock.unlock();</span><br><span class="line">                System.out.println(<span class="string">"A unlock."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,<span class="string">"A"</span>).start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                reentrantLock.lock();</span><br><span class="line">                System.out.println(<span class="string">"B get lock."</span>);</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                reentrantLock.unlock();</span><br><span class="line">                System.out.println(<span class="string">"B unlock."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,<span class="string">"B"</span>).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="案例二（争抢锁打断线程）"><a href="#案例二（争抢锁打断线程）" class="headerlink" title="案例二（争抢锁打断线程）"></a>案例二（争抢锁打断线程）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                reentrantLock.lock();</span><br><span class="line">                System.out.println(<span class="string">"A get lock."</span>);</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                reentrantLock.unlock();</span><br><span class="line">                System.out.println(<span class="string">"A unlock."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,<span class="string">"A"</span>).start();</span><br><span class="line"></span><br><span class="line">    Thread threadB = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                reentrantLock.lockInterruptibly();</span><br><span class="line">                System.out.println(<span class="string">"B get lock."</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                reentrantLock.unlock();</span><br><span class="line">                System.out.println(<span class="string">"B unlock."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">"B"</span>);</span><br><span class="line">    threadB.start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    threadB.interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ReentrantLock相关API"><a href="#ReentrantLock相关API" class="headerlink" title="ReentrantLock相关API"></a>ReentrantLock相关API</h3><h3 id="类声明"><a href="#类声明" class="headerlink" title="类声明"></a>类声明</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造函数</span></span><br><span class="line">ReentrantLock reentrant1 = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="comment">//可以设置公平策略</span></span><br><span class="line">ReentrantLock reentrant2 = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h4 id="getHoldCount"><a href="#getHoldCount" class="headerlink" title="getHoldCount"></a>getHoldCount</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//getHoldCount</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1.查询当前线程保持此锁定的个数(调用lock()方法的次数)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">reentrantLock.getHoldCount();</span><br></pre></td></tr></table></figure><h4 id="getQueueLength"><a href="#getQueueLength" class="headerlink" title="getQueueLength"></a>getQueueLength</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//getQueueLength</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1.获取正等待获取此锁定的线程数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">System.out.println(reentrantLock.getQueueLength());</span><br></pre></td></tr></table></figure><h4 id="hasQueuedThread"><a href="#hasQueuedThread" class="headerlink" title="hasQueuedThread"></a>hasQueuedThread</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//hasQueuedThread</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1.判断线程是否处于等待队列之中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">System.out.println(reentrantLock.hasQueuedThread(Thread.currentThread()));</span><br></pre></td></tr></table></figure><h4 id="hasQueuedThreads"><a href="#hasQueuedThreads" class="headerlink" title="hasQueuedThreads"></a>hasQueuedThreads</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//hasQueuedThreads</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1.判断是否有线程处于等待队列之中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">System.out.println(reentrantLock.hasQueuedThreads());</span><br></pre></td></tr></table></figure><h4 id="hasWaiters"><a href="#hasWaiters" class="headerlink" title="hasWaiters"></a>hasWaiters</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//hasWaiters</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1.查询是否有线程正在等待与此锁定有关的Condition条件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">System.out.println(reentrantLock.hasWaiters(<span class="keyword">null</span>));</span><br></pre></td></tr></table></figure><h4 id="isFair"><a href="#isFair" class="headerlink" title="isFair"></a>isFair</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//isFair</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1.判断锁策略公平锁还是非公平锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">System.out.println(reentrantLock.isFair());</span><br></pre></td></tr></table></figure><h4 id="isHeldByCurrentThread"><a href="#isHeldByCurrentThread" class="headerlink" title="isHeldByCurrentThread"></a>isHeldByCurrentThread</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//isHeldByCurrentThread</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1.查询当前线程是否保持此锁定</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">System.out.println(reentrantLock.isHeldByCurrentThread());</span><br></pre></td></tr></table></figure><h4 id="isLocked"><a href="#isLocked" class="headerlink" title="isLocked"></a>isLocked</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//isLocked</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1.查询此锁定是否由任意线程保持</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">System.out.println(reentrantLock.isLocked());</span><br></pre></td></tr></table></figure><h4 id="lock-amp-unlock"><a href="#lock-amp-unlock" class="headerlink" title="lock &amp; unlock"></a>lock &amp; unlock</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//lock &amp; unlock</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1.获取锁</span></span><br><span class="line"><span class="comment"> * 2.释放锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    reentrantLock.lock();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    reentrantLock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="lockInterruptibly"><a href="#lockInterruptibly" class="headerlink" title="lockInterruptibly"></a>lockInterruptibly</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//lockInterruptibly</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1.线程在请求lock并被阻塞时，如果被interrupt，则此线程会被唤醒并被要求处理InterruptedException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    reentrantLock.lockInterruptibly();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="newCondition"><a href="#newCondition" class="headerlink" title="newCondition"></a>newCondition</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//newCondition</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1.创建一个新的Condition实例。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">System.out.println(reentrantLock.newCondition());</span><br></pre></td></tr></table></figure><h4 id="tryLock"><a href="#tryLock" class="headerlink" title="tryLock"></a>tryLock</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//tryLock</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1.尝试获取锁，如果获取成功，则返回true，如果获取失败（即锁已被其他线程获取），则返回false</span></span><br><span class="line"><span class="comment"> * 2。支持设置超时时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">System.out.println(reentrantLock.tryLock());</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    System.out.println(reentrantLock.tryLock(<span class="number">10</span>, TimeUnit.MILLISECONDS));</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="执行策略"><a href="#执行策略" class="headerlink" title="执行策略"></a>执行策略</h3><p>&emsp;&emsp;1.公平策略:多线程争抢锁的情况下，公平策略更加的倾向于等待时间最长的显示，先来后到的原则。</p><p>&emsp;&emsp;2.非公平策略:多线程争抢锁的情况下，线程获取锁资源是随机的。</p><h2 id="AbstractQueuedSynchronizer相关"><a href="#AbstractQueuedSynchronizer相关" class="headerlink" title="AbstractQueuedSynchronizer相关"></a>AbstractQueuedSynchronizer相关</h2><h3 id="同步等待队列"><a href="#同步等待队列" class="headerlink" title="同步等待队列"></a>同步等待队列</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指向队列首元素的头指针</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指向队列尾元素的尾指针</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指向前一个结点的指针</span></span><br><span class="line"><span class="keyword">volatile</span> Node prev; </span><br><span class="line"><span class="comment">//指向后一个结点的指针</span></span><br><span class="line"><span class="keyword">volatile</span> Node next; </span><br><span class="line"><span class="comment">//当前结点代表的线程</span></span><br><span class="line"><span class="comment">//因为同步队列中的节点封装了之前的竞争锁失败的线程，所有内部必定存在一个对应的实例对象</span></span><br><span class="line"><span class="keyword">volatile</span> Thread thread; </span><br><span class="line"><span class="comment">//等待状态</span></span><br><span class="line"><span class="comment">//0:初始化状态 </span></span><br><span class="line"><span class="comment">//-1:当前节点表示的线程在释放锁后需要唤醒后续节点的线程</span></span><br><span class="line"><span class="comment">//1:在同步队列中等待的线程等待超时或者被中断、取消继续等待</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br></pre></td></tr></table></figure><p><img src="/image/hexo/image-20200712201348426.png" alt="image-20200712201348426"></p><p>&emsp;&emsp;1.同步队列是一个先进先出（FIFO）队列。</p><p>&emsp;&emsp;2.获取锁失败的线程：构造节点并且加入队列尾部，阻塞自己。</p><p>&emsp;&emsp;3.队列首节点可以用来表示当前正在获取的线程。</p><p>&emsp;&emsp;4.当前线程释放锁后：尝试唤醒后续节点处于阻塞状态的线程。</p><h3 id="同步状态变量"><a href="#同步状态变量" class="headerlink" title="同步状态变量"></a>同步状态变量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The synchronization state.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;1.它的作用类似计数器，在<strong>ReentrantLock</strong>中主要表示该锁被线程重入的次数。</p><p>&emsp;&emsp;2.<strong>state:0</strong>：表示该锁不被任何线程持有。</p><p>&emsp;&emsp;3.<strong>state:&gt;=1</strong>：表示该锁被线程重入<strong>state</strong>次。</p><p>&emsp;&emsp;4.由于多线程高并发的原因，为了保证数据的可见性这里采用<strong>volatile</strong>去实现。 </p><h3 id="持有同步线程的标记"><a href="#持有同步线程的标记" class="headerlink" title="持有同步线程的标记"></a>持有同步线程的标记</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The current owner of exclusive mode synchronization.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Thread exclusiveOwnerThread;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;1.在独占同步模式下标记持有的同步状态线程。</p><p>&emsp;&emsp;2.在<strong>ReentrantLock</strong>锁中，主要用于标记锁被具体哪一个线程所持有。</p><h2 id="部分源码解析"><a href="#部分源码解析" class="headerlink" title="部分源码解析"></a>部分源码解析</h2><h3 id="lock-非公平"><a href="#lock-非公平" class="headerlink" title="lock(非公平)"></a>lock(非公平)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.lock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//尝试将state从0更新为1（CAS操作）</span></span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        <span class="comment">//获取锁成功后将当前线程标记为持有锁的线程</span></span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//获取锁失败</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//当前线程企图获取所资源</span></span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp; </span><br><span class="line">        <span class="comment">//锁争夺失败进入该逻辑</span></span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="tryAcquire"><a href="#tryAcquire" class="headerlink" title="tryAcquire"></a>tryAcquire</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取当前线程</span></span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="comment">//获取state变量</span></span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="comment">//如果state==0、表示当前锁没有被任何的线程持有</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//CAS方式尝试获取锁资源</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            <span class="comment">//标记当前线程为持有锁的线程</span></span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="comment">//非重入获取锁资源</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断当前线程是否已经持有了该锁、表示该锁已经开始重入</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="comment">//计算state的更新值</span></span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="comment">//判断是否越界</span></span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        <span class="comment">//设置新的值（非同步）</span></span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取锁失败</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="addWaiter"><a href="#addWaiter" class="headerlink" title="addWaiter"></a>addWaiter</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建一个新的节点Node，设置当前线程实例在内部</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//入队逻辑</span></span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//当前t指向队列的最后一个节点</span></span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="comment">//如果为null</span></span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; </span><br><span class="line">            <span class="comment">//构造一个新的节点，CAS方式去设置队列首元素</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                <span class="comment">//队尾指针指向了首节点</span></span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//队列不为null的情况</span></span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="comment">//CAS将队尾指针指向当前节点</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                <span class="comment">//原队尾节点的next指针指向当前节点</span></span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/image/hexo/image-20200712214119877.png" alt="image-20200712214119877"></p><p><img src="/image/hexo/image-20200712214136785.png" alt="image-20200712214136785"></p><p><img src="/image/hexo/image-20200712214334164.png" alt="image-20200712214334164"></p><h3 id="unlock-非公平"><a href="#unlock-非公平" class="headerlink" title="unlock(非公平)"></a>unlock(非公平)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//释放锁,对应state-1</span></span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="comment">//当前队列不为空并且头部节点状态不是初始化状态</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//唤醒同步队列中被阻塞的线程</span></span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//计算所需要更新的state的数值</span></span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">    <span class="comment">//判断当前线程是否获取到了锁</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="comment">//没有拥有该锁则会抛出异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//如果c == 0,那么持有该锁的线程没有重入</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        free = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//清除锁持有线程的标记</span></span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//更新state</span></span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//唤醒同步队列中阻塞的线程</span></span><br><span class="line"><span class="comment">//一般只需要唤醒后继节点即可</span></span><br><span class="line"><span class="comment">//但是后续节点可能已经取消了等待,那么从队列尾部往前回溯尝试唤醒阻塞的线程</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If status is negative (i.e., possibly needing signal) try</span></span><br><span class="line"><span class="comment">     * to clear in anticipation of signalling.  It is OK if this</span></span><br><span class="line"><span class="comment">     * fails or if status is changed by waiting thread.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Thread to unpark is held in successor, which is normally</span></span><br><span class="line"><span class="comment">     * just the next node.  But if cancelled or apparently null,</span></span><br><span class="line"><span class="comment">     * traverse backwards from tail to find the actual</span></span><br><span class="line"><span class="comment">     * non-cancelled successor.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/image/hexo/image-20200712215100773.png" alt="image-20200712215100773"></p><h3 id="lock-公平"><a href="#lock-公平" class="headerlink" title="lock(公平)"></a>lock(公平)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.lock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//在执行CAS前新增了hasQueuedPredecessors判断</span></span><br><span class="line">            <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//主要用于判断队列之中是否还存在优先级更高的等待线程</span></span><br><span class="line"><span class="comment">//需要注意的是头部的线程表示当前线程，那么第二个节点表示整个队列中优先级最高的线程</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// The correctness of this depends on head being initialized</span></span><br><span class="line">    <span class="comment">// before tail and on head.next being accurate if the current</span></span><br><span class="line">    <span class="comment">// thread is first in queue.</span></span><br><span class="line">    Node t = tail; <span class="comment">// Read fields in reverse initialization order</span></span><br><span class="line">    Node h = head;</span><br><span class="line">    Node s;</span><br><span class="line">    <span class="keyword">return</span> h != t &amp;&amp;</span><br><span class="line">        ((s = h.next) == <span class="keyword">null</span> || s.thread != Thread.currentThread());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;1.第二个节点已经完全插入，但是为知该节点是否为当前节点，那么可以通过<strong>s.thread != Thread.currentThread()</strong>判断，<code>true</code>表示该节点代表的是其他线程。</p><p>&emsp;&emsp;2.第二个节点没有完全的插入。（1.待插入的节点pre指针指向队尾。2.CAS更新队尾指针。3.原队尾节点的next指针指向新插入节点。）<strong>(s = h.next) == null</strong>主要用于处理<strong>2-&gt;3</strong>这种阶段的情况。</p><h3 id="acquireQueued"><a href="#acquireQueued" class="headerlink" title="acquireQueued"></a>acquireQueued</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//死循环,正常情况下线程只有获得锁才能跳出循环</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">//获得当前线程所在结点的前驱结点</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">//第一个if分句</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123; </span><br><span class="line">                <span class="comment">//将当前结点设置为队列头结点</span></span><br><span class="line">                setHead(node); </span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="comment">//正常情况下死循环唯一的出口</span></span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//判断是否要阻塞当前线程</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;  </span><br><span class="line">                <span class="comment">//阻塞当前线程</span></span><br><span class="line">                parkAndCheckInterrupt())      </span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="几点疑问"><a href="#几点疑问" class="headerlink" title="几点疑问"></a>几点疑问</h2><h3 id="FIFO同步队列怎么实现非公平锁"><a href="#FIFO同步队列怎么实现非公平锁" class="headerlink" title="FIFO同步队列怎么实现非公平锁"></a>FIFO同步队列怎么实现非公平锁</h3><p>&emsp;&emsp;1.FIFO特性：先加入同步队列等待的线程更加靠近队列头部，也就能够更早的获取到锁。先进先出的顺序在这个意义上来讲保证了公平性。</p><p>&emsp;&emsp;2.实际上并非只有加入线程等待队列才有机会获得锁，尽管线程同步队列已经有线程处于等待状态，这也是非公平模式的意义所在。在线程进入线程同步队列之前有两次抢占锁的机会。</p><p>&emsp;&emsp;3.第一次：非重入获取锁资源，只有当前锁没有被任何线程持有（包含自身）。</p><p>&emsp;&emsp;4.第二次：在进入线程等待队列前，包含了所有情况获取锁的方式。</p><p>&emsp;&emsp;5.如果两次获取锁失败，线程就会进行构造新的节点加入线程等待队列之中。释放锁的时候先修改<strong>state</strong>再唤醒其后继节点中处于等待的线程。</p><p>&emsp;&emsp;6.在<code>5</code>中也会有以下情况发生：若是线程A已经释放了锁，但是还没有来得及唤醒后继节点中的线程C，那么此刻线程B刚好尝试获取锁，并且锁由于线程A的释放导致它不被任何线程持有，那么线程C则会继续陷入等待中，这也是非公平的一个体现。</p><h3 id="非公平锁的性能体现"><a href="#非公平锁的性能体现" class="headerlink" title="非公平锁的性能体现"></a>非公平锁的性能体现</h3><p>&emsp;&emsp;1.非公平模式的极具抢占性，线程在入队之前拥有两次机会去尝试获取锁，极大的提高了获取锁的机率。</p><p>&emsp;&emsp;2.由于在未入队之前可以有机会抢占锁，那么在一定程度上减少了构造队列节点等繁琐的操作，也减少了唤醒后继节点等待线程的所带来的性能开销（主要涉及线程上下文的切换和操作系统的调用，是非常耗费资源的）。</p><p>&emsp;&emsp;3.由于入队时会产生<strong>CAS</strong>竞争，如果在入队才能获取锁，此处的<strong>CAS</strong>竞争将会异常的激烈，由于<strong>CAS</strong>带来的不断重试也会带来一定的性能开销。并且获取锁时将非重入的情况提前处理，还有在入队操作的时候，针对队列为空的情况进行了提前处理。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/image/hexo/image-20200712140726035.png&quot; alt=&quot;image-20200712140726035&quot;&gt;&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;&lt;strong&gt;ReentrantLock&lt;/strong&gt;是一种&lt;st
      
    
    </summary>
    
    
      <category term="JAVA" scheme="https://blog.huhdcc.top/categories/JAVA/"/>
    
      <category term="多线程" scheme="https://blog.huhdcc.top/categories/JAVA/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="JAVA" scheme="https://blog.huhdcc.top/tags/JAVA/"/>
    
      <category term="多线程" scheme="https://blog.huhdcc.top/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="源码深入" scheme="https://blog.huhdcc.top/tags/%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>多线程高阶-47-Semaphore详解</title>
    <link href="https://blog.huhdcc.top/2020/07/12/40954/hub/"/>
    <id>https://blog.huhdcc.top/2020/07/12/40954/hub/</id>
    <published>2020-07-12T00:13:47.000Z</published>
    <updated>2020-07-12T06:04:12.991Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/image/hexo/image-20200712084643728.png" alt="image-20200712084643728"></p><p>&emsp;&emsp;<strong>Semaphore</strong>(信号量),它的作用类似于“许可证”，它维护了一个许可集。当有线程想要去访问共享资源的时候，就必须要获取到一个“许可”证明，若是“许可”证明已经发放完毕，那么该线程就将陷入等待，直到“许可”证明可用才会继续访问，当一个线程访问结束后，可以归还这个“许可”凭证，再次提供给其他线程使用。</p><p>&emsp;&emsp;<strong>Semaphore</strong>也时支持公平/非公平的策略。</p><h2 id="定义一个显示锁"><a href="#定义一个显示锁" class="headerlink" title="定义一个显示锁"></a>定义一个显示锁</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SemaphoreLock lock = <span class="keyword">new</span> SemaphoreLock();</span><br><span class="line">    IntStream.range(<span class="number">0</span>,<span class="number">2</span>).forEach(i-&gt;&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" is Running."</span>);</span><br><span class="line">                lock.lock();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" get Lock."</span>);</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" unlock."</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个显示锁</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreLock</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//整个锁完全时依赖于semaphore许可证的数量</span></span><br><span class="line">    <span class="keyword">private</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        semaphore.acquire();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        semaphore.release();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Semaphore相关API"><a href="#Semaphore相关API" class="headerlink" title="Semaphore相关API"></a>Semaphore相关API</h2><h3 id="类声明"><a href="#类声明" class="headerlink" title="类声明"></a>类声明</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Semaphore</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//公平策略</span></span><br><span class="line"><span class="keyword">private</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">1</span>,<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h4 id="acquire"><a href="#acquire" class="headerlink" title="acquire"></a>acquire</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//acquire</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1.获取许可证</span></span><br><span class="line"><span class="comment"> * 2.获取指定数量的许可证</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">semaphore.acquire();</span><br><span class="line">semaphore.acquire(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><h4 id="release"><a href="#release" class="headerlink" title="release"></a>release</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//release</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1.释放许可证</span></span><br><span class="line"><span class="comment"> * 2.释放前必须先获得</span></span><br><span class="line"><span class="comment"> * 3.释放指定数量的许可证</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">semaphore.release();</span><br><span class="line">semaphore.release(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><h4 id="tryAcquire"><a href="#tryAcquire" class="headerlink" title="tryAcquire"></a>tryAcquire</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//tryAcquire</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1.尝试获取一个许可证</span></span><br><span class="line"><span class="comment"> * 2.成功返回：true,失败返回：false</span></span><br><span class="line"><span class="comment"> * 3.尝试获取多个许可证</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">boolean</span> tryAcquire = semaphore.tryAcquire();</span><br><span class="line">semaphore.tryAcquire(<span class="number">10</span>);</span><br><span class="line"><span class="comment">//尝试获取多个并且具有超时时间</span></span><br><span class="line">semaphore.tryAcquire(<span class="number">10</span>, <span class="number">10</span>, TimeUnit.MILLISECONDS);</span><br><span class="line"><span class="comment">//尝试获取一个并且具有超时时间</span></span><br><span class="line">semaphore.tryAcquire(<span class="number">10</span>, TimeUnit.MILLISECONDS);</span><br></pre></td></tr></table></figure><h4 id="acquireUninterruptibly"><a href="#acquireUninterruptibly" class="headerlink" title="acquireUninterruptibly"></a>acquireUninterruptibly</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//acquireUninterruptibly</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1.从此信号量中获取许可，在有可用的许可前将其阻塞</span></span><br><span class="line"><span class="comment"> * 2.从此信号量获取给定数目的许可，在提供这些许可前一直将线程阻塞</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">semaphore.acquireUninterruptibly();</span><br><span class="line">semaphore.acquireUninterruptibly(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><h4 id="availablePermits"><a href="#availablePermits" class="headerlink" title="availablePermits"></a>availablePermits</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//availablePermits</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1.返回此信号量中当前可用的许可数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">System.out.println(semaphore.availablePermits());</span><br></pre></td></tr></table></figure><h4 id="drainPermits"><a href="#drainPermits" class="headerlink" title="drainPermits"></a>drainPermits</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//drainPermits</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1.获取并返回立即可用的所有许可。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">System.out.println(semaphore.drainPermits());</span><br></pre></td></tr></table></figure><h4 id="getQueueLength"><a href="#getQueueLength" class="headerlink" title="getQueueLength"></a>getQueueLength</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//getQueueLength</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1.返回正在等待获取的线程的估计数目</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">System.out.println(semaphore.getQueueLength());</span><br></pre></td></tr></table></figure><h4 id="hasQueuedThreads"><a href="#hasQueuedThreads" class="headerlink" title="hasQueuedThreads"></a>hasQueuedThreads</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//hasQueuedThreads</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1.查询是否有线程正在等待获取</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">System.out.println(semaphore.hasQueuedThreads());</span><br></pre></td></tr></table></figure><h4 id="isFair"><a href="#isFair" class="headerlink" title="isFair"></a>isFair</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//isFair</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1.如果此信号量的公平设置为 true，则返回 true</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">System.out.println(semaphore.isFair());</span><br></pre></td></tr></table></figure><h2 id="部分源码解析"><a href="#部分源码解析" class="headerlink" title="部分源码解析"></a>部分源码解析</h2><h3 id="内部类Sync"><a href="#内部类Sync" class="headerlink" title="内部类Sync"></a>内部类Sync</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1192457210091910933L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置许可证总数</span></span><br><span class="line">    Sync(<span class="keyword">int</span> permits) &#123;</span><br><span class="line">        setState(permits);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取剩余的许可证总数</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getPermits</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getState();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//主要用于：自旋 CAS非公平获取</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">nonfairTryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//进入自旋</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">//获取剩余的许可证数量</span></span><br><span class="line">            <span class="keyword">int</span> available = getState();</span><br><span class="line">            <span class="comment">//获取本次获取后、还剩余的许可证数量</span></span><br><span class="line">            <span class="keyword">int</span> remaining = available - acquires;</span><br><span class="line">            <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">               <span class="comment">//如果可操作的&gt;=0,那么进行CAS更新许可数量</span></span><br><span class="line">                <span class="comment">//否则许可证获取失败</span></span><br><span class="line">                compareAndSetState(available, remaining))</span><br><span class="line">                <span class="keyword">return</span> remaining;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//主要用于CAS释放许可证</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//进入自旋</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">//获取当前可用的许可证数量</span></span><br><span class="line">            <span class="keyword">int</span> current = getState();</span><br><span class="line">            <span class="comment">//获取当前释放许可证数量更新的数值</span></span><br><span class="line">            <span class="keyword">int</span> next = current + releases;</span><br><span class="line">            <span class="comment">//如果更新值为负数则抛出异常</span></span><br><span class="line">            <span class="keyword">if</span> (next &lt; current) <span class="comment">// overflow</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum permit count exceeded"</span>);</span><br><span class="line">            <span class="comment">//进入CAS更新许可证数量</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(current, next))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//主要用于减少许可证数量</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">reducePermits</span><span class="params">(<span class="keyword">int</span> reductions)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//进入自旋</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">//获取当前剩余的许可证数量</span></span><br><span class="line">            <span class="keyword">int</span> current = getState();</span><br><span class="line">            <span class="comment">//计算需要更新的许可证数量</span></span><br><span class="line">            <span class="keyword">int</span> next = current - reductions;</span><br><span class="line">            <span class="comment">//主要判断reductions是否为负，为负则抛出异常信息</span></span><br><span class="line">            <span class="keyword">if</span> (next &gt; current) <span class="comment">// underflow</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Permit count underflow"</span>);</span><br><span class="line">            <span class="comment">//进行CAS更新许可证数量</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(current, next))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//主要用于丢弃所有的许可证</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">drainPermits</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> current = getState();</span><br><span class="line">            <span class="keyword">if</span> (current == <span class="number">0</span> || compareAndSetState(current, <span class="number">0</span>))</span><br><span class="line">                <span class="keyword">return</span> current;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="非公平模式NonfairSync"><a href="#非公平模式NonfairSync" class="headerlink" title="非公平模式NonfairSync"></a>非公平模式NonfairSync</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">2694183684443567898L</span>;</span><br><span class="line"></span><br><span class="line">    NonfairSync(<span class="keyword">int</span> permits) &#123;</span><br><span class="line">        <span class="keyword">super</span>(permits);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nonfairTryAcquireShared(acquires);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="公平模式FairSync"><a href="#公平模式FairSync" class="headerlink" title="公平模式FairSync"></a>公平模式FairSync</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">2014338818796000944L</span>;</span><br><span class="line"></span><br><span class="line">    FairSync(<span class="keyword">int</span> permits) &#123;</span><br><span class="line">        <span class="keyword">super</span>(permits);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//公平的获取许可证</span></span><br><span class="line">    <span class="comment">//需要判断同步队列中是否有线程在等待，如果有那么获取失败进入阻塞状态</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//进入自旋</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">//如果存在线程在等待那么立即返回</span></span><br><span class="line">            <span class="keyword">if</span> (hasQueuedPredecessors())</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//以CAS的方式去获取许可证</span></span><br><span class="line">            <span class="keyword">int</span> available = getState();</span><br><span class="line">            <span class="keyword">int</span> remaining = available - acquires;</span><br><span class="line">            <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">                compareAndSetState(available, remaining))</span><br><span class="line">                <span class="keyword">return</span> remaining;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="acquire-1"><a href="#acquire-1" class="headerlink" title="acquire"></a>acquire</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="comment">//企图获取许可证，若&lt;0则进入阻塞，否则获取成功</span></span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nonfairTryAcquireShared(acquires);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 剩余许可数量。非负数，获取许可成功，负数，获取许可失败</span></span><br><span class="line"><span class="comment"> * 以CAS+自旋的方式获取</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">nonfairTryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> available = getState();</span><br><span class="line">        <span class="keyword">int</span> remaining = available - acquires;</span><br><span class="line">        <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">            compareAndSetState(available, remaining))</span><br><span class="line">            <span class="keyword">return</span> remaining;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取许可失败，线程进入阻塞状态</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">//主要创建同步队列节点，并且加入队列</span></span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">//如果当前节点是第二个节点，那么尝试获取锁</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//阻塞线程</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="release-1"><a href="#release-1" class="headerlink" title="release"></a>release</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//归还许可</span></span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//释放许可，但是未对释放数量做限制，那么可以通过releases动态的增加许可数量</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//CAS+自旋修改许可数量</span></span><br><span class="line">        <span class="keyword">int</span> current = getState();</span><br><span class="line">        <span class="keyword">int</span> next = current + releases;</span><br><span class="line">        <span class="keyword">if</span> (next &lt; current) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum permit count exceeded"</span>);</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(current, next))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//进入自旋</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                <span class="comment">//唤醒第一个线程</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/image/hexo/image-20200712084643728.png&quot; alt=&quot;image-20200712084643728&quot;&gt;&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;&lt;strong&gt;Semaphore&lt;/strong&gt;(信号量),它的作用
      
    
    </summary>
    
    
      <category term="JAVA" scheme="https://blog.huhdcc.top/categories/JAVA/"/>
    
      <category term="多线程" scheme="https://blog.huhdcc.top/categories/JAVA/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="JAVA" scheme="https://blog.huhdcc.top/tags/JAVA/"/>
    
      <category term="多线程" scheme="https://blog.huhdcc.top/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="源码深入" scheme="https://blog.huhdcc.top/tags/%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>多线程高阶-46-Exchanger详解</title>
    <link href="https://blog.huhdcc.top/2020/07/11/34522/hub/"/>
    <id>https://blog.huhdcc.top/2020/07/11/34522/hub/</id>
    <published>2020-07-11T15:54:55.000Z</published>
    <updated>2020-07-12T06:04:12.979Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/image/hexo/image-20200711235656352.png" alt="image-20200711235656352"></p><p><img src="/image/hexo/image-20200712065745894.png" alt="image-20200712065745894"></p><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><h3 id="String数据交换"><a href="#String数据交换" class="headerlink" title="String数据交换"></a>String数据交换</h3><p>&emsp;&emsp;<strong>Exchanger</strong>中的线程总是成对出现，一个线程总是在成它所成对的线程执行结束，进行数据交换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Exchanger&lt;String&gt; exchanger = <span class="keyword">new</span> Exchanger&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" start."</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String result = exchanger.exchange(<span class="string">"I am come from A"</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" Get value:"</span> + result);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" Thread stop."</span>);</span><br><span class="line">    &#125;,<span class="string">"A"</span>).start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" start."</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String result = exchanger.exchange(<span class="string">"I am come from B"</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" Get value:"</span> + result);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" Thread stop."</span>);</span><br><span class="line">    &#125;,<span class="string">"B"</span>).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对象数据交换线程安全"><a href="#对象数据交换线程安全" class="headerlink" title="对象数据交换线程安全"></a>对象数据交换线程安全</h3><p>&emsp;&emsp;可以发现<strong>Exchanger</strong>交换的数据对象是同一个，那么必然也会存在线程安全问题，使用上也需要注意这一点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Exchanger&lt;Object&gt; exchanger = <span class="keyword">new</span> Exchanger&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        Object aobj = <span class="keyword">new</span> Object();</span><br><span class="line">        System.out.println(<span class="string">"A will be send object:"</span> + aobj);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Object exchange = exchanger.exchange(aobj);</span><br><span class="line">            System.out.println(<span class="string">"A get result object:"</span> + exchange);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;, <span class="string">"A"</span>).start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        Object aobj = <span class="keyword">new</span> Object();</span><br><span class="line">        System.out.println(<span class="string">"B will be send object:"</span> + aobj);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Object exchange = exchanger.exchange(aobj);</span><br><span class="line">            System.out.println(<span class="string">"B get result object:"</span> + exchange);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;, <span class="string">"B"</span>).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复用并且多次交换数据"><a href="#复用并且多次交换数据" class="headerlink" title="复用并且多次交换数据"></a>复用并且多次交换数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Exchanger&lt;Integer&gt; exchanger = <span class="keyword">new</span> Exchanger&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        AtomicInteger integer = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Integer exchange = exchanger.exchange(integer.get());</span><br><span class="line">                System.out.println(<span class="string">"A send value:"</span> + integer.get());</span><br><span class="line">                integer.set(exchange);</span><br><span class="line">                System.out.println(<span class="string">"A get value:"</span> + integer.get());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">"A"</span>).start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        AtomicInteger integer = <span class="keyword">new</span> AtomicInteger(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Integer exchange = exchanger.exchange(integer.get());</span><br><span class="line">                System.out.println(<span class="string">"B send value:"</span> + integer.get());</span><br><span class="line">                integer.set(exchange);</span><br><span class="line">                System.out.println(<span class="string">"B get value:"</span> + integer.get());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">"B"</span>).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Exchanger相关API"><a href="#Exchanger相关API" class="headerlink" title="Exchanger相关API"></a>Exchanger相关API</h2><h3 id="类声明"><a href="#类声明" class="headerlink" title="类声明"></a>类声明</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exchanger</span>&lt;<span class="title">V</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exchanger&lt;String&gt; exchanger = <span class="keyword">new</span> Exchanger&lt;&gt;();</span><br></pre></td></tr></table></figure><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h4 id="exchange"><a href="#exchange" class="headerlink" title="exchange"></a>exchange</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//成对的线程间进行数据交换</span></span><br><span class="line">exchanger.exchange(<span class="string">"I am come from A"</span>);</span><br></pre></td></tr></table></figure><h2 id="部分源码解析"><a href="#部分源码解析" class="headerlink" title="部分源码解析"></a>部分源码解析</h2><p><img src="/image/hexo/image-20200712081523157.png!%5Bimage-20200712081542341%5D(/image/hexo/image-20200712081542341.png" alt="image-20200712081523157"></p><h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ThreadLocal变量，每个线程都有自己的一个副本</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Participant participant;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//高并发下使用的，保存待匹配的Node实例</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> Node[] arena;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//低并发下，arena未初始化时使用的保存待匹配的Node实例</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> Node slot;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始值为0，当创建arena后会被赋值成SEQ，用来记录arena数组的可用最大索引，会随着并发的增大而增大直到等于最大值FULL，会随着并行的线程逐一匹配成功而减少恢复成初始值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> bound;</span><br></pre></td></tr></table></figure><h3 id="静态常量"><a href="#静态常量" class="headerlink" title="静态常量"></a>静态常量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化arena时使用，1 &lt;&lt; ASHIFT是一个缓存行的大小，避免不同的Node落入到同一个高速缓存行</span></span><br><span class="line"><span class="comment">// 这里实际是把数组容量扩大了8倍，原来索引相邻的两个元素，扩容后中间隔了7个元素，从元素的起始地址上看就隔了8个元素，中间的7个都是空的，为了避免原来相邻的两个元素落到同一个缓存行中</span></span><br><span class="line"><span class="comment">//因为arena是对象数组，一个元素占8字节，8个就是64字节</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ASHIFT = <span class="number">7</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//arena数组元素的索引最大值即255</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MMASK = <span class="number">0xff</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//arena数组的最大长度即256</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SEQ = MMASK + <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//获取CPU核数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NCPU = Runtime.getRuntime().availableProcessors();</span><br><span class="line"> </span><br><span class="line"><span class="comment">//实际的数组长度，因为是线程两两配对的，所以最大长度是核数除以2</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FULL = (NCPU &gt;= (MMASK &lt;&lt; <span class="number">1</span>)) ? MMASK : NCPU &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//自旋等待的次数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SPINS = <span class="number">1</span> &lt;&lt; <span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//如果交换的对象是null，则返回此对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object NULL_ITEM = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果等待超时导致交换失败，则返回此对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object TIMED_OUT = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure><h3 id="exchange-1"><a href="#exchange-1" class="headerlink" title="exchange"></a>exchange</h3><p>&emsp;&emsp;1.低并发下：<code>arena</code>未初始化的时候使用<strong>slotExchange</strong>进行了数据交换。<code>arena</code>初始化后或者<strong>slotExchange</strong>因为并发原因导致数据交互失败，那么采用<strong>arenaExchange</strong>进行数据交换。</p><p>&emsp;&emsp;2.针对传入的对象若是==null，那么针对入参与出参都会将其转换<strong>NULL_ITEM</strong>,主要为了区分交换失败。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">exchange</span><span class="params">(V x)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Object v;</span><br><span class="line">    Object item = (x == <span class="keyword">null</span>) ? NULL_ITEM : x; <span class="comment">// translate null args</span></span><br><span class="line">    <span class="keyword">if</span> ((arena != <span class="keyword">null</span> ||</span><br><span class="line">         <span class="comment">//arena为null的情形下执行slotExchange</span></span><br><span class="line">         (v = slotExchange(item, <span class="keyword">false</span>, <span class="number">0L</span>)) == <span class="keyword">null</span>) &amp;&amp;</span><br><span class="line">        <span class="comment">//若线程被打断则抛出异常</span></span><br><span class="line">        ((Thread.interrupted() || <span class="comment">// disambiguates null return</span></span><br><span class="line">          <span class="comment">//arenaExchange失败、因为没有设置超时时间，那么肯定线程已经被中断抛出异常</span></span><br><span class="line">          (v = arenaExchange(item, <span class="keyword">false</span>, <span class="number">0L</span>)) == <span class="keyword">null</span>)))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">return</span> (v == NULL_ITEM) ? <span class="keyword">null</span> : (V)v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//增加了等待的超时时间</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">exchange</span><span class="params">(V x, <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException, TimeoutException </span>&#123;</span><br><span class="line">    Object v;</span><br><span class="line">    Object item = (x == <span class="keyword">null</span>) ? NULL_ITEM : x;</span><br><span class="line">    <span class="keyword">long</span> ns = unit.toNanos(timeout);</span><br><span class="line">    <span class="keyword">if</span> ((arena != <span class="keyword">null</span> ||</span><br><span class="line">         (v = slotExchange(item, <span class="keyword">true</span>, ns)) == <span class="keyword">null</span>) &amp;&amp;</span><br><span class="line">        ((Thread.interrupted() ||</span><br><span class="line">          (v = arenaExchange(item, <span class="keyword">true</span>, ns)) == <span class="keyword">null</span>)))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="comment">//如果超时，那么抛出超时异常</span></span><br><span class="line">    <span class="keyword">if</span> (v == TIMED_OUT)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</span><br><span class="line">    <span class="keyword">return</span> (v == NULL_ITEM) ? <span class="keyword">null</span> : (V)v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;1.<strong>slotExchange</strong>主要是使用<code>slot</code>去进行数据交换的</p><p>&emsp;&emsp;2.<code>slot</code>若是为null，当前线程则将<code>slot</code>修改为当前线程的<code>Node</code>，修改失败则进入下一次循环，进 入<code>slot</code>不为null。修改成功则进入自旋，达到一定的自旋次数后使当前线程休眠（超时特性也在这里进行了指定）。当线程被唤醒的时候都会去检测<code>Node</code>的<code>match</code>属性，不为null的时候表示数据交互成功，否则返回<strong>TIMED_OUT</strong>或者<strong>NULL</strong>，然后清除数据并且保存自旋的<strong>hash</strong>值。</p><p>&emsp;&emsp;3.<code>slot</code>若是不为null,当前线程企图将其修改为null。<strong>cas</strong>修改成功，表示当前线程的<code>slot</code>的属性匹配当前线程成功，保存数据，处理休眠状态的线程，交互流程结束。<strong>cas</strong>修改失败，说明有其他线程也在抢占<code>slot</code>，导致进入下一次循环，如果<code>arena</code>不为null，则进入<strong>arenaExchange</strong>执行数据交互。</p><p><img src="/image/hexo/image-20200712081638127.png" alt="image-20200712081638127"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *1.如果arena为null，则执行本方法</span></span><br><span class="line"><span class="comment"> *2.返回值为null则表示数据交换失败</span></span><br><span class="line"><span class="comment"> *3.item是交换的对象，timed：false表示不设置超时</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> Object <span class="title">slotExchange</span><span class="params">(Object item, <span class="keyword">boolean</span> timed, <span class="keyword">long</span> ns)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取当前线程所对应的Node</span></span><br><span class="line">    Node p = participant.get();</span><br><span class="line">    <span class="comment">//获取当前线程</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">//如果线程已经被打断了那么此次数据交换失败</span></span><br><span class="line">    <span class="keyword">if</span> (t.isInterrupted()) <span class="comment">// preserve interrupt status so caller can recheck</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">for</span> (Node q;;) &#123;</span><br><span class="line">        <span class="comment">//slot不为null</span></span><br><span class="line">        <span class="keyword">if</span> ((q = slot) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//slot设置为null，slot对应的线程与当前线程匹配成功</span></span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapObject(<span class="keyword">this</span>, SLOT, q, <span class="keyword">null</span>)) &#123;</span><br><span class="line">                Object v = q.item;</span><br><span class="line">                <span class="comment">//保存item数据、标识数据交互完成</span></span><br><span class="line">                q.match = item;</span><br><span class="line">                <span class="comment">//唤醒q对应的处于等待的线程</span></span><br><span class="line">                Thread w = q.parked;</span><br><span class="line">                <span class="keyword">if</span> (w != <span class="keyword">null</span>)</span><br><span class="line">                    U.unpark(w);</span><br><span class="line">                <span class="keyword">return</span> v;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//slot修改失败</span></span><br><span class="line">            <span class="comment">//多个线程同时调用了exchange方法</span></span><br><span class="line">            <span class="comment">//bound == 0表示为初始化，目的：避免重复进行初始化操作</span></span><br><span class="line">            <span class="keyword">if</span> (NCPU &gt; <span class="number">1</span> &amp;&amp; bound == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                <span class="comment">//BOUND修改成SEQ</span></span><br><span class="line">                U.compareAndSwapInt(<span class="keyword">this</span>, BOUND, <span class="number">0</span>, SEQ))</span><br><span class="line">                <span class="comment">//初始化：创建数组</span></span><br><span class="line">                <span class="comment">//下一次for循环就因为arena不为null，返回null了</span></span><br><span class="line">                arena = <span class="keyword">new</span> Node[(FULL + <span class="number">2</span>) &lt;&lt; ASHIFT];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (arena != <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">//arena不为null，使用arenaExchange交换数据</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//slot、arena同时为null</span></span><br><span class="line">            p.item = item;</span><br><span class="line">            <span class="comment">//修改slot为p，修改成功则终止循环</span></span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapObject(<span class="keyword">this</span>, SLOT, <span class="keyword">null</span>, p))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//修改失败则继续进行循环，将item恢复为null</span></span><br><span class="line">            p.item = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//修改slot为p成功后执行下面的逻辑,hash初始为0</span></span><br><span class="line">    <span class="keyword">int</span> h = p.hash;</span><br><span class="line">    <span class="keyword">long</span> end = timed ? System.nanoTime() + ns : <span class="number">0L</span>;</span><br><span class="line">    <span class="keyword">int</span> spins = (NCPU &gt; <span class="number">1</span>) ? SPINS : <span class="number">1</span>;</span><br><span class="line">    Object v;</span><br><span class="line">    <span class="comment">//match保存这同其他线程交换的对象，如果不为null,则表示数据交互成功</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//进入自旋</span></span><br><span class="line">    <span class="keyword">while</span> ((v = p.match) == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (spins &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            h ^= h &lt;&lt; <span class="number">1</span>; h ^= h &gt;&gt;&gt; <span class="number">3</span>; h ^= h &lt;&lt; <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span> (h == <span class="number">0</span>)</span><br><span class="line">                <span class="comment">//初始化h</span></span><br><span class="line">                h = SPINS | (<span class="keyword">int</span>)t.getId(); </span><br><span class="line">            <span class="comment">//只有h小于0才会减少spins</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (h &lt; <span class="number">0</span> &amp;&amp; (--spins &amp; ((SPINS &gt;&gt;&gt; <span class="number">1</span>) - <span class="number">1</span>)) == <span class="number">0</span>)</span><br><span class="line">                Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果slot已经匹配到了其他线程（被修改），重新自旋，</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (slot != p)</span><br><span class="line">            spins = SPINS;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!t.isInterrupted() &amp;&amp; arena == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                 <span class="comment">//线程没有被中断且arena为null</span></span><br><span class="line">                 <span class="comment">//需要等待</span></span><br><span class="line">                 (!timed || (ns = end - System.nanoTime()) &gt; <span class="number">0L</span>)) &#123;</span><br><span class="line">            U.putObject(t, BLOCKER, <span class="keyword">this</span>);</span><br><span class="line">            p.parked = t;</span><br><span class="line">            <span class="keyword">if</span> (slot == p)</span><br><span class="line">                U.park(<span class="keyword">false</span>, ns);</span><br><span class="line">            <span class="comment">//唤醒线程、执行下一次循环</span></span><br><span class="line">            </span><br><span class="line">            p.parked = <span class="keyword">null</span>;</span><br><span class="line">            U.putObject(t, BLOCKER, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//由于等待超时而被环境</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapObject(<span class="keyword">this</span>, SLOT, p, <span class="keyword">null</span>)) &#123;</span><br><span class="line">            <span class="comment">//timed: false，无限等待，由于线程中断而返回null</span></span><br><span class="line">            <span class="comment">//timed: true,  超时被唤醒，返回TIMED_OUT,或者由于线程中断返回null</span></span><br><span class="line">            v = timed &amp;&amp; ns &lt;= <span class="number">0L</span> &amp;&amp; !t.isInterrupted() ? TIMED_OUT : <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    U.putOrderedObject(p, MATCH, <span class="keyword">null</span>);</span><br><span class="line">    p.item = <span class="keyword">null</span>;</span><br><span class="line">    p.hash = h;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;1.<strong>slotExchange</strong>主要采用<code>arena</code>去完成整个的数据交互的。</p><p>&emsp;&emsp;2.<code>m</code>与<code>index</code>的初始值为0，两者都是&gt;=0，并且i不能大于m。若是多个线程企图抢占<code>index</code>对应的数组元素<code>Node</code>均失败的情形下将<code>m</code>进行加1操作,抢占<code>m+1</code>对应的数组元素，将其修改为当前线程所关联的<code>Node</code>，进入自旋。</p><p>&emsp;&emsp;3.自旋结束匹配到线程，那么将<code>m+1</code>对应的数组元素重置为null,然后将<code>m-1</code>，再次进入循环继续抢占元素。若是达到极端情况，<code>m</code>会一直递增达到最大值<strong>FULL</strong>，然后随着并发的减少，<code>m</code>会随之减少到0，通过这种方式动态的去调整<code>m</code>去避免过多的线程基于<strong>CAS</strong>修改同一个元素而导致<strong>CAS</strong>失败，提高了匹配的效率。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//争夺slot失败</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> Object <span class="title">arenaExchange</span><span class="params">(Object item, <span class="keyword">boolean</span> timed, <span class="keyword">long</span> ns)</span> </span>&#123;</span><br><span class="line">    Node[] a = arena;</span><br><span class="line">    Node p = participant.get();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = p.index;;) &#123; <span class="comment">//index初始值为0</span></span><br><span class="line">        <span class="keyword">int</span> b, m, c; <span class="keyword">long</span> j;   </span><br><span class="line"><span class="comment">//创建arena</span></span><br><span class="line">        <span class="comment">//将本来的数组容量 &lt;&lt; ASHIFT，为了避免数组元素落到了同一个高速缓存行，这里获取真实的数组元素索引时也需要 &lt;&lt; ASHIFT</span></span><br><span class="line">        Node q = (Node)U.getObjectVolatile(a, j = (i &lt;&lt; ASHIFT) + ABASE);</span><br><span class="line">        <span class="comment">////如果q不为null，则将对应的数组元素置为null，表示当前线程和该元素对应的线程匹配了</span></span><br><span class="line">        <span class="keyword">if</span> (q != <span class="keyword">null</span> &amp;&amp; U.compareAndSwapObject(a, j, q, <span class="keyword">null</span>)) &#123;</span><br><span class="line">            Object v = q.item;</span><br><span class="line">            <span class="comment">//保存item</span></span><br><span class="line">            q.match = item;</span><br><span class="line">            <span class="comment">//唤醒等待的线程</span></span><br><span class="line">            Thread w = q.parked;</span><br><span class="line">            <span class="keyword">if</span> (w != <span class="keyword">null</span>)</span><br><span class="line">                U.unpark(w);</span><br><span class="line">            <span class="comment">//数据交互完成</span></span><br><span class="line">            <span class="keyword">return</span> v;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//q==null || cas失败</span></span><br><span class="line">        <span class="comment">//bound初始化时是SEQ，SEQ &amp; MMASK就是0，即m的初始值就是0，m为0时，i肯定为0</span></span><br><span class="line">        <span class="comment">//q为null，该数组元素未被占用,注意上面的cas会将数组元素置为null，下一次for循环q变成nul</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (i &lt;= (m = (b = bound) &amp; MMASK) &amp;&amp; q == <span class="keyword">null</span>) &#123;</span><br><span class="line">            p.item = item;     </span><br><span class="line">            <span class="comment">//对应的数组元素修改为p</span></span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapObject(a, j, <span class="keyword">null</span>, p)) &#123;</span><br><span class="line">                <span class="comment">//如果timed为true且m等于0的情形下才会等待指定的时间，否则是无期限等待</span></span><br><span class="line">                <span class="keyword">long</span> end = (timed &amp;&amp; m == <span class="number">0</span>) ? System.nanoTime() + ns : <span class="number">0L</span>;</span><br><span class="line">                Thread t = Thread.currentThread(); <span class="comment">// wait</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> h = p.hash, spins = SPINS;;) &#123;</span><br><span class="line">                    Object v = p.match;</span><br><span class="line">                    <span class="comment">//已经跟某个线程交换成功</span></span><br><span class="line">                    <span class="keyword">if</span> (v != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">//MATCH、item置为null，方便下次使用</span></span><br><span class="line">                        U.putOrderedObject(p, MATCH, <span class="keyword">null</span>);</span><br><span class="line">                        p.item = <span class="keyword">null</span>;             <span class="comment">// clear for next use</span></span><br><span class="line">                        <span class="comment">//保存hash、便于下次自旋操作</span></span><br><span class="line">                        p.hash = h;</span><br><span class="line">                        <span class="keyword">return</span> v;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (spins &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">//进入自旋</span></span><br><span class="line">                        h ^= h &lt;&lt; <span class="number">1</span>; h ^= h &gt;&gt;&gt; <span class="number">3</span>; h ^= h &lt;&lt; <span class="number">10</span>; <span class="comment">// xorshift</span></span><br><span class="line">                        <span class="keyword">if</span> (h == <span class="number">0</span>)                <span class="comment">// initialize hash</span></span><br><span class="line">                            h = SPINS | (<span class="keyword">int</span>)t.getId();</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (h &lt; <span class="number">0</span> &amp;&amp;          <span class="comment">// approx 50% true</span></span><br><span class="line">                                 (--spins &amp; ((SPINS &gt;&gt;&gt; <span class="number">1</span>) - <span class="number">1</span>)) == <span class="number">0</span>)</span><br><span class="line">                            Thread.yield();        <span class="comment">// two yields per wait</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//索引j处的数组元素发生变更</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (U.getObjectVolatile(a, j) != p)</span><br><span class="line">                        spins = SPINS;       <span class="comment">// releaser hasn't set match yet</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (!t.isInterrupted() &amp;&amp; m == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                             <span class="comment">//只有m等于0才会进入此分支让线程阻塞</span></span><br><span class="line">                             (!timed ||</span><br><span class="line">                              <span class="comment">//超时时间限制陷入等待</span></span><br><span class="line">                              (ns = end - System.nanoTime()) &gt; <span class="number">0L</span>)) &#123;</span><br><span class="line">                        U.putObject(t, BLOCKER, <span class="keyword">this</span>); <span class="comment">// emulate LockSupport</span></span><br><span class="line">                        p.parked = t;              <span class="comment">// minimize window</span></span><br><span class="line">                        <span class="comment">//再校验一遍，j处的数组元素未发生变更</span></span><br><span class="line">                        <span class="keyword">if</span> (U.getObjectVolatile(a, j) == p)</span><br><span class="line">                            <span class="comment">//线程休眠指定时间</span></span><br><span class="line">                            U.park(<span class="keyword">false</span>, ns);</span><br><span class="line">                        <span class="comment">//线程唤醒：中断或者超时</span></span><br><span class="line">                        p.parked = <span class="keyword">null</span>;</span><br><span class="line">                        U.putObject(t, BLOCKER, <span class="keyword">null</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//线程被中断或者等待超时或者m!=0</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (U.getObjectVolatile(a, j) == p &amp;&amp;</span><br><span class="line">                             <span class="comment">//j索引位置的元素没有发生改变将其设置为null</span></span><br><span class="line">                             U.compareAndSwapObject(a, j, p, <span class="keyword">null</span>)) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (m != <span class="number">0</span>)                <span class="comment">// try to shrink</span></span><br><span class="line">                            <span class="comment">//修改BOUND,下一次跟MMASK求且的结果会减1，此时可能导致i大于m</span></span><br><span class="line">                            U.compareAndSwapInt(<span class="keyword">this</span>, BOUND, b, b + SEQ - <span class="number">1</span>);</span><br><span class="line">                        p.item = <span class="keyword">null</span>;</span><br><span class="line">                        p.hash = h;</span><br><span class="line">                        <span class="comment">//索引右移一位</span></span><br><span class="line">                        i = p.index &gt;&gt;&gt;= <span class="number">1</span>;        <span class="comment">// descend</span></span><br><span class="line">                        <span class="comment">//线程若是中断则返回null</span></span><br><span class="line">                        <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">if</span> (timed &amp;&amp; m == <span class="number">0</span> &amp;&amp; ns &lt;= <span class="number">0L</span>)</span><br><span class="line">                            <span class="keyword">return</span> TIMED_OUT;</span><br><span class="line">                        <span class="comment">//m！=0,继续自旋</span></span><br><span class="line">                        <span class="keyword">break</span>;                     <span class="comment">// expired; restart</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">//数组元素修改失败，继续重试</span></span><br><span class="line">                <span class="comment">//q不为null，与该元素对应的线程匹配成功</span></span><br><span class="line">                p.item = <span class="keyword">null</span>;                     <span class="comment">// clear offer</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//i&gt;m 或者q不为null，cas抢占q失败了 会进入此分支 </span></span><br><span class="line">            <span class="comment">//bound的初始值也是0</span></span><br><span class="line">            <span class="keyword">if</span> (p.bound != b) &#123;                    </span><br><span class="line">                <span class="comment">//重置bound、collides</span></span><br><span class="line">                p.bound = b; </span><br><span class="line">                p.collides = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">//如果i等于m且m不等于0，则i=m-1,否则i=m</span></span><br><span class="line">                i = (i != m || m == <span class="number">0</span>) ? m : m - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//BOUND修改为b</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((c = p.collides) &lt; m || m == FULL ||</span><br><span class="line">                     !U.compareAndSwapInt(<span class="keyword">this</span>, BOUND, b, b + SEQ + <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="comment">//如果m小于FULL，会尝试最多m次，即进入下面的逻辑最多m次，如果还失败则增加m，然后继续尝试直到m等于FUll为止 </span></span><br><span class="line">                <span class="comment">//计数器+1</span></span><br><span class="line">                p.collides = c + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">//i不等于0的时候，i等于i减1，等于0则i等于m，即循环的从m往后遍历arena数组的元素了</span></span><br><span class="line">                i = (i == <span class="number">0</span>) ? m : i - <span class="number">1</span>;          <span class="comment">// cyclically traverse</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//上一个else if三个条件都为false，即p.collides &gt;m 且m不等于FULL且cas 修改bound成功</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">//修改bound成功会导致下一次计算m时，m加1，此处i等于m+1，下一次for循环i等于m，会抢占m+1对应的rena数组的元素</span></span><br><span class="line">                i = m + <span class="number">1</span>;    </span><br><span class="line">            <span class="comment">//重置索引</span></span><br><span class="line">            p.index = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/image/hexo/image-20200711235656352.png&quot; alt=&quot;image-20200711235656352&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/image/hexo/image-20200712065745894.pn
      
    
    </summary>
    
    
      <category term="JAVA" scheme="https://blog.huhdcc.top/categories/JAVA/"/>
    
      <category term="多线程" scheme="https://blog.huhdcc.top/categories/JAVA/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="JAVA" scheme="https://blog.huhdcc.top/tags/JAVA/"/>
    
      <category term="多线程" scheme="https://blog.huhdcc.top/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="源码深入" scheme="https://blog.huhdcc.top/tags/%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>多线程高阶-45-CyclicBarrier详解</title>
    <link href="https://blog.huhdcc.top/2020/07/11/27417/hub/"/>
    <id>https://blog.huhdcc.top/2020/07/11/27417/hub/</id>
    <published>2020-07-11T12:22:05.000Z</published>
    <updated>2020-07-11T13:56:37.183Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/image/hexo/image-20200711202301272.png" alt="image-20200711202301272"></p><h2 id="CyclicBarrier相关API"><a href="#CyclicBarrier相关API" class="headerlink" title="CyclicBarrier相关API"></a>CyclicBarrier相关API</h2><h3 id="类声明"><a href="#类声明" class="headerlink" title="类声明"></a>类声明</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrier</span></span></span><br></pre></td></tr></table></figure><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造函数</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1.任务数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1.任务数</span></span><br><span class="line"><span class="comment"> * 2.任务所有执行完毕的一个回调函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">CyclicBarrier cyclicBarrier2 = <span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>,()-&gt;&#123;</span><br><span class="line">    System.out.println(<span class="string">"我是一个执行完毕的回调函数！"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h4 id="await"><a href="#await" class="headerlink" title="await"></a>await</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//await</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1.等待所有任务执行结束</span></span><br><span class="line"><span class="comment"> * 2.线程到达之后，会在条件上等待，直到最后一个线程到达，最后一个线程到达时会执行command</span></span><br><span class="line"><span class="comment"> * 3.可以使用携带超时时间的await</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">cyclicBarrier.await();</span><br><span class="line">cyclicBarrier.await(<span class="number">1</span>, TimeUnit.MILLISECONDS);</span><br></pre></td></tr></table></figure><h4 id="getNumberWaiting"><a href="#getNumberWaiting" class="headerlink" title="getNumberWaiting"></a>getNumberWaiting</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//getNumberWaiting</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1.获取已到达等待线程数量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">System.out.println(cyclicBarrier.getNumberWaiting());</span><br></pre></td></tr></table></figure><h4 id="getParties"><a href="#getParties" class="headerlink" title="getParties"></a>getParties</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//getParties</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1.获取需要等待的线程数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">System.out.println(cyclicBarrier.getParties());</span><br></pre></td></tr></table></figure><h4 id="isBroken"><a href="#isBroken" class="headerlink" title="isBroken"></a>isBroken</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//isBroken</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1.栅栏是否已被破解</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">System.out.println(cyclicBarrier.isBroken());</span><br></pre></td></tr></table></figure><h4 id="reset"><a href="#reset" class="headerlink" title="reset"></a>reset</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//reset</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1.重置栅栏数据和状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">cyclicBarrier.reset();</span><br></pre></td></tr></table></figure><h2 id="部分源码解析"><a href="#部分源码解析" class="headerlink" title="部分源码解析"></a>部分源码解析</h2><h3 id="await-1"><a href="#await-1" class="headerlink" title="await"></a>await</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//等待所有任务执行结束</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dowait(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (TimeoutException toe) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error(toe); <span class="comment">// cannot happen</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//等待所有任务执行结束、具有超时特性</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException,</span></span><br><span class="line"><span class="function">           BrokenBarrierException,</span></span><br><span class="line"><span class="function">           TimeoutException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dowait(<span class="keyword">true</span>, unit.toNanos(timeout));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dowait</span><span class="params">(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException, BrokenBarrierException,</span></span><br><span class="line"><span class="function">           TimeoutException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Generation g = generation;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断当前栅栏是否被打破、抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (g.broken)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//线程被打断、抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">            <span class="comment">//破坏栅栏</span></span><br><span class="line">            breakBarrier();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//计算当前线程达到后、剩余的线程数</span></span><br><span class="line">        <span class="keyword">int</span> index = --count;</span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;  <span class="comment">// tripped</span></span><br><span class="line">            <span class="keyword">boolean</span> ranAction = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//如果是最后一个线程进入，那么执行command操作</span></span><br><span class="line">                <span class="keyword">final</span> Runnable command = barrierCommand;</span><br><span class="line">                <span class="keyword">if</span> (command != <span class="keyword">null</span>)</span><br><span class="line">                    command.run();</span><br><span class="line">                ranAction = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">//产生新的一代、唤醒等待的线程</span></span><br><span class="line">                <span class="comment">//重置count、parties</span></span><br><span class="line">                nextGeneration();</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//command执行失败、打破栅栏</span></span><br><span class="line">                <span class="keyword">if</span> (!ranAction)</span><br><span class="line">                    breakBarrier();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//进入自旋状态</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//判断线程是否超时、中断</span></span><br><span class="line">                <span class="keyword">if</span> (!timed)</span><br><span class="line">                    trip.await();</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; <span class="number">0L</span>)</span><br><span class="line">                    nanos = trip.awaitNanos(nanos);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                <span class="keyword">if</span> (g == generation &amp;&amp; ! g.broken) &#123;</span><br><span class="line">                    breakBarrier();</span><br><span class="line">                    <span class="keyword">throw</span> ie;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// We're about to finish waiting even if we had not</span></span><br><span class="line">                    <span class="comment">// been interrupted, so this interrupt is deemed to</span></span><br><span class="line">                    <span class="comment">// "belong" to subsequent execution.</span></span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//打破栅栏、抛出异常</span></span><br><span class="line">            <span class="keyword">if</span> (g.broken)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (g != generation)</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//线程超时、打破栅栏、抛出异常</span></span><br><span class="line">            <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                breakBarrier();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *1.生成新的一代</span></span><br><span class="line"><span class="comment"> *2.唤醒所有等待的线程</span></span><br><span class="line"><span class="comment"> *3.重置count、parties</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">nextGeneration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// signal completion of last generation</span></span><br><span class="line">    trip.signalAll();</span><br><span class="line">    <span class="comment">// set up next generation</span></span><br><span class="line">    count = parties;</span><br><span class="line">    generation = <span class="keyword">new</span> Generation();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 打破栅栏</span></span><br><span class="line"><span class="comment"> * 1、generation.broker = true标识栅栏已经被打破</span></span><br><span class="line"><span class="comment"> * 2、重置count到parties</span></span><br><span class="line"><span class="comment"> * 3、唤醒所有等待的线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">breakBarrier</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    generation.broken = <span class="keyword">true</span>;</span><br><span class="line">    count = parties;</span><br><span class="line">    trip.signalAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="reset-1"><a href="#reset-1" class="headerlink" title="reset"></a>reset</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *1.重置count、parties</span></span><br><span class="line"><span class="comment"> *2.打破栅栏</span></span><br><span class="line"><span class="comment"> *3.生成新的一代</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        breakBarrier();   <span class="comment">// break the current generation</span></span><br><span class="line">        nextGeneration(); <span class="comment">// start a new generation</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="成员属性"><a href="#成员属性" class="headerlink" title="成员属性"></a>成员属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="comment">// 当有线程到达时，如果count不能减到1，线程将会在该条件上等待</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition trip = lock.newCondition();</span><br><span class="line"><span class="comment">// 总共需要等待的线程数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> parties;</span><br><span class="line"><span class="comment">// 所有等待线程都到达时执行该命令</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Runnable barrierCommand;</span><br><span class="line"><span class="comment">/** The current generation */</span></span><br><span class="line"><span class="keyword">private</span> Generation generation = <span class="keyword">new</span> Generation();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 还需要等待的线程。初始值为总共需要等待的线程，当新产生一代或者栅栏被打破，count重置为parties</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> count;</span><br></pre></td></tr></table></figure><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">            System.out.println(<span class="string">"T1 work finish."</span>);</span><br><span class="line">            cyclicBarrier.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,<span class="string">"T1"</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">15000</span>);</span><br><span class="line">            System.out.println(<span class="string">"T2 work finish."</span>);</span><br><span class="line">            cyclicBarrier.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,<span class="string">"T2"</span>).start();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> <span class="keyword">throws</span> BrokenBarrierException, InterruptedException </span>&#123;</span><br><span class="line">    CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">            System.out.println(<span class="string">"T1 work finish."</span>);</span><br><span class="line">            cyclicBarrier.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,<span class="string">"T1"</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">15000</span>);</span><br><span class="line">            System.out.println(<span class="string">"T2 work finish."</span>);</span><br><span class="line">            cyclicBarrier.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,<span class="string">"T2"</span>).start();</span><br><span class="line"></span><br><span class="line">    cyclicBarrier.await();</span><br><span class="line">    System.out.println(<span class="string">"All work finish."</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CyclicBarrier-amp-CountDownLatch"><a href="#CyclicBarrier-amp-CountDownLatch" class="headerlink" title="CyclicBarrier &amp; CountDownLatch"></a>CyclicBarrier &amp; CountDownLatch</h2><p>&emsp;&emsp;1.<strong>CountDownLatch</strong>基于<strong>AQS</strong>,CyclicBarrier基于<strong>ReentrantLock</strong>。</p><p>&emsp;&emsp;2.<strong>CyclicBarrier</strong>支持复用(<strong>reset</strong>)和<code>barrierCommand</code>，但是<strong>CountDownLatch</strong>不支持。</p><p>&emsp;&emsp;3.<strong>CyclicBarrier</strong>会阻塞线程，在最后一个线程执行完毕之前其余的线程都必须陷入等待(工作线程之间互不影响，等到达到同一个点才会去执行某个特定的操作)，而<strong>CountDownLatch</strong>在<strong>countDown</strong>不会阻塞线程。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/image/hexo/image-20200711202301272.png&quot; alt=&quot;image-20200711202301272&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;CyclicBarrier相关API&quot;&gt;&lt;a href=&quot;#CyclicBarrier
      
    
    </summary>
    
    
      <category term="JAVA" scheme="https://blog.huhdcc.top/categories/JAVA/"/>
    
      <category term="多线程" scheme="https://blog.huhdcc.top/categories/JAVA/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="JAVA" scheme="https://blog.huhdcc.top/tags/JAVA/"/>
    
      <category term="多线程" scheme="https://blog.huhdcc.top/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="源码深入" scheme="https://blog.huhdcc.top/tags/%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>多线程高阶-44-CountDownLatch详解</title>
    <link href="https://blog.huhdcc.top/2020/07/10/56426/hub/"/>
    <id>https://blog.huhdcc.top/2020/07/10/56426/hub/</id>
    <published>2020-07-10T11:34:38.000Z</published>
    <updated>2020-07-10T15:57:59.870Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/image/hexo/image-20200710200228636.png" alt="image-20200710200228636"></p><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><h3 id="案例一（任务完全并行化）"><a href="#案例一（任务完全并行化）" class="headerlink" title="案例一（任务完全并行化）"></a>案例一（任务完全并行化）</h3><p>&emsp;&emsp;使用<strong>CountDownLatch</strong>去执行任务，等待所有任务执行完毕然后释放资源。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        test01();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Random random = <span class="keyword">new</span> Random(System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService executor = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//1.获取数据</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span>[] data = query();</span><br><span class="line">        <span class="comment">//2.执行任务</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; data.length; i++) &#123;</span><br><span class="line">            executor.execute(<span class="keyword">new</span> SimpleRunnable(data, i, latch));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.等待任务结束</span></span><br><span class="line">        latch.await();</span><br><span class="line">        System.out.println(<span class="string">"all of finish down."</span>);</span><br><span class="line">        <span class="comment">//4.关闭线程池</span></span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="comment">//数据data</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span>[] data;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//访问的数据索引位置</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> index;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//countDown</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch countDownLatch;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">SimpleRunnable</span><span class="params">(<span class="keyword">int</span>[] data, <span class="keyword">int</span> index, CountDownLatch countDownLatch)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.data = data;</span><br><span class="line">            <span class="keyword">this</span>.index = index;</span><br><span class="line">            <span class="keyword">this</span>.countDownLatch = countDownLatch;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(random.nextInt(<span class="number">2000</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//任务执行单元</span></span><br><span class="line">            <span class="keyword">int</span> value = data[index];</span><br><span class="line">            <span class="keyword">if</span> (value % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                data[index] = value * <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                data[index] = value * <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//latch关闭</span></span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" finish down."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数据查询</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] query() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="案例二（多任务半并行化）"><a href="#案例二（多任务半并行化）" class="headerlink" title="案例二（多任务半并行化）"></a>案例二（多任务半并行化）</h3><p>&emsp;&emsp;在多个线程串行化的时候，发现前半部分逻辑可以并行化去实现，但是某线程可能后半部分需要串行化处理。那么也可以采用<strong>CountDownLatch</strong>去实现，例如一个完整的任务串行化的时间是3分钟，而前半部分采用了并行化，它整体所需的时间缩减了一分钟，那么在大量任务执行的情况下，这一分钟的时间也是不可忽略的，在一定程度上提升执行效率。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchTest2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//开启一个线程执行某些前置操作</span></span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">//前置操作</span></span><br><span class="line">                System.out.println(<span class="string">"Do some initial working."</span>);</span><br><span class="line">                <span class="comment">//执行完毕发现提交不满足需要其他条件那么此时进入等待</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    countDownLatch.await();</span><br><span class="line">                    <span class="comment">//等待结束继续执行</span></span><br><span class="line">                    System.out.println(<span class="string">"Do other working..."</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//另一个线程也可以并行的执行前置操作但是上面一个线程需要当前线程的一些条件</span></span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">//执行前置条件</span></span><br><span class="line">                System.out.println(<span class="string">"asyn prepare for some data."</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">//最终条件满足，使得另一个等待的线程再次唤醒执行任务</span></span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">        </span><br><span class="line">        Thread.currentThread().join();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;尝试开启多个<strong>wait</strong>任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//开启一个线程执行某些前置操作</span></span><br><span class="line"><span class="keyword">new</span> Thread() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//前置操作</span></span><br><span class="line">        System.out.println(<span class="string">"Do some initial working."</span>);</span><br><span class="line">        <span class="comment">//执行完毕发现提交不满足需要其他条件那么此时进入等待</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            countDownLatch.await();</span><br><span class="line">            <span class="comment">//等待结束继续执行</span></span><br><span class="line">            System.out.println(<span class="string">"Do other working..."</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//开启一个线程执行某些前置操作</span></span><br><span class="line"><span class="keyword">new</span> Thread() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//前置操作</span></span><br><span class="line">        System.out.println(<span class="string">"Do some initial working."</span>);</span><br><span class="line">        <span class="comment">//执行完毕发现提交不满足需要其他条件那么此时进入等待</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            countDownLatch.await();</span><br><span class="line">            <span class="comment">//等待结束继续执行</span></span><br><span class="line">            System.out.println(<span class="string">"Do other working..."</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.start();</span><br></pre></td></tr></table></figure><h3 id="案例三（离散平行任务逻辑化）"><a href="#案例三（离散平行任务逻辑化）" class="headerlink" title="案例三（离散平行任务逻辑化）"></a>案例三（离散平行任务逻辑化）</h3><p>&emsp;&emsp;针对大量的离散任务，并且需要并行化处理也可以使用<strong>CountDownLatch</strong>去完成。</p><h4 id="初始版本"><a href="#初始版本" class="headerlink" title="初始版本"></a>初始版本</h4><h5 id="定义Event"><a href="#定义Event" class="headerlink" title="定义Event"></a>定义Event</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Event</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Event</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="定义数据Table"><a href="#定义数据Table" class="headerlink" title="定义数据Table"></a>定义数据Table</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Table</span></span>&#123;</span><br><span class="line">    String tableName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> sourceRecordCount = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> targetCount;</span><br><span class="line"></span><br><span class="line">    String sourceColumnSchema = <span class="string">"&lt;table name='a'&gt;&lt;column name='coll' type='varchar2'&gt;&lt;/column&gt;&lt;/table&gt;"</span>;</span><br><span class="line"></span><br><span class="line">    String targetColumnSchema = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Table</span><span class="params">(String tableName, <span class="keyword">long</span> sourceRecordCount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.tableName = tableName;</span><br><span class="line">        <span class="keyword">this</span>.sourceRecordCount = sourceRecordCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Event换取Table数据"><a href="#Event换取Table数据" class="headerlink" title="Event换取Table数据"></a>Event换取Table数据</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Table&gt; <span class="title">capture</span><span class="params">(Event event)</span> </span>&#123;</span><br><span class="line">    List&lt;Table&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        list.add(<span class="keyword">new</span> Table(<span class="string">"T-"</span> + event.id + <span class="string">"-"</span> + i, i * <span class="number">1000</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="定义任务Runnable"><a href="#定义任务Runnable" class="headerlink" title="定义任务Runnable"></a>定义任务Runnable</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Random random = <span class="keyword">new</span> Random(System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TrustSourceRecordCount</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Table table;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TrustSourceRecordCount</span><span class="params">(Table table)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.table = table;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(random.nextInt(<span class="number">10000</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        table.sourceRecordCount = table.sourceRecordCount;</span><br><span class="line">        System.out.println(<span class="string">"The Table :"</span> + table.tableName + <span class="string">" target record capture down."</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TrustSourceColumnCount</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Table table;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TrustSourceColumnCount</span><span class="params">(Table table)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.table = table;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(random.nextInt(<span class="number">10000</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        table.targetCount = table.targetCount;</span><br><span class="line">        System.out.println(<span class="string">"The Table :"</span> + table.tableName + <span class="string">" target columns capture down."</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">    List&lt;Event&gt; events = Arrays.asList(<span class="keyword">new</span> Event(<span class="number">1</span>), <span class="keyword">new</span> Event(<span class="number">2</span>));</span><br><span class="line">    events.forEach(e-&gt;&#123;</span><br><span class="line">        List&lt;Table&gt; tables = capture(e);</span><br><span class="line">        tables.forEach(table-&gt;&#123;</span><br><span class="line">            TrustSourceRecordCount trustSourceRecordCount = <span class="keyword">new</span> TrustSourceRecordCount(table);</span><br><span class="line">            TrustSourceColumnCount trustSourceColumnCount = <span class="keyword">new</span> TrustSourceColumnCount(table);</span><br><span class="line">            executorService.execute(trustSourceRecordCount);</span><br><span class="line">            executorService.execute(trustSourceColumnCount);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;不过上述程序表现的很零散，其实并不知道一个<strong>Table</strong>的执行情况。</p><h4 id="Table优化演进"><a href="#Table优化演进" class="headerlink" title="Table优化演进"></a>Table优化演进</h4><h5 id="Watcher接口定义"><a href="#Watcher接口定义" class="headerlink" title="Watcher接口定义"></a>Watcher接口定义</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">interface</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">down</span><span class="params">(Table table)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="TaskBatch任务实现"><a href="#TaskBatch任务实现" class="headerlink" title="TaskBatch任务实现"></a>TaskBatch任务实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskBatch</span> <span class="keyword">implements</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CountDownLatch latch;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TaskBatch</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.latch = <span class="keyword">new</span> CountDownLatch(size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">down</span><span class="params">(Table table)</span> </span>&#123;</span><br><span class="line">        latch.countDown();</span><br><span class="line">        <span class="keyword">if</span> (latch.getCount() == <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"The table :"</span> + table.tableName + <span class="string">" finish down. table:"</span> + table);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="改造任务"><a href="#改造任务" class="headerlink" title="改造任务"></a>改造任务</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TrustSourceRecordCount</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Table table;</span><br><span class="line">    <span class="keyword">private</span> TaskBatch taskBatch;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TrustSourceRecordCount</span><span class="params">(Table table,TaskBatch taskBatch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.table = table;</span><br><span class="line">        <span class="keyword">this</span>.taskBatch = taskBatch;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(random.nextInt(<span class="number">10000</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        table.sourceRecordCount = table.sourceRecordCount;</span><br><span class="line">        taskBatch.down(table);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TrustSourceColumnCount</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Table table;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TaskBatch taskBatch;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TrustSourceColumnCount</span><span class="params">(Table table,TaskBatch taskBatch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.table = table;</span><br><span class="line">        <span class="keyword">this</span>.taskBatch = taskBatch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(random.nextInt(<span class="number">10000</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        table.targetCount = table.targetCount;</span><br><span class="line">        taskBatch.down(table);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="修改任务封装"><a href="#修改任务封装" class="headerlink" title="修改任务封装"></a>修改任务封装</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">    List&lt;Event&gt; events = Arrays.asList(<span class="keyword">new</span> Event(<span class="number">1</span>), <span class="keyword">new</span> Event(<span class="number">2</span>));</span><br><span class="line">    events.forEach(e-&gt;&#123;</span><br><span class="line">        List&lt;Table&gt; tables = capture(e);</span><br><span class="line">        tables.forEach(table-&gt;&#123;</span><br><span class="line">            TaskBatch taskBatch = <span class="keyword">new</span> TaskBatch(<span class="number">2</span>);</span><br><span class="line">            TrustSourceRecordCount trustSourceRecordCount = <span class="keyword">new</span> TrustSourceRecordCount(table,taskBatch);</span><br><span class="line">            TrustSourceColumnCount trustSourceColumnCount = <span class="keyword">new</span> TrustSourceColumnCount(table, taskBatch);</span><br><span class="line">            executorService.execute(trustSourceRecordCount);</span><br><span class="line">            executorService.execute(trustSourceColumnCount);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;通过改造可以发现<strong>Table</strong>的任务更加具有逻辑，但是针对<strong>Event</strong>来说，多个<strong>Table</strong>的执行还是未知的，那么<strong>Event</strong>也可以通过类似的改造来实现。</p><h4 id="Event优化演进"><a href="#Event优化演进" class="headerlink" title="Event优化演进"></a>Event优化演进</h4><h5 id="增加TaskGroup"><a href="#增加TaskGroup" class="headerlink" title="增加TaskGroup"></a>增加TaskGroup</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskGroup</span> <span class="keyword">implements</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CountDownLatch latch;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Event event;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TaskGroup</span><span class="params">(<span class="keyword">int</span> size,Event event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.event = event;</span><br><span class="line">        <span class="keyword">this</span>.latch = <span class="keyword">new</span> CountDownLatch(size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">down</span><span class="params">(Table table)</span> </span>&#123;</span><br><span class="line">        latch.countDown();</span><br><span class="line">        <span class="keyword">if</span> (latch.getCount() == <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"The event :"</span> + event.id + <span class="string">" finish down."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="改造TaskBatch"><a href="#改造TaskBatch" class="headerlink" title="改造TaskBatch"></a>改造TaskBatch</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskBatch</span> <span class="keyword">implements</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CountDownLatch latch;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TaskGroup taskGroup;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TaskBatch</span><span class="params">(<span class="keyword">int</span> size,TaskGroup taskGroup)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.taskGroup = taskGroup;</span><br><span class="line">        <span class="keyword">this</span>.latch = <span class="keyword">new</span> CountDownLatch(size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">down</span><span class="params">(Table table)</span> </span>&#123;</span><br><span class="line">        latch.countDown();</span><br><span class="line">        <span class="keyword">if</span> (latch.getCount() == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="comment">// System.out.println("The table :" + table.tableName + " finish down. table:" + table);</span></span><br><span class="line">            taskGroup.down(table);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="再次运行"><a href="#再次运行" class="headerlink" title="再次运行"></a>再次运行</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">    List&lt;Event&gt; events = Arrays.asList(<span class="keyword">new</span> Event(<span class="number">1</span>), <span class="keyword">new</span> Event(<span class="number">2</span>));</span><br><span class="line">    events.forEach(e-&gt;&#123;</span><br><span class="line">        List&lt;Table&gt; tables = capture(e);</span><br><span class="line">        TaskGroup taskGroup = <span class="keyword">new</span> TaskGroup(tables.size(), e);</span><br><span class="line">        tables.forEach(table-&gt;&#123;</span><br><span class="line">            TaskBatch taskBatch = <span class="keyword">new</span> TaskBatch(<span class="number">2</span>,taskGroup);</span><br><span class="line">            TrustSourceRecordCount trustSourceRecordCount = <span class="keyword">new</span> TrustSourceRecordCount(table,taskBatch);</span><br><span class="line">            TrustSourceColumnCount trustSourceColumnCount = <span class="keyword">new</span> TrustSourceColumnCount(table, taskBatch);</span><br><span class="line">            executorService.execute(trustSourceRecordCount);</span><br><span class="line">            executorService.execute(trustSourceColumnCount);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;通过对<strong>Event</strong>的封装，我们可以将一条零散分布的业务进行逻辑化处理，有效的利用了<strong>CountDownLatch</strong>。</p><h2 id="CountDownLatch相关API"><a href="#CountDownLatch相关API" class="headerlink" title="CountDownLatch相关API"></a>CountDownLatch相关API</h2><h3 id="类声明"><a href="#类声明" class="headerlink" title="类声明"></a>类声明</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatch</span></span></span><br></pre></td></tr></table></figure><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CountDownLatch</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"count &lt; 0"</span>);</span><br><span class="line">    <span class="keyword">this</span>.sync = <span class="keyword">new</span> Sync(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h3 id="await"><a href="#await" class="headerlink" title="await"></a>await</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//await</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1.陷入等待</span></span><br><span class="line"><span class="comment"> * 2.new CountDownLatch(1) 中的count==0才会释放</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">latch.await();</span><br><span class="line"></span><br><span class="line"><span class="comment">//await</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1.陷入等待、并且设置等待超时时间</span></span><br><span class="line"><span class="comment"> * 2.new CountDownLatch(1) 中的count==0才会释放</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">latch.await(<span class="number">10</span>, TimeUnit.MILLISECONDS);</span><br></pre></td></tr></table></figure><h3 id="countDown"><a href="#countDown" class="headerlink" title="countDown"></a>countDown</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//countDown</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1.释放count</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">latch.countDown();</span><br></pre></td></tr></table></figure><h3 id="count"><a href="#count" class="headerlink" title="count"></a>count</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//count</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1.获取当前还存在的count</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">latch.getCount();</span><br></pre></td></tr></table></figure><h2 id="CountDownLatch部分源码解析"><a href="#CountDownLatch部分源码解析" class="headerlink" title="CountDownLatch部分源码解析"></a>CountDownLatch部分源码解析</h2><h3 id="countDown-1"><a href="#countDown-1" class="headerlink" title="countDown"></a>countDown</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">4982264981922014374L</span>;</span><br><span class="line"></span><br><span class="line">  Sync(<span class="keyword">int</span> count) &#123;</span><br><span class="line">    setState(count);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getState();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//对state进行原子性的减一操作  </span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      <span class="keyword">int</span> c = getState();   <span class="comment">// 获取当前state属性的值</span></span><br><span class="line">      <span class="keyword">if</span> (c == <span class="number">0</span>)   <span class="comment">// 如果state为0，则说明当前计数器已经计数完成，直接返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">int</span> nextc = c-<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (compareAndSetState(c, nextc)) <span class="comment">// 使用CAS算法对state进行设置</span></span><br><span class="line">        <span class="keyword">return</span> nextc == <span class="number">0</span>;  <span class="comment">// 设置成功后返回当前是否为最后一个设置state的线程</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;<span class="comment">//主要使用最快失败进行了CAS操作</span></span><br><span class="line">    doReleaseShared();<span class="comment">//唤醒多个await的线程</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    Node h = head;  <span class="comment">// 记录等待队列中的头结点的线程</span></span><br><span class="line">    <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;   <span class="comment">// 头结点不为空，且头结点不等于尾节点</span></span><br><span class="line">      <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">      <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;  <span class="comment">// SIGNAL状态表示当前节点正在等待被唤醒</span></span><br><span class="line">        <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))    <span class="comment">// 清除当前节点的等待状态</span></span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        unparkSuccessor(h); <span class="comment">// 唤醒当前节点的下一个节点</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp; !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (h == head)  <span class="comment">// 如果h还是指向头结点，说明前面这段代码执行过程中没有其他线程对头结点进行过处理</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">  <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">    compareAndSetWaitStatus(node, ws, <span class="number">0</span>);   <span class="comment">// 清除当前节点的等待状态</span></span><br><span class="line"></span><br><span class="line">  Node s = node.next;</span><br><span class="line">  <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;  <span class="comment">// s的等待状态大于0说明该节点中的线程已经被外部取消等待了</span></span><br><span class="line">    s = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 从队列尾部往前遍历，找到最后一个处于等待状态的节点，用s记录下来</span></span><br><span class="line">    <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">      <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">        s = t;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">    LockSupport.unpark(s.thread);   <span class="comment">// 唤醒离传入节点最近的处于等待状态的节点线程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="await-1"><a href="#await-1" class="headerlink" title="await"></a>await</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">  sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sync.tryAcquireSharedNanos(<span class="number">1</span>, unit.toNanos(timeout));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">  <span class="comment">//判断当前线程是否需要以共享状态去获取执行权，</span></span><br><span class="line">  <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">     <span class="comment">//其主要是判断state是否为零，如果为零则返回1，表示当前线程不需要进行权限获取，可直接执行后续代码，返回-1则表示当前线程需要进行共享权限</span></span><br><span class="line">    doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Node node = addWaiter(Node.SHARED); <span class="comment">// 使用当前线程创建一个共享模式的节点</span></span><br><span class="line">  <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      <span class="keyword">final</span> Node p = node.predecessor();    <span class="comment">// 获取当前节点的前一个节点</span></span><br><span class="line">      <span class="keyword">if</span> (p == head) &#123;  <span class="comment">// 判断前一个节点是否为头结点</span></span><br><span class="line">        <span class="keyword">int</span> r = tryAcquireShared(arg);  <span class="comment">// 查看当前线程是否获取到了执行权限</span></span><br><span class="line">        <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;   <span class="comment">// 大于0表示获取了执行权限</span></span><br><span class="line">          setHeadAndPropagate(node, r); <span class="comment">// 将当前节点设置为头结点，并且唤醒后面处于等待状态的节点</span></span><br><span class="line">          p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">          failed = <span class="keyword">false</span>;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">     </span><br><span class="line">      <span class="comment">// 走到这一步说明没有获取到执行权限，就使当前线程进入“搁置”状态</span></span><br><span class="line">      <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">          parkAndCheckInterrupt())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (failed)</span><br><span class="line">      cancelAcquire(node);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHeadAndPropagate</span><span class="params">(Node node, <span class="keyword">int</span> propagate)</span> </span>&#123;</span><br><span class="line">  Node h = head;</span><br><span class="line">  setHead(node);    <span class="comment">// 将当前节点设置为头节点</span></span><br><span class="line">  <span class="comment">// 检查唤醒过程是否需要往下传递，并且检查头结点的等待状态</span></span><br><span class="line">  <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span> ||</span><br><span class="line">      (h = head) == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.isShared())  <span class="comment">// 如果下一个节点是尝试以共享状态获取获取执行权限的节点，则将其唤醒</span></span><br><span class="line">      doReleaseShared();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;<strong>state</strong>并不是原子的，而state是int类型的变量，正好32位，因而对state变量的读取和赋值操作都是原子的。<br>在JDK源码里大量用到了这两个特性，组合之后就会有一个CAS算法，主要还是通过<strong>Unsafe</strong>的一系列<strong>compareAndSet()</strong>方法去实现的原子性。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/image/hexo/image-20200710200228636.png&quot; alt=&quot;image-20200710200228636&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;案例&quot;&gt;&lt;a href=&quot;#案例&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
    
      <category term="JAVA" scheme="https://blog.huhdcc.top/categories/JAVA/"/>
    
      <category term="多线程" scheme="https://blog.huhdcc.top/categories/JAVA/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="JAVA" scheme="https://blog.huhdcc.top/tags/JAVA/"/>
    
      <category term="多线程" scheme="https://blog.huhdcc.top/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="源码深入" scheme="https://blog.huhdcc.top/tags/%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>多线程高阶-43-Unsafe详解</title>
    <link href="https://blog.huhdcc.top/2020/07/08/45501/hub/"/>
    <id>https://blog.huhdcc.top/2020/07/08/45501/hub/</id>
    <published>2020-07-08T08:19:08.000Z</published>
    <updated>2020-07-10T15:57:59.855Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/image/hexo/image-20200708164035247.png" alt="image-20200708164035247"></p><h2 id="Unsafe相关API"><a href="#Unsafe相关API" class="headerlink" title="Unsafe相关API"></a>Unsafe相关API</h2><h3 id="类声明"><a href="#类声明" class="headerlink" title="类声明"></a>类声明</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Unsafe</span></span></span><br></pre></td></tr></table></figure><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Unsafe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Unsafe <span class="title">getUnsafe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Class var0 = Reflection.getCallerClass();</span><br><span class="line">    <span class="keyword">if</span> (!VM.isSystemDomainLoader(var0.getClassLoader())) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(<span class="string">"Unsafe"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> theUnsafe;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//由于JDK8的缘故只允许JDK自己调用他的构造函数</span></span><br><span class="line"><span class="comment">//使用反射进行实例化</span></span><br><span class="line">Field f = Unsafe.class.getDeclaredField("theUnsafe");</span><br><span class="line">f.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">Unsafe unsafe = (Unsafe) f.get(<span class="keyword">null</span>);</span><br><span class="line">System.out.println(unsafe);</span><br></pre></td></tr></table></figure><h2 id="对象相关"><a href="#对象相关" class="headerlink" title="对象相关"></a>对象相关</h2><h3 id="allocateInstance"><a href="#allocateInstance" class="headerlink" title="allocateInstance"></a>allocateInstance</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实例化对象，但是不进行初始化，类初始化和实例初始化都不调用</span></span><br><span class="line"><span class="function">Object <span class="title">allocateInstance</span><span class="params">(Class&lt;?&gt; cls)</span></span></span><br></pre></td></tr></table></figure><h3 id="objectFieldOffset"><a href="#objectFieldOffset" class="headerlink" title="objectFieldOffset"></a>objectFieldOffset</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字段在内存中的地址相对于实例对象内存地址的偏移量</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">objectFieldOffset</span><span class="params">(Field f)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">objectFieldOffset</span><span class="params">(Class&lt;?&gt; c, String name)</span></span></span><br></pre></td></tr></table></figure><h3 id="staticFieldOffset"><a href="#staticFieldOffset" class="headerlink" title="staticFieldOffset"></a>staticFieldOffset</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//静态字段在类对象中的偏移</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">staticFieldOffset</span><span class="params">(Field f)</span></span></span><br></pre></td></tr></table></figure><h3 id="staticFieldBase"><a href="#staticFieldBase" class="headerlink" title="staticFieldBase"></a>staticFieldBase</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获得静态字段所对应类对象，等同于f.getDeclaringClass()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">staticFieldBase</span><span class="params">(Field f)</span></span></span><br></pre></td></tr></table></figure><h3 id="getInt"><a href="#getInt" class="headerlink" title="getInt"></a>getInt</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读取对象上指定偏移位置的值，其他基本数据类型</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">getInt</span><span class="params">(Object o, <span class="keyword">long</span> offset)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="putInt"><a href="#putInt" class="headerlink" title="putInt"></a>putInt</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//修改对象上指定偏移位置的值，其他基本数据类型</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">putInt</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">int</span> x)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="getObject"><a href="#getObject" class="headerlink" title="getObject"></a>getObject</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获得给定对象偏移量上的引用类型的值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> Object <span class="title">getObject</span><span class="params">(Object o, <span class="keyword">long</span> offset)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="putObject"><a href="#putObject" class="headerlink" title="putObject"></a>putObject</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置给定对象偏移量上的引用类型的值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">putObject</span><span class="params">(Object o, <span class="keyword">long</span> offset, Object x)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="getAddress"><a href="#getAddress" class="headerlink" title="getAddress"></a>getAddress</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取本地指针的值，等同于获取int或者是long类型的数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getAddress</span><span class="params">(Object o, <span class="keyword">long</span> offset)</span></span></span><br></pre></td></tr></table></figure><h3 id="getAddress-1"><a href="#getAddress-1" class="headerlink" title="getAddress"></a>getAddress</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设定本地指针的值，等同于设定int或者是long类型的数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">putAddress</span><span class="params">(Object o, <span class="keyword">long</span> offset)</span></span></span><br></pre></td></tr></table></figure><h2 id="Arrays相关"><a href="#Arrays相关" class="headerlink" title="Arrays相关"></a>Arrays相关</h2><p>&emsp;&emsp;数组头部还存储有数组的长度信息，索引访问数组元素时需要知道第一个元素与起始位置的偏移地址，Unsafe类包含所有的基本数据类型和Object类型的偏移的常量值，名称为<code>ARRAY_***_BASE_OFFSET</code></p><p>同时访问数组第i个元素，对应偏移的确定需要乘以一个比例值，即数组中单个元素的长度，Unsafe中对应的常量为<code>ARRAY_***_INDEX_SCALE</code></p><h3 id="初始偏移"><a href="#初始偏移" class="headerlink" title="初始偏移"></a>初始偏移</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">arrayBaseOffset</span><span class="params">(Class&lt;?&gt; arrayClass)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ARRAY_BOOLEAN_BASE_OFFSET  </span>= theUnsafe.arrayBaseOffset(<span class="keyword">boolean</span>[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ARRAY_OBJECT_BASE_OFFSET   = theUnsafe.arrayBaseOffset(Object[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure><h3 id="比例值"><a href="#比例值" class="headerlink" title="比例值"></a>比例值</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">arrayIndexScale</span><span class="params">(Class&lt;?&gt; arrayClass)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ARRAY_BOOLEAN_INDEX_SCALE</span></span><br><span class="line"><span class="function">        </span>= theUnsafe.arrayIndexScale(<span class="keyword">boolean</span>[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ARRAY_OBJECT_INDEX_SCALE</span><br><span class="line">        = theUnsafe.arrayIndexScale(Object[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure><h3 id="读写操作"><a href="#读写操作" class="headerlink" title="读写操作"></a>读写操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ConcurrentHashMap</span></span><br><span class="line">Class&lt;?&gt; ak = Node[]<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">ABASE = U.arrayBaseOffset(ak);</span><br><span class="line"><span class="keyword">int</span> scale = U.arrayIndexScale(ak);</span><br><span class="line">ASHIFT = <span class="number">31</span> - Integer.numberOfLeadingZeros(scale);</span><br><span class="line"></span><br><span class="line"><span class="comment">//，i代表索引</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">casTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    Node&lt;K,V&gt; c, Node&lt;K,V&gt; v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> U.compareAndSwapObject(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE, c, v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CAS操作"><a href="#CAS操作" class="headerlink" title="CAS操作"></a>CAS操作</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapObject</span><span class="params">(Object o, <span class="keyword">long</span> offset, Object expected, Object x)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">int</span> expected, <span class="keyword">int</span> x)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapLong</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">long</span> expected, <span class="keyword">long</span> x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@HotSpotIntrinsicCandidate</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        v = getIntVolatile(o, offset);</span><br><span class="line">    &#125; <span class="keyword">while</span> (!weakCompareAndSetInt(o, offset, v, v + delta));</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@HotSpotIntrinsicCandidate</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndSetInt</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        v = getIntVolatile(o, offset);</span><br><span class="line">    &#125; <span class="keyword">while</span> (!weakCompareAndSetInt(o, offset, v, newValue));</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><h3 id="可见性的保障"><a href="#可见性的保障" class="headerlink" title="可见性的保障"></a>可见性的保障</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置给定对象的int值，使用volatile语义，即设置后立马更新到内存对其他线程可见</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span>  <span class="title">putIntVolatile</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">int</span> x)</span></span>;</span><br><span class="line"><span class="comment">//获得给定对象的指定偏移量offset的int值，使用volatile语义，总能获取到最新的int值。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">getIntVolatile</span><span class="params">(Object o, <span class="keyword">long</span> offset)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="lazySet"><a href="#lazySet" class="headerlink" title="lazySet"></a>lazySet</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//惰性设定值的方式</span></span><br><span class="line">putOrderedObject(Object o, <span class="keyword">long</span> offset, Object x)</span><br><span class="line">putOrderedInt(Object o, <span class="keyword">long</span> offset, <span class="keyword">int</span> x)</span><br><span class="line">putOrderedLong(Object o, <span class="keyword">long</span> offset, <span class="keyword">long</span> x)</span><br></pre></td></tr></table></figure><h2 id="挂起"><a href="#挂起" class="headerlink" title="挂起"></a>挂起</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 阻塞线程</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">(<span class="keyword">boolean</span> isAbsolute, <span class="keyword">long</span> time)</span></span>;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 解除阻塞或者让下一次阻塞调用失效</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">unpark</span><span class="params">(Object thread)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在屏障之前的读操作，不会和之后的读写操作重排序，相当于LoadLoad 加上 LoadStore 屏障</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">loadFence</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//在屏障之前的读写操作，不会和之后的写操作重排序，相当于StoreStore 加上 LoadStore 屏障</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">storeFence</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//在该方法之前的所有读写操作，不会和之后的读写操作重排序，功能上相当于上面两个的功能和，加上StoreLoad屏障</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">fullFence</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h2 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分配指定大小的内存,内存没有被初始化</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">allocateMemory</span><span class="params">(<span class="keyword">long</span> bytes)</span></span></span><br><span class="line"><span class="function"><span class="comment">//根据给定的内存地址address调整内存大小</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">reallocateMemory</span><span class="params">(<span class="keyword">long</span> address, <span class="keyword">long</span> bytes)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//将内存块中的所有字节设置为固定值，类似于C中的memoryset函数</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMemory</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">long</span> bytes, <span class="keyword">byte</span> value)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMemory</span><span class="params">(<span class="keyword">long</span> address, <span class="keyword">long</span> bytes, <span class="keyword">byte</span> value)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//内存复制，支持两种地址模式</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">copyMemory</span><span class="params">(Object srcBase, <span class="keyword">long</span> srcOffset,</span></span></span><br><span class="line"><span class="function"><span class="params">                        Object destBase, <span class="keyword">long</span> destOffset,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">long</span> bytes)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">copyMemory</span><span class="params">(<span class="keyword">long</span> srcAddress, <span class="keyword">long</span> destAddress, <span class="keyword">long</span> bytes)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//释放allocateMemory和reallocateMemory申请的内存</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">freeMemory</span><span class="params">(<span class="keyword">long</span> l)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 本地指针的大小 native pointer,4 或者 8</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addressSize</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 内存页面大小，通常为4KB，即4096</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">pageSize</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><h2 id="一半是天使一半是魔鬼"><a href="#一半是天使一半是魔鬼" class="headerlink" title="一半是天使一半是魔鬼"></a>一半是天使一半是魔鬼</h2><p>&emsp;&emsp;<strong>Unsafe</strong>在JDK8版本中针对整个并发有着举足轻重的地位，在JDK9之前也有提出过删除，但是这样会引起一大批框架的动荡，例如<strong>netty</strong>，因此在JDK9的版本中也仅仅对此进行了一些改进以及优化操作而已。</p><p>&emsp;&emsp;1.由于<strong>Unsafe</strong>大部分源码都是<strong>native</strong>方法，直接去操作了内存，那么整个执行效率也会得到极大的提升，特别是在高并发的情形下，能够更好的提供强有力的支撑。</p><p>&emsp;&emsp;2.由于<strong>Unsafe</strong>使得<strong>Java</strong>拥有了和C语言一样直接去操作内存的能力，那么随之也会带来一系列的问题。比如：不再受制于JVM控制，并且无法GC、由于很多内存地址、偏移量都需要自行计算也可能更加容易导致出现JVM级别的异常，从而导致整个JVM进程崩溃。所以官方也不提供并且不推荐开发者使用。</p><h2 id="Unsafe测试"><a href="#Unsafe测试" class="headerlink" title="Unsafe测试"></a>Unsafe测试</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 反射获取unsafe</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>  sanmengcc</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>   2020/7/10 1:47</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Unsafe <span class="title">getUnsafe</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException </span>&#123;</span><br><span class="line">    Field f = Unsafe.class.getDeclaredField("theUnsafe");</span><br><span class="line">    f.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">return</span>  (Unsafe) f.get(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对象初始化操作"><a href="#对象初始化操作" class="headerlink" title="对象初始化操作"></a>对象初始化操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Simple</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Simple</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        i = <span class="number">1</span>;</span><br><span class="line">        System.out.println(<span class="string">"simple init."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getI</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setI</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.i = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 测试unsafe对象实例化</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>  sanmengcc</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>   2020/7/10 1:51</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testSimple</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException, InstantiationException </span>&#123;</span><br><span class="line">    Unsafe unsafe = getUnsafe();</span><br><span class="line">    <span class="comment">//通过Unsafe创建对象</span></span><br><span class="line">    Simple simple = (Simple) unsafe.allocateInstance(Simple<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    System.out.println(<span class="string">"simple i = "</span> + simple.getI());</span><br><span class="line">    System.out.println(<span class="string">"------------------------------------------"</span>);</span><br><span class="line">    <span class="comment">//直接创建对象</span></span><br><span class="line">    System.out.println(<span class="string">"simple i = "</span> + <span class="keyword">new</span> Simple().getI());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/image/hexo/image-20200710015317017.png" alt="image-20200710015317017"></p><p>&emsp;&emsp;可以发现通过<strong>Unsafe</strong>加载对象他不会调用构造方法，直接进行了实例化操作。</p><h3 id="工作权限案例"><a href="#工作权限案例" class="headerlink" title="工作权限案例"></a>工作权限案例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Guard</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ACCESS_ALLOWED = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//简单的权限校验</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">allow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">42</span> == ACCESS_ALLOWED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//满足条件进行工作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (allow()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"I am do working."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 工作权限测试</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>  sanmengc</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>   2020/7/10 2:00</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testGuard</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException </span>&#123;</span><br><span class="line">    Guard guard = <span class="keyword">new</span> Guard();</span><br><span class="line">    <span class="comment">//肯定是无法工作的</span></span><br><span class="line">    guard.work();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用Unsafe</span></span><br><span class="line">    Field field = guard.getClass().getDeclaredField(<span class="string">"ACCESS_ALLOWED"</span>);</span><br><span class="line">    Unsafe unsafe = getUnsafe();</span><br><span class="line">    unsafe.putInt(guard, unsafe.objectFieldOffset(field), <span class="number">42</span>);</span><br><span class="line">    <span class="comment">//企图工作</span></span><br><span class="line">    guard.work();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/image/hexo/image-20200710020103029.png" alt="image-20200710020103029"></p><p>&emsp;&emsp;可以发现通过<strong>Unsafe</strong>操作可以绕开权限判断，使得正常工作。其实主要还是通过<strong>Unsafe</strong>直接操作了内存导致的。</p><h3 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//UnsafeClass的class文件需要拷贝到指定位置</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnsafeClass</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UnsafeClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.i = <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getI</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 通过Unsafe加载类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>  sanmengcc</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>   2020/7/10 2:43</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testUnsafeClassLoad</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    File classFile = <span class="keyword">new</span> File(<span class="string">"D:\\UnsafeClass.class"</span>);</span><br><span class="line">    FileInputStream inputStream = <span class="keyword">new</span> FileInputStream(classFile);</span><br><span class="line">    <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[(<span class="keyword">int</span>) classFile.length()];</span><br><span class="line">    inputStream.read(bytes);</span><br><span class="line">    inputStream.close();</span><br><span class="line">    <span class="comment">//通过Unsafe加载</span></span><br><span class="line">    Unsafe unsafe = getUnsafe();</span><br><span class="line">    Class defineClass = unsafe.defineClass(<span class="keyword">null</span>, bytes, <span class="number">0</span>, bytes.length, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    Method classMethod = defineClass.getMethod(<span class="string">"getI"</span>);</span><br><span class="line">    Object invoke = classMethod.invoke(defineClass.newInstance(), <span class="keyword">null</span>);</span><br><span class="line">    System.out.println(invoke);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取字段的偏移量"><a href="#获取字段的偏移量" class="headerlink" title="获取字段的偏移量"></a>获取字段的偏移量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> unsafe获取字段偏移量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>  sanmengcc</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>   2020/7/10 2:51</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sizeOf</span><span class="params">(Object object)</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException </span>&#123;</span><br><span class="line">    Unsafe unsafe = getUnsafe();</span><br><span class="line">    Set&lt;Field&gt; fieldSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    Class&lt;?&gt; aClass = object.getClass();</span><br><span class="line">    <span class="keyword">while</span> (aClass != Object<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">        Field[] declaredFields = aClass.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span> (Field field : declaredFields) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((field.getModifiers() &amp; Modifier.STATIC )== <span class="number">0</span>) &#123;</span><br><span class="line">                fieldSet.add(field);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        aClass = aClass.getSuperclass();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> maxOffSet = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Field field : fieldSet) &#123;</span><br><span class="line">        <span class="keyword">long</span> offset = unsafe.objectFieldOffset(field);</span><br><span class="line">        <span class="keyword">if</span> (offset &gt; maxOffSet) &#123;</span><br><span class="line">            maxOffSet = offset;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(((maxOffSet / <span class="number">8</span>) + <span class="number">1</span>) * <span class="number">8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/image/hexo/image-20200708164035247.png&quot; alt=&quot;image-20200708164035247&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Unsafe相关API&quot;&gt;&lt;a href=&quot;#Unsafe相关API&quot; class=&quot;
      
    
    </summary>
    
    
      <category term="JAVA" scheme="https://blog.huhdcc.top/categories/JAVA/"/>
    
      <category term="多线程" scheme="https://blog.huhdcc.top/categories/JAVA/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="JAVA" scheme="https://blog.huhdcc.top/tags/JAVA/"/>
    
      <category term="多线程" scheme="https://blog.huhdcc.top/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="源码深入" scheme="https://blog.huhdcc.top/tags/%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>多线程高阶-42-LongAdder详解</title>
    <link href="https://blog.huhdcc.top/2020/07/07/8158/hub/"/>
    <id>https://blog.huhdcc.top/2020/07/07/8158/hub/</id>
    <published>2020-07-07T14:11:23.000Z</published>
    <updated>2020-07-07T14:37:18.572Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/image/hexo/image-20200707221203318.png" alt="image-20200707221203318"></p><h2 id="LongAdder相关API"><a href="#LongAdder相关API" class="headerlink" title="LongAdder相关API"></a>LongAdder相关API</h2><h3 id="类声明"><a href="#类声明" class="headerlink" title="类声明"></a>类声明</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extends Striped64 implements Serializable</span><br></pre></td></tr></table></figure><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造函数</span></span><br><span class="line">LongAdder longAdder = <span class="keyword">new</span> LongAdder();</span><br></pre></td></tr></table></figure><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h4 id="add"><a href="#add" class="headerlink" title="add"></a>add</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//add</span></span><br><span class="line">longAdder.add(<span class="number">10</span>);</span><br><span class="line">System.out.println(longAdder.intValue());</span><br></pre></td></tr></table></figure><h4 id="decrement"><a href="#decrement" class="headerlink" title="decrement"></a>decrement</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//decrement</span></span><br><span class="line">longAdder.decrement();</span><br><span class="line">System.out.println(longAdder.doubleValue());</span><br></pre></td></tr></table></figure><h4 id="doubleValue"><a href="#doubleValue" class="headerlink" title="doubleValue"></a>doubleValue</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//doubleValue</span></span><br><span class="line">System.out.println(longAdder.doubleValue());</span><br></pre></td></tr></table></figure><h4 id="floatValue"><a href="#floatValue" class="headerlink" title="floatValue"></a>floatValue</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//floatValue</span></span><br><span class="line">System.out.println(longAdder.floatValue());</span><br></pre></td></tr></table></figure><h4 id="increment"><a href="#increment" class="headerlink" title="increment"></a>increment</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//increment</span></span><br><span class="line">longAdder.increment();</span><br><span class="line">System.out.println(longAdder.floatValue());</span><br></pre></td></tr></table></figure><h4 id="intValue"><a href="#intValue" class="headerlink" title="intValue"></a>intValue</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//intValue</span></span><br><span class="line">System.out.println(longAdder.intValue());</span><br></pre></td></tr></table></figure><h4 id="longValue"><a href="#longValue" class="headerlink" title="longValue"></a>longValue</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//longValue</span></span><br><span class="line">System.out.println(longAdder.longValue());</span><br></pre></td></tr></table></figure><h4 id="reset"><a href="#reset" class="headerlink" title="reset"></a>reset</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//reset</span></span><br><span class="line">longAdder.reset();</span><br><span class="line">System.out.println(longAdder.longValue());</span><br></pre></td></tr></table></figure><h4 id="sum"><a href="#sum" class="headerlink" title="sum"></a>sum</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sum</span></span><br><span class="line">System.out.println(longAdder.sum());</span><br></pre></td></tr></table></figure><h4 id="sumThenReset"><a href="#sumThenReset" class="headerlink" title="sumThenReset"></a>sumThenReset</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sumThenReset</span></span><br><span class="line">System.out.println(longAdder.sumThenReset());</span><br></pre></td></tr></table></figure><h2 id="部分源码解析"><a href="#部分源码解析" class="headerlink" title="部分源码解析"></a>部分源码解析</h2><h3 id="sum-1"><a href="#sum-1" class="headerlink" title="sum"></a>sum</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">sum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Cell[] as = cells; Cell a;</span><br><span class="line">    <span class="keyword">long</span> sum = base;</span><br><span class="line">    <span class="keyword">if</span> (as != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//对Cell求和</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; as.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((a = as[i]) != <span class="keyword">null</span>)</span><br><span class="line">                sum += a.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="reset-1"><a href="#reset-1" class="headerlink" title="reset"></a>reset</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Cell[] as = cells; Cell a;</span><br><span class="line">    <span class="comment">//base值set为0</span></span><br><span class="line">    base = <span class="number">0L</span>;</span><br><span class="line">    <span class="keyword">if</span> (as != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; as.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((a = as[i]) != <span class="keyword">null</span>)</span><br><span class="line">                <span class="comment">//元素set为0</span></span><br><span class="line">                a.value = <span class="number">0L</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="sumThenReset-1"><a href="#sumThenReset-1" class="headerlink" title="sumThenReset"></a>sumThenReset</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程安全问题</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">sumThenReset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Cell[] as = cells; Cell a;</span><br><span class="line">    <span class="keyword">long</span> sum = base;</span><br><span class="line">    <span class="comment">//base值set为0</span></span><br><span class="line">    base = <span class="number">0L</span>;</span><br><span class="line">    <span class="keyword">if</span> (as != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; as.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((a = as[i]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//累加元素</span></span><br><span class="line">                sum += a.value;</span><br><span class="line">                <span class="comment">//累加以后的元素set为0</span></span><br><span class="line">                a.value = <span class="number">0L</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="add-1"><a href="#add-1" class="headerlink" title="add"></a>add</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">long</span> x)</span> </span>&#123;</span><br><span class="line">    Cell[] as; <span class="keyword">long</span> b, v; <span class="keyword">int</span> m; Cell a;</span><br><span class="line">    <span class="comment">//第一次cells为空则进行casBase操作</span></span><br><span class="line">    <span class="keyword">if</span> ((as = cells) != <span class="keyword">null</span> || !casBase(b = base, b + x)) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> uncontended = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (as == <span class="keyword">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> || </span><br><span class="line">            <span class="comment">//如果Cells数组长度!=0那么计算cells位置</span></span><br><span class="line">            (a = as[getProbe() &amp; m]) == <span class="keyword">null</span> ||</span><br><span class="line">            <span class="comment">//如果cells所处位置不为空那么执行cas操作</span></span><br><span class="line">            !(uncontended = a.cas(v = a.value, v + x)))</span><br><span class="line">            <span class="comment">//否则进行初始化cells操作</span></span><br><span class="line">            longAccumulate(x, <span class="keyword">null</span>, uncontended);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/image/hexo/image-20200707221203318.png&quot; alt=&quot;image-20200707221203318&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;LongAdder相关API&quot;&gt;&lt;a href=&quot;#LongAdder相关API&quot; c
      
    
    </summary>
    
    
      <category term="JAVA" scheme="https://blog.huhdcc.top/categories/JAVA/"/>
    
      <category term="多线程" scheme="https://blog.huhdcc.top/categories/JAVA/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="JAVA" scheme="https://blog.huhdcc.top/tags/JAVA/"/>
    
      <category term="多线程" scheme="https://blog.huhdcc.top/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="源码深入" scheme="https://blog.huhdcc.top/tags/%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5/"/>
    
  </entry>
  
</feed>
