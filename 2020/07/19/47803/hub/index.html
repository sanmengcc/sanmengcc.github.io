<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>多线程高阶-52-ForkJoin详解 | Here will be a new beginning</title><meta name="description" content="案例RecursiveTask12345678910111213141516171819202122232425262728293031323334public static void main(String[] args) throws ExecutionException, InterruptedException &amp;#123;    final ForkJoinPool forkJoin"><meta name="keywords" content="JAVA,多线程,源码深入"><meta name="author" content="sanmeng"><meta name="copyright" content="sanmeng"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="dns-prefetch" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://hm.baidu.com"/><link rel="dns-prefetch" href="https://hm.baidu.com"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="dns-prefetch" href="https://fonts.googleapis.com"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="多线程高阶-52-ForkJoin详解"><meta name="twitter:description" content="案例RecursiveTask12345678910111213141516171819202122232425262728293031323334public static void main(String[] args) throws ExecutionException, InterruptedException &amp;#123;    final ForkJoinPool forkJoin"><meta name="twitter:image" content="https://blog.huhdcc.top/image/hexo/image-20200719101018337.png"><meta property="og:type" content="article"><meta property="og:title" content="多线程高阶-52-ForkJoin详解"><meta property="og:url" content="https://blog.huhdcc.top/2020/07/19/47803/hub/"><meta property="og:site_name" content="Here will be a new beginning"><meta property="og:description" content="案例RecursiveTask12345678910111213141516171819202122232425262728293031323334public static void main(String[] args) throws ExecutionException, InterruptedException &amp;#123;    final ForkJoinPool forkJoin"><meta property="og:image" content="https://blog.huhdcc.top/image/hexo/image-20200719101018337.png"><meta property="article:published_time" content="2020-07-19T02:09:31.000Z"><meta property="article:modified_time" content="2020-07-23T08:59:43.852Z"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="https://blog.huhdcc.top/2020/07/19/47803/hub/"><link rel="prev" title="多线程高阶-53-Phaser详解" href="https://blog.huhdcc.top/2020/07/25/56893/hub/"><link rel="next" title="多线程高阶-51-StampedLock详解" href="https://blog.huhdcc.top/2020/07/18/50320/hub/"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?5896b35ca19338a74f13168d02db0318";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: {"text":"富强,民主,文明,和谐,自由,平等,公正,法治,爱国,敬业,诚信,友善","fontSize":"15px"},
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@master/Hexo/css/custom.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@master/Hexo/css/hideCategory.min.css"><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="Here will be a new beginning" type="application/atom+xml">
</head><body><canvas class="fireworks"></canvas><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/head.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">72</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">19</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">19</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#案例"><span class="toc-number">1.</span> <span class="toc-text">案例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#RecursiveTask"><span class="toc-number">1.1.</span> <span class="toc-text">RecursiveTask</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RecursiveAction"><span class="toc-number">1.2.</span> <span class="toc-text">RecursiveAction</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#简介"><span class="toc-number">2.</span> <span class="toc-text">简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#主要的角色"><span class="toc-number">2.1.</span> <span class="toc-text">主要的角色</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ForkJoinWorkerThread"><span class="toc-number">2.2.</span> <span class="toc-text">ForkJoinWorkerThread:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ForkJoinPool-WorkQueue"><span class="toc-number">2.3.</span> <span class="toc-text">ForkJoinPool.WorkQueue:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ForkJoinTask："><span class="toc-number">2.4.</span> <span class="toc-text">ForkJoinTask：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ForkJoinTask详解"><span class="toc-number">3.</span> <span class="toc-text">ForkJoinTask详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#类声明"><span class="toc-number">3.1.</span> <span class="toc-text">类声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#常量"><span class="toc-number">3.2.</span> <span class="toc-text">常量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#常见方法"><span class="toc-number">3.3.</span> <span class="toc-text">常见方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#fork"><span class="toc-number">3.3.1.</span> <span class="toc-text">fork</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#join"><span class="toc-number">3.3.2.</span> <span class="toc-text">join</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#doJoin"><span class="toc-number">3.3.3.</span> <span class="toc-text">doJoin</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#setCompletion"><span class="toc-number">3.3.4.</span> <span class="toc-text">setCompletion</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#doExec"><span class="toc-number">3.3.5.</span> <span class="toc-text">doExec</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#setExceptionalCompletion"><span class="toc-number">3.3.6.</span> <span class="toc-text">setExceptionalCompletion</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#reportException"><span class="toc-number">3.3.7.</span> <span class="toc-text">reportException</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#getThrowableException"><span class="toc-number">3.3.8.</span> <span class="toc-text">getThrowableException</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#recordExceptionalCompletion"><span class="toc-number">3.3.9.</span> <span class="toc-text">recordExceptionalCompletion</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#exceptionTable相关"><span class="toc-number">3.3.10.</span> <span class="toc-text">exceptionTable相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ExceptionNode"><span class="toc-number">3.3.11.</span> <span class="toc-text">ExceptionNode</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#expungeStaleExceptions"><span class="toc-number">3.3.12.</span> <span class="toc-text">expungeStaleExceptions</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#externalAwaitDone"><span class="toc-number">3.3.13.</span> <span class="toc-text">externalAwaitDone</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#get"><span class="toc-number">3.3.14.</span> <span class="toc-text">get</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#externalInterruptibleAwaitDone"><span class="toc-number">3.3.15.</span> <span class="toc-text">externalInterruptibleAwaitDone</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#invoke"><span class="toc-number">3.3.16.</span> <span class="toc-text">invoke</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#doInvoke"><span class="toc-number">3.3.17.</span> <span class="toc-text">doInvoke</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#invokeAll"><span class="toc-number">3.3.18.</span> <span class="toc-text">invokeAll</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#quietlyInvoke"><span class="toc-number">3.3.19.</span> <span class="toc-text">quietlyInvoke</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#quietlyJoin"><span class="toc-number">3.3.20.</span> <span class="toc-text">quietlyJoin</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#cancel"><span class="toc-number">3.3.21.</span> <span class="toc-text">cancel</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#tryUnfork"><span class="toc-number">3.3.22.</span> <span class="toc-text">tryUnfork</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#reinitialize"><span class="toc-number">3.3.23.</span> <span class="toc-text">reinitialize</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#helpQuiesce"><span class="toc-number">3.3.24.</span> <span class="toc-text">helpQuiesce</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#getSurplusQueuedTaskCount"><span class="toc-number">3.3.25.</span> <span class="toc-text">getSurplusQueuedTaskCount</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#子类实现"><span class="toc-number">3.4.</span> <span class="toc-text">子类实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#RecursiveTask-1"><span class="toc-number">3.4.1.</span> <span class="toc-text">RecursiveTask</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RecursiveAction-1"><span class="toc-number">3.4.2.</span> <span class="toc-text">RecursiveAction</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CountedCompleter"><span class="toc-number">3.4.3.</span> <span class="toc-text">CountedCompleter</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ForkJoinWorkerThread-1"><span class="toc-number">4.</span> <span class="toc-text">ForkJoinWorkerThread</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#类声明-1"><span class="toc-number">4.1.</span> <span class="toc-text">类声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#成员变量"><span class="toc-number">4.2.</span> <span class="toc-text">成员变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#构造函数"><span class="toc-number">4.3.</span> <span class="toc-text">构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#方法"><span class="toc-number">4.4.</span> <span class="toc-text">方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#getPool"><span class="toc-number">4.4.1.</span> <span class="toc-text">getPool</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#getPoolIndex"><span class="toc-number">4.4.2.</span> <span class="toc-text">getPoolIndex</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#onStart"><span class="toc-number">4.4.3.</span> <span class="toc-text">onStart</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#onTermination"><span class="toc-number">4.4.4.</span> <span class="toc-text">onTermination</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#run"><span class="toc-number">4.4.5.</span> <span class="toc-text">run</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#eraseThreadLocals"><span class="toc-number">4.4.6.</span> <span class="toc-text">eraseThreadLocals</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#afterTopLevelExec"><span class="toc-number">4.4.7.</span> <span class="toc-text">afterTopLevelExec</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#子类"><span class="toc-number">4.5.</span> <span class="toc-text">子类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#并行可窃取的分治查找算法"><span class="toc-number">4.6.</span> <span class="toc-text">并行可窃取的分治查找算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#跨节点（Map-Reduce）"><span class="toc-number">4.7.</span> <span class="toc-text">跨节点（Map,Reduce）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#WorkQueue"><span class="toc-number">5.</span> <span class="toc-text">WorkQueue</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#类声明-2"><span class="toc-number">5.1.</span> <span class="toc-text">类声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#构造函数-1"><span class="toc-number">5.2.</span> <span class="toc-text">构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#相关成员"><span class="toc-number">5.3.</span> <span class="toc-text">相关成员</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#静态函数"><span class="toc-number">5.4.</span> <span class="toc-text">静态函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#方法-1"><span class="toc-number">5.5.</span> <span class="toc-text">方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#getPoolIndex-1"><span class="toc-number">5.5.1.</span> <span class="toc-text">getPoolIndex</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#queueSize"><span class="toc-number">5.5.2.</span> <span class="toc-text">queueSize</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#isEmpty"><span class="toc-number">5.5.3.</span> <span class="toc-text">isEmpty</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#push"><span class="toc-number">5.5.4.</span> <span class="toc-text">push</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#growArray"><span class="toc-number">5.5.5.</span> <span class="toc-text">growArray</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pop"><span class="toc-number">5.5.6.</span> <span class="toc-text">pop</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pollAt"><span class="toc-number">5.5.7.</span> <span class="toc-text">pollAt</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#poll"><span class="toc-number">5.5.8.</span> <span class="toc-text">poll</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#nextLocalTask"><span class="toc-number">5.5.9.</span> <span class="toc-text">nextLocalTask</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#peek"><span class="toc-number">5.5.10.</span> <span class="toc-text">peek</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#tryUnpush"><span class="toc-number">5.5.11.</span> <span class="toc-text">tryUnpush</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#cancelAll"><span class="toc-number">5.5.12.</span> <span class="toc-text">cancelAll</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pollAndExecAll"><span class="toc-number">5.5.13.</span> <span class="toc-text">pollAndExecAll</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#execLocalTasks"><span class="toc-number">5.5.14.</span> <span class="toc-text">execLocalTasks</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#runTask"><span class="toc-number">5.5.15.</span> <span class="toc-text">runTask</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#transferStealCount"><span class="toc-number">5.5.16.</span> <span class="toc-text">transferStealCount</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#tryRemoveAndExec"><span class="toc-number">5.5.17.</span> <span class="toc-text">tryRemoveAndExec</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#popCC"><span class="toc-number">5.5.18.</span> <span class="toc-text">popCC</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pollAndExecCC"><span class="toc-number">5.5.19.</span> <span class="toc-text">pollAndExecCC</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#isApparentlyUnblocked"><span class="toc-number">5.5.20.</span> <span class="toc-text">isApparentlyUnblocked</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ForkJoinPool详解"><span class="toc-number">6.</span> <span class="toc-text">ForkJoinPool详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#类声明-3"><span class="toc-number">6.1.</span> <span class="toc-text">类声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#构造函数-2"><span class="toc-number">6.2.</span> <span class="toc-text">构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Executors构建"><span class="toc-number">6.3.</span> <span class="toc-text">Executors构建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程工厂"><span class="toc-number">6.4.</span> <span class="toc-text">线程工厂</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#提交任务"><span class="toc-number">6.5.</span> <span class="toc-text">提交任务</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#invoke-1"><span class="toc-number">6.5.1.</span> <span class="toc-text">invoke</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#execute"><span class="toc-number">6.5.2.</span> <span class="toc-text">execute</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#submit"><span class="toc-number">6.5.3.</span> <span class="toc-text">submit</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#方法-2"><span class="toc-number">6.6.</span> <span class="toc-text">方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#lockRunState"><span class="toc-number">6.6.1.</span> <span class="toc-text">lockRunState</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#awaitRunStateLock"><span class="toc-number">6.6.2.</span> <span class="toc-text">awaitRunStateLock</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#createWorker"><span class="toc-number">6.6.3.</span> <span class="toc-text">createWorker</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#tryAddWorker"><span class="toc-number">6.6.4.</span> <span class="toc-text">tryAddWorker</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#registerWorker"><span class="toc-number">6.6.5.</span> <span class="toc-text">registerWorker</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#nextSecondarySeed"><span class="toc-number">6.6.6.</span> <span class="toc-text">nextSecondarySeed</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#localInit"><span class="toc-number">6.6.7.</span> <span class="toc-text">localInit</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#deregisterWorker"><span class="toc-number">6.6.8.</span> <span class="toc-text">deregisterWorker</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#signalWork"><span class="toc-number">6.6.9.</span> <span class="toc-text">signalWork</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#tryRelease"><span class="toc-number">6.6.10.</span> <span class="toc-text">tryRelease</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#runWorker"><span class="toc-number">6.6.11.</span> <span class="toc-text">runWorker</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#scan"><span class="toc-number">6.6.12.</span> <span class="toc-text">scan</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#awaitWork"><span class="toc-number">6.6.13.</span> <span class="toc-text">awaitWork</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#helpComplete"><span class="toc-number">6.6.14.</span> <span class="toc-text">helpComplete</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#helpStealer"><span class="toc-number">6.6.15.</span> <span class="toc-text">helpStealer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#tryCompensate"><span class="toc-number">6.6.16.</span> <span class="toc-text">tryCompensate</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#awaitJoin"><span class="toc-number">6.6.17.</span> <span class="toc-text">awaitJoin</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#findNonEmptyStealQueue"><span class="toc-number">6.6.18.</span> <span class="toc-text">findNonEmptyStealQueue</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#helpQuiescePool"><span class="toc-number">6.6.19.</span> <span class="toc-text">helpQuiescePool</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#nextTaskFor"><span class="toc-number">6.6.20.</span> <span class="toc-text">nextTaskFor</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#tryTerminate"><span class="toc-number">6.6.21.</span> <span class="toc-text">tryTerminate</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#externalSubmit"><span class="toc-number">6.6.22.</span> <span class="toc-text">externalSubmit</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#externalPush"><span class="toc-number">6.6.23.</span> <span class="toc-text">externalPush</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#tryExternalUnpush"><span class="toc-number">6.6.24.</span> <span class="toc-text">tryExternalUnpush</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#externalHelpComplete"><span class="toc-number">6.6.25.</span> <span class="toc-text">externalHelpComplete</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#invoke-2"><span class="toc-number">6.6.26.</span> <span class="toc-text">invoke</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#execute-1"><span class="toc-number">6.6.27.</span> <span class="toc-text">execute</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#execute-2"><span class="toc-number">6.6.28.</span> <span class="toc-text">execute</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#submit-1"><span class="toc-number">6.6.29.</span> <span class="toc-text">submit</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#invokeAll-1"><span class="toc-number">6.6.30.</span> <span class="toc-text">invokeAll</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#getRunningThreadCount"><span class="toc-number">6.6.31.</span> <span class="toc-text">getRunningThreadCount</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#getActiveThreadCount"><span class="toc-number">6.6.32.</span> <span class="toc-text">getActiveThreadCount</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#isQuiescent"><span class="toc-number">6.6.33.</span> <span class="toc-text">isQuiescent</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#shutdown"><span class="toc-number">6.6.34.</span> <span class="toc-text">shutdown</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#shutdownNow"><span class="toc-number">6.6.35.</span> <span class="toc-text">shutdownNow</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#isTerminated"><span class="toc-number">6.6.36.</span> <span class="toc-text">isTerminated</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#isTerminating"><span class="toc-number">6.6.37.</span> <span class="toc-text">isTerminating</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#isShutdown"><span class="toc-number">6.6.38.</span> <span class="toc-text">isShutdown</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#awaitTermination"><span class="toc-number">6.6.39.</span> <span class="toc-text">awaitTermination</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#awaitQuiescence"><span class="toc-number">6.6.40.</span> <span class="toc-text">awaitQuiescence</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ManagedBlocker"><span class="toc-number">7.</span> <span class="toc-text">ManagedBlocker</span></a></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(https://blog.huhdcc.top/image/hexo/image-20200719101018337.png)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Here will be a new beginning</a></span><span class="pull_right menus"><div id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">多线程高阶-52-ForkJoin详解</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-07-19 10:09:31"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-07-19</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-07-23 16:59:43"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-07-23</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/JAVA/">JAVA</a><i class="fa fa-angle-right post-meta__separator" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/JAVA/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a></span></div><div class="meta-secondline"> <span class="post-meta-wordcount"><i class="post-meta__icon fa fa-file-word-o" aria-hidden="true"></i><span>字数总计:</span><span class="word-count">38.3k</span><span class="post-meta__separator">|</span><i class="post-meta__icon fa fa-clock-o" aria-hidden="true"></i><span>阅读时长: 150 分钟</span></span></div><div class="meta-thirdline"><span class="post-meta-pv-cv"></span><span class="post-meta-commentcount"></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><p><img src="/image/hexo/image-20200719101018337.png" alt="image-20200719101018337"></p>
<p><img src="/image/hexo/image-20200719102418252.png" alt="image-20200719102418252"></p>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><h3 id="RecursiveTask"><a href="#RecursiveTask" class="headerlink" title="RecursiveTask"></a>RecursiveTask</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ForkJoinPool forkJoinPool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">    ForkJoinTask&lt;Integer&gt; futureTask = forkJoinPool.submit(<span class="keyword">new</span> CalculatedRecursiveTask(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">    System.out.println(futureTask.get());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Integer MAX_SIZE = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//RecursiveTask</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CalculatedRecursiveTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">java</span>.<span class="title">lang</span>.<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> start;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> end;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CalculatedRecursiveTask</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> java.lang.<span class="function">Integer <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (end - start &lt;= MAX_SIZE) &#123;</span><br><span class="line">            <span class="keyword">return</span> IntStream.rangeClosed(start, end).sum();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> middle = (start + end) / <span class="number">2</span>;</span><br><span class="line">            CalculatedRecursiveTask left = <span class="keyword">new</span> CalculatedRecursiveTask(start, middle);</span><br><span class="line">            CalculatedRecursiveTask right = <span class="keyword">new</span> CalculatedRecursiveTask(middle + <span class="number">1</span>, end);</span><br><span class="line">            left.fork();</span><br><span class="line">            right.fork();</span><br><span class="line">            <span class="keyword">return</span> left.join() + right.join();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="RecursiveAction"><a href="#RecursiveAction" class="headerlink" title="RecursiveAction"></a>RecursiveAction</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger sum = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ForkJoinPool forkJoinPool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">    forkJoinPool.submit(<span class="keyword">new</span> CalculatedRecursiveTask(<span class="number">1</span>, <span class="number">100</span>));</span><br><span class="line">    forkJoinPool.awaitQuiescence(<span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">    System.out.println(sum.get());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Integer MAX_SIZE = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//RecursiveAction</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CalculatedRecursiveTask</span> <span class="keyword">extends</span> <span class="title">RecursiveAction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> start;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> end;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CalculatedRecursiveTask</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (end - start &lt;= MAX_SIZE) &#123;</span><br><span class="line">            sum.getAndAdd(IntStream.rangeClosed(start, end).sum());</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> middle = (start + end) / <span class="number">2</span>;</span><br><span class="line">            CalculatedRecursiveTask left = <span class="keyword">new</span> CalculatedRecursiveTask(start, middle);</span><br><span class="line">            CalculatedRecursiveTask right = <span class="keyword">new</span> CalculatedRecursiveTask(middle + <span class="number">1</span>, end);</span><br><span class="line">            left.fork();</span><br><span class="line">            right.fork();</span><br><span class="line">            left.join();</span><br><span class="line">            right.join();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>&emsp;&emsp;<strong>ForkJoin</strong>的理念可以使用<strong>分而治之</strong>来理解。把一个比较难处理的任务细化为多个任务，若是还不能解决那么可以再进行细化，最终将各个分支把处理的结果进行合并。</p>
<p>&emsp;&emsp;这个理念其实是比较常规的，大家都能很容易的想到，并且能够熟练的运用。但是它还运用了<strong>work-stealing</strong>算法(工作窃取)，该算法主要是把分解以后的多个任务放入了多个双端队列，那么工作线程可以从头部或者尾部获取任务。如果某个线程的任务执行完毕，那么它可以从其他线程中获取没有执行完毕的任务（从尾部获取），这样充分的利用线程的空余时间。</p>
<p><img src="/image/hexo/image-20200719205547339.png" alt="image-20200719205547339"></p>
<h3 id="主要的角色"><a href="#主要的角色" class="headerlink" title="主要的角色"></a>主要的角色</h3><p><strong>ForkJoinPool</strong>:</p>
<p>&emsp;&emsp;<strong>ForkJoin</strong>的管理者，任务都需要提交给它去处理，负责了整个<strong>workerThread</strong>的创建以及激活等操作、<strong>workQueue</strong>的创建以及分配等操作，它相当于整个<strong>ForkJoin</strong>的容器。</p>
<h3 id="ForkJoinWorkerThread"><a href="#ForkJoinWorkerThread" class="headerlink" title="ForkJoinWorkerThread:"></a>ForkJoinWorkerThread:</h3><p>&emsp;&emsp;工作线程，处理任务的线程。内部有一个<strong>ForkJoinPool.WorkQueue</strong>的任务队列，<strong>WorkQueue</strong>依赖与<strong>ForkJoinPool</strong>。</p>
<h3 id="ForkJoinPool-WorkQueue"><a href="#ForkJoinPool-WorkQueue" class="headerlink" title="ForkJoinPool.WorkQueue:"></a>ForkJoinPool.WorkQueue:</h3><p>&emsp;&emsp;双端任务队列，主要存储了当前线程需要执行的任务，<code>工作窃取</code>就是通过尾部获取未执行的任务。</p>
<h3 id="ForkJoinTask："><a href="#ForkJoinTask：" class="headerlink" title="ForkJoinTask："></a>ForkJoinTask：</h3><p>&emsp;&emsp;任务类型(<strong>RecursiveTask、RecursiveAction</strong>),<code>RecursiveTask</code>：主要是有返回值。<code>RecursiveAction</code>:不具备返回值。<code>fork</code>用于分解任务并异步执行，<code>join</code>用于处理任务执行完毕执行结果的合并。</p>
<h2 id="ForkJoinTask详解"><a href="#ForkJoinTask详解" class="headerlink" title="ForkJoinTask详解"></a>ForkJoinTask详解</h2><h3 id="类声明"><a href="#类声明" class="headerlink" title="类声明"></a>类声明</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt;, <span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure>

<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//任务状态值、通过ForkJoinPool或者工作线程去修改</span></span><br><span class="line"><span class="comment">//volatile保证内存可见性</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> status;</span><br><span class="line"><span class="comment">//用于屏蔽完成状态位</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DONE_MASK   = <span class="number">0xf0000000</span>;</span><br><span class="line"><span class="comment">//表示正常完成（负值）</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NORMAL      = <span class="number">0xf0000000</span>;</span><br><span class="line"><span class="comment">//表示被取消(负值且&lt; NORMAL)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED   = <span class="number">0xc0000000</span>;</span><br><span class="line"><span class="comment">//异常完成(负值且&lt;CANCELLED)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCEPTIONAL = <span class="number">0x80000000</span>;</span><br><span class="line"><span class="comment">//用于signal(1&lt;&lt;16)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL      = <span class="number">0x00010000</span>;</span><br><span class="line"><span class="comment">//后十六位的task标签</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SMASK       = <span class="number">0x0000ffff</span>;</span><br></pre></td></tr></table></figure>

<p><img src="/image/hexo/image-20200720074842646.png" alt="image-20200720074842646"></p>
<h3 id="常见方法"><a href="#常见方法" class="headerlink" title="常见方法"></a>常见方法</h3><h4 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ForkJoinTask&lt;V&gt; <span class="title">fork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t;</span><br><span class="line">    <span class="comment">//判断当前的线程是否是ForkJoinWorkerThread</span></span><br><span class="line">    <span class="keyword">if</span> ((t = Thread.currentThread()) <span class="keyword">instanceof</span> ForkJoinWorkerThread)</span><br><span class="line">        <span class="comment">//尝试将任务添加到workQueue中</span></span><br><span class="line">        ((ForkJoinWorkerThread)t).workQueue.push(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//尝试将任务添加到common的线程池中</span></span><br><span class="line">        ForkJoinPool.common.externalPush(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="join"><a href="#join" class="headerlink" title="join"></a>join</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">join</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s;</span><br><span class="line">    <span class="comment">//doJoin会尝试获取任务执行的结果</span></span><br><span class="line">    <span class="keyword">if</span> ((s = doJoin() &amp; DONE_MASK) != NORMAL)</span><br><span class="line">        reportException(s);</span><br><span class="line">    <span class="keyword">return</span> getRawResult();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="doJoin"><a href="#doJoin" class="headerlink" title="doJoin"></a>doJoin</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">doJoin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s; Thread t; ForkJoinWorkerThread wt; ForkJoinPool.WorkQueue w;</span><br><span class="line">    <span class="comment">//如果任务执行完毕返回status</span></span><br><span class="line">    <span class="keyword">return</span> (s = status) &lt; <span class="number">0</span> ? s :</span><br><span class="line">    	<span class="comment">//判断当前是否是ForkJoinWorkerThread</span></span><br><span class="line">        ((t = Thread.currentThread()) <span class="keyword">instanceof</span> ForkJoinWorkerThread) ?</span><br><span class="line">        (w = (wt = (ForkJoinWorkerThread)t).workQueue).</span><br><span class="line">        <span class="comment">//尝试从任务队列取出this、并且执行恩物    </span></span><br><span class="line">        tryUnpush(<span class="keyword">this</span>) &amp;&amp; (s = doExec()) &lt; <span class="number">0</span> ? s :</span><br><span class="line">    	<span class="comment">//等待任务执行结束、会尝试帮助其他的线程完成任务</span></span><br><span class="line">        wt.pool.awaitJoin(w, <span class="keyword">this</span>, <span class="number">0L</span>) :</span><br><span class="line">        externalAwaitDone();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="setCompletion"><a href="#setCompletion" class="headerlink" title="setCompletion"></a>setCompletion</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//主要用于标记当前task的completion状态</span></span><br><span class="line"><span class="comment">//满足条件则唤醒等待该task的线程</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">setCompletion</span><span class="params">(<span class="keyword">int</span> completion)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> s;;) &#123;</span><br><span class="line">        <span class="comment">//如果当前task的status已经完成(&lt;0)，返回status</span></span><br><span class="line">        <span class="comment">//status可能是某一次循环被其他线程操作完全</span></span><br><span class="line">        <span class="keyword">if</span> ((s = status) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        <span class="comment">//CAS:尝试将原来的status设置为它与completion位或的结果</span></span><br><span class="line">        <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, STATUS, s, s | completion)) &#123;</span><br><span class="line">            <span class="comment">//SIGNAL标记</span></span><br><span class="line">            <span class="comment">//task只要完成(发生异常或取消)，或者completion传入的值1&lt;&lt;16</span></span><br><span class="line">            <span class="comment">//唤醒其他的线程</span></span><br><span class="line">            <span class="keyword">if</span> ((s &gt;&gt;&gt; <span class="number">16</span>) != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123; notifyAll(); &#125;</span><br><span class="line">            <span class="comment">//CAS成功、返回参数中的completion</span></span><br><span class="line">            <span class="keyword">return</span> completion;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="doExec"><a href="#doExec" class="headerlink" title="doExec"></a>doExec</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//运行ForkJoinTask的核心</span></span><br><span class="line"><span class="comment">//使用final修饰</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">doExec</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s; <span class="keyword">boolean</span> completed;</span><br><span class="line">    <span class="comment">//如果任务未完成则会继续运行</span></span><br><span class="line">    <span class="keyword">if</span> ((s = status) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//exec</span></span><br><span class="line">            completed = exec();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable rex) &#123;</span><br><span class="line">            <span class="comment">//发生异常情况、setExceptionalCompletion设置结果</span></span><br><span class="line">            <span class="keyword">return</span> setExceptionalCompletion(rex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (completed)</span><br><span class="line">            <span class="comment">//正常完成、调用setCompletio将返回s</span></span><br><span class="line">            s = setCompletion(NORMAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="setExceptionalCompletion"><a href="#setExceptionalCompletion" class="headerlink" title="setExceptionalCompletion"></a>setExceptionalCompletion</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//主要用于记录异常并且在满足条件的情形下传播异常</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">setExceptionalCompletion</span><span class="params">(Throwable ex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//记录异常信息到结果</span></span><br><span class="line">    <span class="keyword">int</span> s = recordExceptionalCompletion(ex);</span><br><span class="line">    <span class="keyword">if</span> ((s &amp; DONE_MASK) == EXCEPTIONAL)</span><br><span class="line">        <span class="comment">//status去除非完成标志位 == EXCEPTIONAL</span></span><br><span class="line">        <span class="comment">//内部传播异常</span></span><br><span class="line">        <span class="comment">//internalPropagateException空的方法，需要子类去实现</span></span><br><span class="line">        internalPropagateException(ex);</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="reportException"><a href="#reportException" class="headerlink" title="reportException"></a>reportException</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//任务执行期间抛出未捕获的异常或者被取消</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reportException</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == CANCELLED)</span><br><span class="line">        <span class="comment">//任务取消抛出CancellationException</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CancellationException();</span><br><span class="line">    <span class="keyword">if</span> (s == EXCEPTIONAL)</span><br><span class="line">        <span class="comment">//未捕获异常则通过rethrow包装为RunTimeException</span></span><br><span class="line">        rethrow(getThrowableException());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="getThrowableException"><a href="#getThrowableException" class="headerlink" title="getThrowableException"></a>getThrowableException</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取给定任务的执行异常</span></span><br><span class="line"><span class="comment">//如果异常不是当前的线程抛出</span></span><br><span class="line"><span class="comment">//尝试以记录的异常为原因创建一个与抛出异常类型相同的新的异常</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Throwable <span class="title">getThrowableException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((status &amp; DONE_MASK) != EXCEPTIONAL)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//通过当前任务对象的哈希值从哈希链表中找到对应的异常节点</span></span><br><span class="line">    <span class="keyword">int</span> h = System.identityHashCode(<span class="keyword">this</span>);</span><br><span class="line">    ExceptionNode e;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = exceptionTableLock;</span><br><span class="line">    <span class="comment">//加锁操作</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//清理被GC回收的任务的异常节点</span></span><br><span class="line">        expungeStaleExceptions();</span><br><span class="line">        ExceptionNode[] t = exceptionTable;</span><br><span class="line">      	<span class="comment">//取模运算获取对应的索引进而获取哈希数组槽位中的节点</span></span><br><span class="line">        e = t[h &amp; (t.length - <span class="number">1</span>)];</span><br><span class="line">      	<span class="comment">//遍历找到当前任务对应的异常节点</span></span><br><span class="line">        <span class="keyword">while</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() != <span class="keyword">this</span>)</span><br><span class="line">            e = e.next;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//解锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    Throwable ex;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span> || (ex = e.ex) == <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">//没有出现任何的异常、退出</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//存在异常、当不是当前线程所抛出</span></span><br><span class="line">    <span class="keyword">if</span> (e.thrower != Thread.currentThread().getId()) &#123;</span><br><span class="line">        <span class="comment">//反射找到构造方法、并且开始构造一个新的异常</span></span><br><span class="line">        Class&lt;? extends Throwable&gt; ec = ex.getClass();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Constructor&lt;?&gt; noArgCtor = <span class="keyword">null</span>;</span><br><span class="line">            Constructor&lt;?&gt;[] cs = ec.getConstructors();<span class="comment">// public ctors only</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cs.length; ++i) &#123;</span><br><span class="line">                Constructor&lt;?&gt; c = cs[i];</span><br><span class="line">                Class&lt;?&gt;[] ps = c.getParameterTypes();</span><br><span class="line">                <span class="keyword">if</span> (ps.length == <span class="number">0</span>)</span><br><span class="line">                    <span class="comment">//标记无参构造方法、在没有找到期望的构造方法的时候去使用</span></span><br><span class="line">                    noArgCtor = c;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ps.length == <span class="number">1</span> &amp;&amp; ps[<span class="number">0</span>] == Throwable<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                    <span class="comment">//发现了期望的Throwable类型的参数的构造方法</span></span><br><span class="line">                    Throwable wx = (Throwable)c.newInstance(ex);</span><br><span class="line">                    <span class="keyword">return</span> (wx == <span class="keyword">null</span>) ? ex : wx;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//没有找到期望的构造方法</span></span><br><span class="line">            <span class="keyword">if</span> (noArgCtor != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//通过无参构造的方法进行构建一个新的异常</span></span><br><span class="line">                Throwable wx = (Throwable)(noArgCtor.newInstance());</span><br><span class="line">                <span class="keyword">if</span> (wx != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//设置原始的异常信息</span></span><br><span class="line">                    wx.initCause(ex);</span><br><span class="line">                    <span class="keyword">return</span> wx;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ignore) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="recordExceptionalCompletion"><a href="#recordExceptionalCompletion" class="headerlink" title="recordExceptionalCompletion"></a>recordExceptionalCompletion</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//记录异常</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">recordExceptionalCompletion</span><span class="params">(Throwable ex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s;</span><br><span class="line">    <span class="keyword">if</span> ((s = status) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//判断是否是异常的状态status</span></span><br><span class="line">        <span class="comment">//禁止重写hash值，不适用子类的hashCode函数</span></span><br><span class="line">        <span class="keyword">int</span> h = System.identityHashCode(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = exceptionTableLock;</span><br><span class="line">        <span class="comment">//获取异常锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//抹除脏异常数据</span></span><br><span class="line">            expungeStaleExceptions();</span><br><span class="line">            <span class="comment">//异常表数组，exceptionTable全局静态变量</span></span><br><span class="line">            ExceptionNode[] t = exceptionTable;</span><br><span class="line">            <span class="comment">//通过hash值和数组长度进行一个运算获取一个初始的索引</span></span><br><span class="line">            <span class="keyword">int</span> i = h &amp; (t.length - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (ExceptionNode e = t[i]; ; e = e.next) &#123;</span><br><span class="line">                <span class="comment">//找到空的索引位</span></span><br><span class="line">                <span class="keyword">if</span> (e == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//创建一个新的ExceptionNode、保存this</span></span><br><span class="line">                    <span class="comment">//退出循环</span></span><br><span class="line">                    t[i] = <span class="keyword">new</span> ExceptionNode(<span class="keyword">this</span>, ex, t[i]);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果已经设置了相同的元素在索引中、退出循环</span></span><br><span class="line">                <span class="keyword">if</span> (e.get() == <span class="keyword">this</span>) </span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//记录成功、更新task为异常完成</span></span><br><span class="line">        s = setCompletion(EXCEPTIONAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="exceptionTable相关"><a href="#exceptionTable相关" class="headerlink" title="exceptionTable相关"></a>exceptionTable相关</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全局异常Node表</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ExceptionNode[] exceptionTable;</span><br><span class="line"><span class="comment">//异常可重入锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ReentrantLock exceptionTableLock;</span><br><span class="line"><span class="comment">//变量表引用队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ReferenceQueue&lt;Object&gt; exceptionTableRefQueue;</span><br><span class="line"><span class="comment">//异常表的固定容量32</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCEPTION_MAP_CAPACITY = <span class="number">32</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化操作</span></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    exceptionTableLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    exceptionTableRefQueue = <span class="keyword">new</span> ReferenceQueue&lt;Object&gt;();</span><br><span class="line">    exceptionTable = <span class="keyword">new</span> ExceptionNode[EXCEPTION_MAP_CAPACITY];</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        U = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">        Class&lt;?&gt; k = ForkJoinTask<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        STATUS = U.objectFieldOffset</span><br><span class="line">            (k.getDeclaredField(<span class="string">"status"</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ExceptionNode"><a href="#ExceptionNode" class="headerlink" title="ExceptionNode"></a>ExceptionNode</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ExceptionNode实现了一个弱引用</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionNode</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ForkJoinTask</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Throwable ex;</span><br><span class="line">    ExceptionNode next;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> thrower;  <span class="comment">// use id not ref to avoid weak cycles</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hashCode;  <span class="comment">// store task hashCode before weak ref disappears</span></span><br><span class="line">    ExceptionNode(ForkJoinTask&lt;?&gt; task, Throwable ex, ExceptionNode next) &#123;</span><br><span class="line">        <span class="comment">//指向弱引用的构造函数</span></span><br><span class="line">        <span class="comment">//保存引用为task</span></span><br><span class="line">        <span class="comment">//全局队列</span></span><br><span class="line">        <span class="keyword">super</span>(task, exceptionTableRefQueue);</span><br><span class="line">        <span class="comment">//抛出异常的引用</span></span><br><span class="line">        <span class="keyword">this</span>.ex = ex;</span><br><span class="line">        <span class="comment">//ExceptionNode以链表的方式存在</span></span><br><span class="line">        <span class="comment">//先入者为后入者的</span></span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="comment">//保存抛出异常的线程ID</span></span><br><span class="line">        <span class="keyword">this</span>.thrower = Thread.currentThread().getId();</span><br><span class="line">        <span class="comment">//hash码保存关联的task的哈希值</span></span><br><span class="line">        <span class="keyword">this</span>.hashCode = System.identityHashCode(task);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="expungeStaleExceptions"><a href="#expungeStaleExceptions" class="headerlink" title="expungeStaleExceptions"></a>expungeStaleExceptions</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//清除异常表中的脏数据</span></span><br><span class="line"><span class="comment">//持有全局锁才可使用</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">expungeStaleExceptions</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//进入转换</span></span><br><span class="line">    <span class="comment">//exceptionTableRefQueue不为空，且</span></span><br><span class="line">    <span class="keyword">for</span> (Object x; (x = exceptionTableRefQueue.poll()) != <span class="keyword">null</span>;) &#123;</span><br><span class="line">        <span class="comment">//依次获取元素</span></span><br><span class="line">        <span class="keyword">if</span> (x <span class="keyword">instanceof</span> ExceptionNode) &#123;</span><br><span class="line">            <span class="comment">//计算在exceptionTable中的索引</span></span><br><span class="line">            <span class="keyword">int</span> hashCode = ((ExceptionNode)x).hashCode;</span><br><span class="line">            ExceptionNode[] t = exceptionTable;</span><br><span class="line">            <span class="keyword">int</span> i = hashCode &amp; (t.length - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//取出Node</span></span><br><span class="line">            ExceptionNode e = t[i];</span><br><span class="line">            ExceptionNode pred = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//进入循环、直到e为null就停止</span></span><br><span class="line">            <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                ExceptionNode next = e.next;</span><br><span class="line">                <span class="comment">//x:队首出对的元素</span></span><br><span class="line">                <span class="keyword">if</span> (e == x) &#123;</span><br><span class="line">                    <span class="comment">//pred:没有前置元素，e排在链表的首位</span></span><br><span class="line">                    <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">                        <span class="comment">//没有前置元素、直接修改引用指向了next</span></span><br><span class="line">                        t[i] = next;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        <span class="comment">//存在了前置的元素、说明循环过N次、跳出循环</span></span><br><span class="line">                        pred.next = next;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果当前e不是x，准备开启下一轮循环、pred指向了e，进行下一个元素的比窘</span></span><br><span class="line">                pred = e;</span><br><span class="line">                e = next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="externalAwaitDone"><a href="#externalAwaitDone" class="headerlink" title="externalAwaitDone"></a>externalAwaitDone</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//等待未完成的非ForkJoinWorkerThread线程提交的任务</span></span><br><span class="line"><span class="comment">//返回任务执行的结果</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">externalAwaitDone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1.如果是CountedCompleter任务、等待externalHelpComplete返回</span></span><br><span class="line">    <span class="comment">//2.否则ForkJoinPool.common.tryExternalUnpush(this)返回doExec结果</span></span><br><span class="line">    <span class="comment">//3.否则返回0</span></span><br><span class="line">    <span class="keyword">int</span> s = ((<span class="keyword">this</span> <span class="keyword">instanceof</span> CountedCompleter) ? <span class="comment">// try helping</span></span><br><span class="line">             ForkJoinPool.common.externalHelpComplete(</span><br><span class="line">                 <span class="comment">//辅助完成外部提交的externalHelpComplete任务</span></span><br><span class="line">                 (CountedCompleter&lt;?&gt;)<span class="keyword">this</span>, <span class="number">0</span>) :</span><br><span class="line">             <span class="comment">//辅助完成外部提交的非externalHelpComplete任务</span></span><br><span class="line">             ForkJoinPool.common.tryExternalUnpush(<span class="keyword">this</span>) ? doExec() : <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//任务还未执行完毕、阻塞等待</span></span><br><span class="line">    <span class="keyword">if</span> (s &gt;= <span class="number">0</span> &amp;&amp; (s = status) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">//标记有线程需要被唤醒</span></span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, STATUS, s, s | SIGNAL)) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (status &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="comment">//任务未执行完毕、陷入阻塞等待被唤醒</span></span><br><span class="line">                            wait(<span class="number">0L</span>);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                            interrupted = <span class="keyword">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        <span class="comment">//任务执行完毕、唤醒所有陷入阻塞的线程</span></span><br><span class="line">                        notifyAll();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((s = status) &gt;= <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (interrupted)</span><br><span class="line">            <span class="comment">//中断线程</span></span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="get"><a href="#get" class="headerlink" title="get"></a>get</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取异步任务的执行结果</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">    <span class="comment">//如果是ForkJoinWorkerThread则执行doJoin否则externalInterruptibleAwaitDone</span></span><br><span class="line">    <span class="keyword">int</span> s = (Thread.currentThread() <span class="keyword">instanceof</span> ForkJoinWorkerThread) ?</span><br><span class="line">        doJoin() : externalInterruptibleAwaitDone();</span><br><span class="line">    Throwable ex;</span><br><span class="line">    <span class="keyword">if</span> ((s &amp;= DONE_MASK) == CANCELLED)</span><br><span class="line">        <span class="comment">//如果任务被取消抛出CancellationException</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CancellationException();</span><br><span class="line">    <span class="keyword">if</span> (s == EXCEPTIONAL &amp;&amp; (ex = getThrowableException()) != <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">//任务执行过程中出现异常则抛出对应的异常信息</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ExecutionException(ex);</span><br><span class="line">    <span class="keyword">return</span> getRawResult();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="externalInterruptibleAwaitDone"><a href="#externalInterruptibleAwaitDone" class="headerlink" title="externalInterruptibleAwaitDone"></a>externalInterruptibleAwaitDone</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//阻塞非ForkJoinWorkerThread线程</span></span><br><span class="line"><span class="comment">//等待任务执行完毕或中断线程</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">externalInterruptibleAwaitDone</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">if</span> ((s = status) &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (s = ((<span class="keyword">this</span> <span class="keyword">instanceof</span> CountedCompleter) ?</span><br><span class="line">              ForkJoinPool.common.externalHelpComplete(</span><br><span class="line">                  (CountedCompleter&lt;?&gt;)<span class="keyword">this</span>, <span class="number">0</span>) :</span><br><span class="line">              ForkJoinPool.common.tryExternalUnpush(<span class="keyword">this</span>) ? doExec() :</span><br><span class="line">              <span class="number">0</span>)) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//任务需要阻塞陷入等待</span></span><br><span class="line">        <span class="keyword">while</span> ((s = status) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, STATUS, s, s | SIGNAL)) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (status &gt;= <span class="number">0</span>)</span><br><span class="line">                        <span class="comment">//陷入阻塞等待</span></span><br><span class="line">                        wait(<span class="number">0L</span>);</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        <span class="comment">//唤醒等待中的所有的线程</span></span><br><span class="line">                        notifyAll();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="invoke"><a href="#invoke" class="headerlink" title="invoke"></a>invoke</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//开始执行任务、等待执行并返回任务执行的结果</span></span><br><span class="line"><span class="comment">//出现异常、则抛出对应的未捕获的异常</span></span><br><span class="line"><span class="comment">//如果中断了线程并不会立即返回、而是等待任务执行有了结果才会对中断状态进行补偿</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">invoke</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s;</span><br><span class="line">    <span class="keyword">if</span> ((s = doInvoke() &amp; DONE_MASK) != NORMAL)</span><br><span class="line">        reportException(s);</span><br><span class="line">    <span class="keyword">return</span> getRawResult();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="doInvoke"><a href="#doInvoke" class="headerlink" title="doInvoke"></a>doInvoke</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">doInvoke</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s; Thread t; ForkJoinWorkerThread wt;</span><br><span class="line">    <span class="comment">//执行任务、执行完毕返回status</span></span><br><span class="line">    <span class="keyword">return</span> (s = doExec()) &lt; <span class="number">0</span> ? s :</span><br><span class="line">    	<span class="comment">//如果当前线程是ForkJoinWorkerThread根据不同的任务类型执行不同的等待</span></span><br><span class="line">        ((t = Thread.currentThread()) <span class="keyword">instanceof</span> ForkJoinWorkerThread) ?</span><br><span class="line">        (wt = (ForkJoinWorkerThread)t).pool.</span><br><span class="line">        awaitJoin(wt.workQueue, <span class="keyword">this</span>, <span class="number">0L</span>) :</span><br><span class="line">        externalAwaitDone();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="invokeAll"><a href="#invokeAll" class="headerlink" title="invokeAll"></a>invokeAll</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行两个任务</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeAll</span><span class="params">(ForkJoinTask&lt;?&gt; t1, ForkJoinTask&lt;?&gt; t2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s1, s2;</span><br><span class="line">    <span class="comment">//t2任务交给线程池进行调度</span></span><br><span class="line">    t2.fork();</span><br><span class="line">    <span class="comment">//t1通过当前的线程执行</span></span><br><span class="line">    <span class="keyword">if</span> ((s1 = t1.doInvoke() &amp; DONE_MASK) != NORMAL)</span><br><span class="line">        t1.reportException(s1);</span><br><span class="line">    <span class="comment">//等待t2任务执行完毕</span></span><br><span class="line">    <span class="keyword">if</span> ((s2 = t2.doJoin() &amp; DONE_MASK) != NORMAL)</span><br><span class="line">        t2.reportException(s2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行任务数组</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeAll</span><span class="params">(ForkJoinTask&lt;?&gt;... tasks)</span> </span>&#123;</span><br><span class="line">    Throwable ex = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> last = tasks.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = last; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        ForkJoinTask&lt;?&gt; t = tasks[i];</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//都不能为null</span></span><br><span class="line">            <span class="keyword">if</span> (ex == <span class="keyword">null</span>)</span><br><span class="line">                ex = <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (i != <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//除了第一个任务都交给线程池进行调度</span></span><br><span class="line">            t.fork();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//第一个任务由当先线程进行执行</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (t.doInvoke() &lt; NORMAL &amp;&amp; ex == <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">//记录第一个任务执行的异常</span></span><br><span class="line">            ex = t.getException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= last; ++i) &#123;</span><br><span class="line">        ForkJoinTask&lt;?&gt; t = tasks[i];</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//第一个任务异常结束、取消其他的任务</span></span><br><span class="line">            <span class="keyword">if</span> (ex != <span class="keyword">null</span>)</span><br><span class="line">                t.cancel(<span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (t.doJoin() &lt; NORMAL)</span><br><span class="line">                <span class="comment">//由任务异常结束、记录异常信息</span></span><br><span class="line">                ex = t.getException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ex != <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">//如果由任务异常结束、抛出数组最前面那么异常结束任务的异常</span></span><br><span class="line">        rethrow(ex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//批量执行任务</span></span><br><span class="line"><span class="comment">//返回每个任务对应的ForkJoinTask</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends ForkJoinTask&lt;?&gt;&gt; <span class="function">Collection&lt;T&gt; <span class="title">invokeAll</span><span class="params">(Collection&lt;T&gt; tasks)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(tasks <span class="keyword">instanceof</span> RandomAccess) || !(tasks <span class="keyword">instanceof</span> List&lt;?&gt;)) &#123;</span><br><span class="line">        <span class="comment">//将任务封装成ForkJoinTask</span></span><br><span class="line">        invokeAll(tasks.toArray(<span class="keyword">new</span> ForkJoinTask&lt;?&gt;[tasks.size()]));</span><br><span class="line">        <span class="keyword">return</span> tasks;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   </span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    List&lt;? extends ForkJoinTask&lt;?&gt;&gt; ts =</span><br><span class="line">        (List&lt;? extends ForkJoinTask&lt;?&gt;&gt;) tasks;</span><br><span class="line">    Throwable ex = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> last = ts.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = last; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        ForkJoinTask&lt;?&gt; t = ts.get(i);</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ex == <span class="keyword">null</span>)</span><br><span class="line">                ex = <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (i != <span class="number">0</span>)</span><br><span class="line">            t.fork();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (t.doInvoke() &lt; NORMAL &amp;&amp; ex == <span class="keyword">null</span>)</span><br><span class="line">            ex = t.getException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= last; ++i) &#123;</span><br><span class="line">        ForkJoinTask&lt;?&gt; t = ts.get(i);</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ex != <span class="keyword">null</span>)</span><br><span class="line">                t.cancel(<span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (t.doJoin() &lt; NORMAL)</span><br><span class="line">                ex = t.getException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ex != <span class="keyword">null</span>)</span><br><span class="line">        rethrow(ex);</span><br><span class="line">    <span class="keyword">return</span> tasks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;批量执行任务其实都是排在前面的任务由当前的线程去执行，其余的都交给了线程池去调度执行，如果有多个任务抛出了异常，只会抛出排在最前面的那个任务的异常。</p>
<h4 id="quietlyInvoke"><a href="#quietlyInvoke" class="headerlink" title="quietlyInvoke"></a>quietlyInvoke</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不需要执行结果的invoke</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">quietlyInvoke</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    doInvoke();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="quietlyJoin"><a href="#quietlyJoin" class="headerlink" title="quietlyJoin"></a>quietlyJoin</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不需要执行结果的join</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">quietlyJoin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    doJoin();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="cancel"><a href="#cancel" class="headerlink" title="cancel"></a>cancel</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//主要通过setCompletion标记尚未执行完毕的任务状态为CANCELLED</span></span><br><span class="line"><span class="comment">//尝试唤醒通过join等待此任务的线程</span></span><br><span class="line"><span class="comment">//已经执行完毕的任务无法取消</span></span><br><span class="line"><span class="comment">//mayInterruptIfRunning并没有使用，ForkJoinTask并不支持在取消任务时中断已经开始执行的任务</span></span><br><span class="line"><span class="comment">//当然该子类可以重写进行实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (setCompletion(CANCELLED) &amp; DONE_MASK) == CANCELLED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="tryUnfork"><a href="#tryUnfork" class="headerlink" title="tryUnfork"></a>tryUnfork</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//取消fork将任务从任务队列中移除</span></span><br><span class="line"><span class="comment">//如果此任务时当前线程最近才刚刚通过fork方法调度、并且尚未在另一个线程中去执行、通常情况下会成功</span></span><br><span class="line"><span class="comment">//不保证所有的都会成功</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryUnfork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t;</span><br><span class="line">    <span class="keyword">return</span> (((t = Thread.currentThread()) <span class="keyword">instanceof</span> ForkJoinWorkerThread) ?</span><br><span class="line">            <span class="comment">//针对ForkJoinWorkerThread的取消逻辑</span></span><br><span class="line">            ((ForkJoinWorkerThread)t).workQueue.tryUnpush(<span class="keyword">this</span>) :</span><br><span class="line">            <span class="comment">//针对非ForkJoinWorkerThread的取消逻辑</span></span><br><span class="line">            ForkJoinPool.common.tryExternalUnpush(<span class="keyword">this</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="reinitialize"><a href="#reinitialize" class="headerlink" title="reinitialize"></a>reinitialize</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//重新初始化该任务</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reinitialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((status &amp; DONE_MASK) == EXCEPTIONAL)</span><br><span class="line">        <span class="comment">//存在异常从哈希链表数组中移除当前任务的异常节点</span></span><br><span class="line">        clearExceptionalCompletion();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//重置status==0</span></span><br><span class="line">        status = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="helpQuiesce"><a href="#helpQuiesce" class="headerlink" title="helpQuiesce"></a>helpQuiesce</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果有一批任务被安排进行执行，但是不知道什么时候结束、希望在这些任务都执行完毕后再安排一个任务</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">helpQuiesce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t;</span><br><span class="line">    <span class="comment">//根据执行线程的类型执行不同的执行逻辑</span></span><br><span class="line">    <span class="keyword">if</span> ((t = Thread.currentThread()) <span class="keyword">instanceof</span> ForkJoinWorkerThread) &#123;</span><br><span class="line">        ForkJoinWorkerThread wt = (ForkJoinWorkerThread)t;</span><br><span class="line">        wt.pool.helpQuiescePool(wt.workQueue);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ForkJoinPool.quiesceCommonPool();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="getSurplusQueuedTaskCount"><a href="#getSurplusQueuedTaskCount" class="headerlink" title="getSurplusQueuedTaskCount"></a>getSurplusQueuedTaskCount</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取当前工作线程持有的任务数比其他可能窃取其任务的其他线程持有的任务数的一个估计值</span></span><br><span class="line"><span class="comment">//如果当前线程不是ForkJoinPool中则返回0</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getSurplusQueuedTaskCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ForkJoinPool.getSurplusQueuedTaskCount();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="子类实现"><a href="#子类实现" class="headerlink" title="子类实现"></a>子类实现</h3><h4 id="RecursiveTask-1"><a href="#RecursiveTask-1" class="headerlink" title="RecursiveTask"></a>RecursiveTask</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//带有返回结果的Task,定义了一个表示执行结果的result字段</span></span><br><span class="line"><span class="comment">//compute抽象方法用于当ForkJoinTask被调度执行exec方法时调用</span></span><br><span class="line"><span class="comment">//compute也是进行任务的拆分的逻辑</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">RecursiveTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">ForkJoinTask</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">5232453952276485270L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The result of the computation.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    V result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The main computation performed by this task.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the result of the computation</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> V <span class="title">compute</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getRawResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setRawResult</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line">        result = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Implements execution conventions for RecursiveTask.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">exec</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        result = compute();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="RecursiveAction-1"><a href="#RecursiveAction-1" class="headerlink" title="RecursiveAction"></a>RecursiveAction</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//没有返回值</span></span><br><span class="line"><span class="comment">//getRawResult永远为null</span></span><br><span class="line"><span class="comment">//setRawResult什么都不操作</span></span><br><span class="line"><span class="comment">//compute进行任务拆分</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">RecursiveAction</span> <span class="keyword">extends</span> <span class="title">ForkJoinTask</span>&lt;<span class="title">Void</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">5232453952276485070L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The main computation performed by this task.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">compute</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Always returns &#123;<span class="doctag">@code</span> null&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> null&#125; always</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Void <span class="title">getRawResult</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">null</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Requires null completion value.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setRawResult</span><span class="params">(Void mustBeNull)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Implements execution conventions for RecursiveActions.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">exec</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        compute();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="CountedCompleter"><a href="#CountedCompleter" class="headerlink" title="CountedCompleter"></a>CountedCompleter</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JDK8新增的CountedCompleter、操作完成后可以触发钩子函数、它是一个特殊的ForkJoinTask</span></span><br><span class="line"><span class="comment">//在触发完成动作时：检查有没有挂起的action、若没有则执行一个完成的动作</span></span><br><span class="line"><span class="comment">//可以支持返回结果或不返回结果、对方法进行重写</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CountedCompleter</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ForkJoinTask</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">5232453752276485070L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//一个链表结构、完成的触发顺序则是先进后出的模式(任务的完成者)</span></span><br><span class="line">    <span class="keyword">final</span> CountedCompleter&lt;?&gt; completer;</span><br><span class="line">    <span class="comment">//完成前挂起等待的任务数量</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> pending;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">CountedCompleter</span><span class="params">(CountedCompleter&lt;?&gt; completer,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">int</span> initialPendingCount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.completer = completer;</span><br><span class="line">        <span class="keyword">this</span>.pending = initialPendingCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">CountedCompleter</span><span class="params">(CountedCompleter&lt;?&gt; completer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.completer = completer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">CountedCompleter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.completer = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拆分逻辑</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">compute</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用了无条件complete或者调用tryComplet如果等待的任务数==0，触发该方法</span></span><br><span class="line">    <span class="comment">//默认不做任何操作</span></span><br><span class="line">    <span class="comment">//该实现主要取决于要实现的操作，比如并行流中的ops会处理一些结果集的reduce操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompletion</span><span class="params">(CountedCompleter&lt;?&gt; caller)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用completeexcepttion或者compute抛出异常时执行的操作、任务尚未执行完毕</span></span><br><span class="line">    <span class="comment">//默认返回true</span></span><br><span class="line">    <span class="comment">//异常完成的钩子函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onExceptionalCompletion</span><span class="params">(Throwable ex, CountedCompleter&lt;?&gt; caller)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//提供了扩展性、表示异常应该传递给this的completer</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回此任务的构造函数中建立的实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> CountedCompleter&lt;?&gt; getCompleter() &#123;</span><br><span class="line">        <span class="keyword">return</span> completer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回当前挂起等待的任务数量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getPendingCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pending;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置挂起等待的任务数量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setPendingCount</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">        pending = count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//原子性的将给定的值添加到挂起的计数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">addToPendingCount</span><span class="params">(<span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">        U.getAndAddInt(<span class="keyword">this</span>, PENDING, delta);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在当前持有的给定期望值、原子的挂起的计数设置为给定的计数expected修改到count</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetPendingCount</span><span class="params">(<span class="keyword">int</span> expected, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> U.compareAndSwapInt(<span class="keyword">this</span>, PENDING, expected, count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当前任务的挂起的任务数量原子减为0</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">decrementPendingCountUnlessZero</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> c;</span><br><span class="line">        <span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> ((c = pending) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     !U.compareAndSwapInt(<span class="keyword">this</span>, PENDING, c, c - <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> CountedCompleter&lt;?&gt; getRoot() &#123;</span><br><span class="line">        CountedCompleter&lt;?&gt; a = <span class="keyword">this</span>, p;</span><br><span class="line">        <span class="keyword">while</span> ((p = a.completer) != <span class="keyword">null</span>)</span><br><span class="line">            a = p;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果挂起的计数不为0，则减少计数，否则调用onCompletion</span></span><br><span class="line">    <span class="comment">//类似的尝试此任务的completer，存在则将此任务标记完成</span></span><br><span class="line">    <span class="comment">//尝试完成根任务或减少栈链下游的某一个completer的挂起数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">tryComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CountedCompleter&lt;?&gt; a = <span class="keyword">this</span>, s = a;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> c;;) &#123;</span><br><span class="line">            <span class="comment">//a(this或this的completer链中的某一个)的的挂起任务数为0,代表它挂起的任务都完成了.</span></span><br><span class="line">            <span class="keyword">if</span> ((c = a.pending) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//a的钩子函数:</span></span><br><span class="line">                <span class="comment">//对this于参数是否相等进行判断，如并行流聚合可以根据这个条件进行结果集的合并</span></span><br><span class="line">                a.onCompletion(s);</span><br><span class="line">                <span class="keyword">if</span> ((a = (s = a).completer) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//原来a的completer不存在，a不再是root了，那么就不需要传递</span></span><br><span class="line">                    <span class="comment">//调用quietlyComplete</span></span><br><span class="line">                    <span class="comment">//此时说明整条链上的completer的挂起任务全部都是0</span></span><br><span class="line">                    s.quietlyComplete();</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//对this的completer栈的某一次循环发现挂起任务数不为0</span></span><br><span class="line">            <span class="comment">//对该completer的挂起数-1</span></span><br><span class="line">            <span class="comment">//表示它挂起的任务完成了一个</span></span><br><span class="line">            <span class="comment">//如果产生了竞争状态，某个链上的任务抢先-1操作</span></span><br><span class="line">            <span class="comment">//那么进入下一次循环、进入到链上的下一个completer的传播逻辑</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(a, PENDING, c, c - <span class="number">1</span>))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//基本等效tryComplete</span></span><br><span class="line">    <span class="comment">//仅仅是不执行onCompletion</span></span><br><span class="line">    <span class="comment">//tryComplete会在判断链上的某个completer的挂起数是否为0</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">propagateCompletion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CountedCompleter&lt;?&gt; a = <span class="keyword">this</span>, s = a;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> c;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((c = a.pending) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((a = (s = a).completer) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    s.quietlyComplete();</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(a, PENDING, c, c - <span class="number">1</span>))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当获得多个子任务的任何一个结果</span></span><br><span class="line">    <span class="comment">//适合findAny场景</span></span><br><span class="line">    <span class="comment">//它丝毫不考虑挂起数、直接执行当前task的几个完成的方法</span></span><br><span class="line">    <span class="comment">//并且尝试对completer进行tryComplete</span></span><br><span class="line">    <span class="comment">//不改变自身的挂起任务数、但会让completer对栈上的其他completer或者自身尝试减少挂起数或者完成root</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">complete</span><span class="params">(T rawResult)</span> </span>&#123;</span><br><span class="line">        CountedCompleter&lt;?&gt; p;</span><br><span class="line">        <span class="comment">//使用参数设置当前任务的结果</span></span><br><span class="line">        setRawResult(rawResult);</span><br><span class="line">        <span class="comment">//直接调用钩子函数</span></span><br><span class="line">        onCompletion(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">//将status设置为NORMAL</span></span><br><span class="line">        quietlyComplete();</span><br><span class="line">        <span class="keyword">if</span> ((p = completer) != <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">//自己不改变自身的挂起数、也不尝试完成root</span></span><br><span class="line">           p.tryComplete();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果此任何的挂起计数为0，返回此任何，否则递减其挂起计数并返回</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> CountedCompleter&lt;?&gt; firstComplete() &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> c;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((c = pending) == <span class="number">0</span>)</span><br><span class="line">                <span class="comment">//当前task没有挂起的任务数则返回</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, PENDING, c, c - <span class="number">1</span>))</span><br><span class="line">                <span class="comment">//尝试坚守一个任务数并返回null</span></span><br><span class="line">                <span class="comment">//可能出现CAS失败</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//会针对当前任务判断是否又completer</span></span><br><span class="line">    <span class="comment">//有则对completer进行firstComplete</span></span><br><span class="line">    <span class="comment">//否则将当前任务安静的完成并且返回null</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> CountedCompleter&lt;?&gt; nextComplete() &#123;</span><br><span class="line">        CountedCompleter&lt;?&gt; p;</span><br><span class="line">        <span class="keyword">if</span> ((p = completer) != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> p.firstComplete();</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            quietlyComplete();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//等效于getRoot.quietlyCompleteRoot</span></span><br><span class="line">    <span class="comment">//遍历到root的completer执行quietlyComplete</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">quietlyCompleteRoot</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (CountedCompleter&lt;?&gt; a = <span class="keyword">this</span>, p;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((p = a.completer) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                a.quietlyComplete();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            a = p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果当前task尚未完成，尝试去运行指定数量的未运行的完成路径上的任务</span></span><br><span class="line">    <span class="comment">//当前任务处于他们的完成路径上、实现特殊的工作窃取</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">helpComplete</span><span class="params">(<span class="keyword">int</span> maxTasks)</span> </span>&#123;</span><br><span class="line">        Thread t; ForkJoinWorkerThread wt;</span><br><span class="line">        <span class="keyword">if</span> (maxTasks &gt; <span class="number">0</span> &amp;&amp; status &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//判断当前线程是否是ForkJoinWorkerThread</span></span><br><span class="line">            <span class="keyword">if</span> ((t = Thread.currentThread()) <span class="keyword">instanceof</span> ForkJoinWorkerThread)</span><br><span class="line">                (wt = (ForkJoinWorkerThread)t).pool.</span><br><span class="line">                	<span class="comment">//尝试执行当前任务并尝试从线程的工作队列中尝试帮助前置任务执行</span></span><br><span class="line">                    helpComplete(wt.workQueue, <span class="keyword">this</span>, maxTasks);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">//使用common池的externalHelpComplete方法</span></span><br><span class="line">                ForkJoinPool.common.externalHelpComplete(<span class="keyword">this</span>, maxTasks);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//支持FJT的异常传播</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">internalPropagateException</span><span class="params">(Throwable ex)</span> </span>&#123;</span><br><span class="line">        CountedCompleter&lt;?&gt; a = <span class="keyword">this</span>, s = a;</span><br><span class="line">        <span class="comment">//循环判断每一个task是否需要传递异常给completer</span></span><br><span class="line">        <span class="comment">//无代码体的while循环、神迹</span></span><br><span class="line">        <span class="keyword">while</span> (a.onExceptionalCompletion(ex, s) &amp;&amp;</span><br><span class="line">               <span class="comment">//需要传递给completer并且具备completer并且completer还不是完成态</span></span><br><span class="line">               (a = (s = a).completer) != <span class="keyword">null</span> &amp;&amp; a.status &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">               <span class="comment">//使用completer去记录异常的完成、记录成功进入下轮的循环</span></span><br><span class="line">               a.recordExceptionalCompletion(ex) == EXCEPTIONAL)</span><br><span class="line">            ;</span><br><span class="line">        </span><br><span class="line">   		<span class="comment">//因为onExceptionalCompletion固定返回true,若没有中间完成的任务</span></span><br><span class="line">        <span class="comment">//直到最后一个completer,也就是root,root不具备completer,将中断循环</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写的exec</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">exec</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//直接调用了compute方法并且返回false</span></span><br><span class="line">        <span class="comment">//在ForkJoinTask中的doExec方法调用了exce后得到true，将执行setCompletion操作</span></span><br><span class="line">        <span class="comment">//主要将在首次唤醒等待结果的线程</span></span><br><span class="line">        <span class="comment">//此处return false将不再执行上述的操作</span></span><br><span class="line">        compute();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getRawResult</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">null</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setRawResult</span><span class="params">(T t)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe U;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> PENDING;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            U = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">            PENDING = U.objectFieldOffset</span><br><span class="line">                (CountedCompleter.class.getDeclaredField("pending"));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;1.完成态/异常态之间的切换：<code>internalPropagateException</code>置空了实现，对于不同方式的实现、需要不同的传递行为。重写的<code>internalPropagateException</code>不断的判断当前任务是否要将异常信号传递给链上的下一个任务，让后让未完成的<code>completer</code>去记录同一个异常ex。</p>
<p>&emsp;&emsp;2.只要<code>completer</code>完成过，显然while循环中断，当前<code>completer</code>和后续的<code>completer</code>将不会被处理：</p>
<p>如果后续的<code>completer</code>已经出现过了异常，也会走一遍同样的逻辑，传递给后面的<code>completer</code>，如果它正常完成，也必然要有相应向后传递的行为。</p>
<p>&emsp;&emsp;3.如果传递异常的任务本身就是另一个或者几个任务的<code>completer</code>、它的异常信息显然不会进行反向传递：</p>
<p>&emsp;&emsp;&emsp;&emsp;(1)<code>tryComplete</code>方法会产生两个结果：<code>completer</code>链前方的某一个<code>completer</code>的挂起任务数-1，或者<code>completer</code>前方的某一个<code>completer(root)</code>的<code>quietlyComplete</code>被执行。</p>
<p>&emsp;&emsp;&emsp;&emsp;(2)<code>tryComplete</code>仅会对<code>root</code>执行<code>quietlyComplete</code>进而执行<code>setComplete</code>,而对于链上的其他任务，最多帮其挂起数-1，而不会将他们设置为完成状态。但是线程池在执行任务时，<code>invoke</code>,<code>doExce</code>,<code>get</code>操作都会将<code>setComplete</code>。</p>
<p>&emsp;&emsp;&emsp;&emsp;(3)每一个<code>CountedCompelet</code>都可能有自己的<code>completer</code>栈链，而每一个<code>CountedComplete</code>也可以位于其他的<code>CountedComplete</code>的栈链上且上游不唯一，下游唯一，任何一条栈链仅有一个<code>root</code>，且<code>root</code>的<code>completer</code>为null。</p>
<p>&emsp;&emsp;&emsp;&emsp;(4)<code>tryComplete</code>只能向前影响到链上的<code>completer</code>，所以随时可以将一些<code>completer</code>的数量设置为任意数，所以可能出现下一个<code>completer</code>的挂起数为0，但是下下一个<code>completer</code>只能安静的完成或者将其挂起数-1。</p>
<p>&emsp;&emsp;&emsp;&emsp;(5)<code>helpComplete</code>方法主要用于工作窃取，非<code>common</code>线程池窃取的时自己的任务。</p>
<p>&emsp;&emsp;我们可能会有各种各样的情景,<code>ForkJoin</code>框架无法阻止我们对<code>ForkJoinTask</code>的<code>exec</code>函数进行任意式的扩展,也无法阻止我们对<code>CountedCompleter</code>的<code>compute</code>任意扩展,那么如何在我们任意拓展的情景下保持效率和健壮?比如下面这个使用场景:</p>
<p>&emsp;&emsp;&emsp;a.建立一种<code>ForkJoinTask</code>,直接继承<code>CountedCompleter</code>并重写<code>compute</code>方法,则它可以运行在<code>ForkJoinPool</code>中.</p>
<p>&emsp;&emsp;&emsp;b.我们接下来在<code>compute</code>方法中多次根据计算结果集的大小进行拆分并递归fork子任务入池,父任务成为子任务的<code>completer</code>,同时<code>compute</code>方法自身也负责不可拆分的计算逻辑,并在自身这一块计算结束后,可能等待所有fork入池的子任务结束,也可能不等待子任务,直接结束父任务,让线程空出来做其他的事.</p>
<p>&emsp;&emsp;&emsp;c.所有子任务结束后,使用一个合并函数合并子任务的结果集和自身的结果,并作为最终的结果.然后<code>tryComplete</code>(如果b中使用了join,或者判断当前任务是root).</p>
<p>&emsp;&emsp;&emsp;显然,b中fork出的子任务,也同样要执行bc的逻辑.那么可能出现这样的情况:</p>
<p>不同的父任务子任务在<code>ForkJoinPool</code>最初始压入当前工作线程的队列中,但随时可能被其他工作线程甚至外部线程偷去执行.</p>
<p>&emsp;&emsp;&emsp;父任务抢先抢得运行资源,运行完自己计算的部分,而入池的子任务及子孙任务有大量未完成.</p>
<p>难道父任务的执行线程就这样干等?ForkJoin框架适宜多计算,轻io,轻阻塞的情况,且本身就是为了避免线程忙的忙死饿的饿死,因此每个任务等待子任务执行结束是不可取的,这或许也是为什么有了<code>ForkJoinTask</code>,却还要有<code>CountedCompleter</code>的原因之一吧.</p>
<p>&emsp;&emsp;&emsp;若我们在任何每一个任务中只是单纯地将该分出去的子任务fork入池并执行自己那一部分,并不让当前线程join子任务呢?(事实上不join子任务恰好可以将当前线程的资源腾出来做其他的事)</p>
<p>&emsp;&emsp;&emsp;所以,除了前面提到的若干种向前影响<code>completer</code>栈链的挂起数或root的完成态,还需要一个能向栈链后方有所影响的操作,比如帮助子任务的完成,毕竟子任务也是b中fork出来且由自己入队的.</p>
<p>&emsp;&emsp;&emsp;<code>helpComplete</code>方法就可以做到这一点,它在<code>ForkJoinPool</code>中,它仅应在当前任务未完成时使用,首先它会尝试将当前任务从出队列并执行(<code>ForkJoinPool::popCC</code>及成功后续doExec,LIFO),出队失败则表示正在被执行甚至被偷去执行.出队这一步之后,再尝试自己的线程工作队列中找出自己的子孙任务(FIFO)并进行执行(<code>ForkJoinPool::pollAndExecCC</code>).</p>
<p>&emsp;&emsp;&emsp;而若执行完某个父任务的工作线程必然会调用tryComplete等有关方法,将自身或栈链后方的某一个<code>completer</code>的挂起数减一,甚至因为一些不合理的api使用(如直接更改了后方某个任务的挂起数量)而直接终止了root,将root任务标记成完成态.(注意前面强调的”运行完自己计算的部分”,这就是否定本句话的关键了,前面也说明<code>helpComplete</code>仅在当前任务未完成时使用,显然,完成了自己负责的计算内容并不代表当前任务完成了,因为它的子任务还没有完成,因此它不会调用<code>tryComplete</code>,并且可以去帮助子任务)</p>
<p>&emsp;&emsp;&emsp;同时,执行完父任务负责的计算内容的任务线程也会去找它栈链后方的其他任务,按照b的逻辑,这将是它的子任务,帮助它们完成,每完成一个子任务(子任务无子任务,不再help的情况),会进行<code>tryComplete</code>传递一次.</p>
<h2 id="ForkJoinWorkerThread-1"><a href="#ForkJoinWorkerThread-1" class="headerlink" title="ForkJoinWorkerThread"></a>ForkJoinWorkerThread</h2><p>&emsp;&emsp;<code>ForkJoinTask</code>被声称是一个轻量于普通线程和Future的实体,而它在ForkJoinPool中的运行载体便是<code>ForkJoinWorkerThread</code>,这个轻量究竟体现在何处?</p>
<h3 id="类声明-1"><a href="#类声明-1" class="headerlink" title="类声明"></a>类声明</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinWorkerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span></span><br></pre></td></tr></table></figure>

<h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//每个ForkJoinWorkerThread都只能属于一个线程池,且保存该池的引用</span></span><br><span class="line"><span class="keyword">final</span> ForkJoinPool pool; </span><br><span class="line"><span class="comment">//每个ForkJoinWorkerThread都有一个工作队列</span></span><br><span class="line"><span class="comment">//显然队列中的任务就是该线程干活的最小单位了</span></span><br><span class="line"><span class="comment">//它也是工作窃取机制的核心</span></span><br><span class="line"><span class="keyword">final</span> ForkJoinPool.WorkQueue workQueue;</span><br></pre></td></tr></table></figure>

<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指定线程池</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">ForkJoinWorkerThread</span><span class="params">(ForkJoinPool pool)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 线程名称</span></span><br><span class="line">    <span class="keyword">super</span>(<span class="string">"aForkJoinWorkerThread"</span>);</span><br><span class="line">    <span class="keyword">this</span>.pool = pool;</span><br><span class="line">    <span class="comment">//将工作线程注册到ForkJoinPool后会返回一个工作队列</span></span><br><span class="line">    <span class="comment">//供当前线程使用和供其他线程偷取</span></span><br><span class="line">    <span class="keyword">this</span>.workQueue = pool.registerWorker(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指定线程组</span></span><br><span class="line">ForkJoinWorkerThread(ForkJoinPool pool, ThreadGroup threadGroup,</span><br><span class="line">                     AccessControlContext acc) &#123;</span><br><span class="line">    <span class="keyword">super</span>(threadGroup, <span class="keyword">null</span>, <span class="string">"aForkJoinWorkerThread"</span>);</span><br><span class="line">    <span class="comment">//inheritedAccessControlContext是从Thread继承下来的</span></span><br><span class="line">    <span class="comment">//字面意思是继承的访问控制上下文,设置为acc.</span></span><br><span class="line">    U.putOrderedObject(<span class="keyword">this</span>, INHERITEDACCESSCONTROLCONTEXT, acc);</span><br><span class="line">    <span class="comment">//注册入池之前,清除掉本地化信息</span></span><br><span class="line">    eraseThreadLocals(); </span><br><span class="line">    <span class="keyword">this</span>.pool = pool;</span><br><span class="line">    <span class="keyword">this</span>.workQueue = pool.registerWorker(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h4 id="getPool"><a href="#getPool" class="headerlink" title="getPool"></a>getPool</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回注册的线程池</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ForkJoinPool <span class="title">getPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pool;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="getPoolIndex"><a href="#getPoolIndex" class="headerlink" title="getPoolIndex"></a>getPoolIndex</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回当前线程工作队列在池中的索引</span></span><br><span class="line"><span class="comment">//每个队列都会维护一个在池中的索引.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPoolIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> workQueue.getPoolIndex();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="onStart"><a href="#onStart" class="headerlink" title="onStart"></a>onStart</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//空函数,可交给子类实现</span></span><br><span class="line"><span class="comment">//它的作用是在构造之后处理任务之前</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="onTermination"><a href="#onTermination" class="headerlink" title="onTermination"></a>onTermination</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//工作线程终止时的勾子方法</span></span><br><span class="line"><span class="comment">//负责执行一些有关的清理操作</span></span><br><span class="line"><span class="comment">//但是若要重写它,必须在方法的最后调用super.onTermination</span></span><br><span class="line"><span class="comment">//参数exception是造成该线程终止的异常</span></span><br><span class="line"><span class="comment">//若是正常结束,则它是null.</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onTermination</span><span class="params">(Throwable exception)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="run"><a href="#run" class="headerlink" title="run"></a>run</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//ForkJoinPool中会有一个WorkQueue的数组</span></span><br><span class="line">    <span class="comment">//在取消线程的注册后本线程关联的WorkQueue会从该数组移除</span></span><br><span class="line">    <span class="comment">//但WorkQueue中的array不会置空.</span></span><br><span class="line">    <span class="keyword">if</span> (workQueue.array == <span class="keyword">null</span>) &#123;</span><br><span class="line">        Throwable exception = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//前置操作函数</span></span><br><span class="line">            onStart();</span><br><span class="line">            <span class="comment">//用线程池的runWorker方法执行,传入队列</span></span><br><span class="line">            pool.runWorker(workQueue);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            <span class="comment">//发生异常,中断前记录下来</span></span><br><span class="line">            exception = ex;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//将记录下来的异常调用勾子方法.</span></span><br><span class="line">                onTermination(exception);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                <span class="keyword">if</span> (exception == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="comment">//执行勾子方法本身出现了异常,记录下来</span></span><br><span class="line">                    exception = ex;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//调用线程池的解除注册方法,会将本线程的WorkQueue从数组中移除,同时使用上述异常.</span></span><br><span class="line">                pool.deregisterWorker(<span class="keyword">this</span>, exception);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="eraseThreadLocals"><a href="#eraseThreadLocals" class="headerlink" title="eraseThreadLocals"></a>eraseThreadLocals</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//擦除本地变量</span></span><br><span class="line"><span class="comment">//把当前线程的两个ThreadLocalMap全部置空</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">eraseThreadLocals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    U.putObject(<span class="keyword">this</span>, THREADLOCALS, <span class="keyword">null</span>);</span><br><span class="line">    U.putObject(<span class="keyword">this</span>, INHERITABLETHREADLOCALS, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="afterTopLevelExec"><a href="#afterTopLevelExec" class="headerlink" title="afterTopLevelExec"></a>afterTopLevelExec</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//每正常运行完一次顶级task,就调用一次它</span></span><br><span class="line"><span class="comment">//这个顶级任务自带易误解天性</span></span><br><span class="line"><span class="comment">//其实可以理解为每一次从队列取出的任务</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterTopLevelExec</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="子类"><a href="#子类" class="headerlink" title="子类"></a>子类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不具备任何特殊权限</span></span><br><span class="line"><span class="comment">//也不是用户定义的任何线程组的成员,每次运行完一个顶级任务</span></span><br><span class="line"><span class="comment">//则擦除本地化变量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">InnocuousForkJoinWorkerThread</span> <span class="keyword">extends</span> <span class="title">ForkJoinWorkerThread</span> </span>&#123;</span><br><span class="line">   <span class="comment">//自已创建默认线程组.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadGroup innocuousThreadGroup =</span><br><span class="line">        createThreadGroup();</span><br><span class="line">    <span class="comment">//访问控制上下文支持权限.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AccessControlContext INNOCUOUS_ACC =</span><br><span class="line">        <span class="keyword">new</span> AccessControlContext(</span><br><span class="line">            <span class="keyword">new</span> ProtectionDomain[] &#123;</span><br><span class="line">                <span class="keyword">new</span> ProtectionDomain(<span class="keyword">null</span>, <span class="keyword">null</span>)</span><br><span class="line">            &#125;);</span><br><span class="line">    <span class="comment">//构造函数.</span></span><br><span class="line">    InnocuousForkJoinWorkerThread(ForkJoinPool pool) &#123;</span><br><span class="line">        <span class="keyword">super</span>(pool, innocuousThreadGroup, INNOCUOUS_ACC);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">afterTopLevelExec</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//在每一次从队列取出的"顶级"任务运行后即擦除本地化变量.</span></span><br><span class="line">        eraseThreadLocals();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> ClassLoader <span class="title">getContextClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果获取线程上下文类加载器,永远直接返回系统类加载器.</span></span><br><span class="line">        <span class="keyword">return</span> ClassLoader.getSystemClassLoader();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//尝试对未捕获异常处理器的设置,忽略.</span></span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUncaughtExceptionHandler</span><span class="params">(UncaughtExceptionHandler x)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//禁止直接设置线程的上下文类加载器.</span></span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContextClassLoader</span><span class="params">(ClassLoader cl)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(<span class="string">"setContextClassLoader"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建一个以顶级线程组为父的线程组.</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ThreadGroup <span class="title">createThreadGroup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sun.misc.Unsafe u = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">            Class&lt;?&gt; tk = Thread<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">            Class&lt;?&gt; gk = ThreadGroup<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">            <span class="keyword">long</span> tg = u.objectFieldOffset(tk.getDeclaredField(<span class="string">"group"</span>));</span><br><span class="line">            <span class="keyword">long</span> gp = u.objectFieldOffset(gk.getDeclaredField(<span class="string">"parent"</span>));</span><br><span class="line">            <span class="comment">//当前线程的所属组.</span></span><br><span class="line">            ThreadGroup group = (ThreadGroup)</span><br><span class="line">                u.getObject(Thread.currentThread(), tg);</span><br><span class="line">            <span class="comment">//循环条件,当前线程的所属组不是null</span></span><br><span class="line">            <span class="keyword">while</span> (group != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//不停地循环向上取parent</span></span><br><span class="line">                ThreadGroup parent = (ThreadGroup)u.getObject(group, gp);</span><br><span class="line">                <span class="keyword">if</span> (parent == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="comment">//发现无parent的线程组,说明是系统顶级线程组</span></span><br><span class="line">                    <span class="comment">//用它当parent创建一个"无害"线程组返回.</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> ThreadGroup(group,</span><br><span class="line">                                           <span class="string">"InnocuousForkJoinWorkerThreadGroup"</span>);</span><br><span class="line">                <span class="comment">//有parent,把它赋给group开启下一轮循环.</span></span><br><span class="line">                group = parent;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">//有异常用Error包装抛出.</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//不能return就抛出Error.</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Cannot create ThreadGroup"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;1.内部维护了一个工作队列，实现任务调度以及工作窃取。</p>
<p>&emsp;&emsp;2.每次顶级任务运行结束、清理<code>ThreadLocal</code>,避免同线程的本地化数据被污染。</p>
<h3 id="并行可窃取的分治查找算法"><a href="#并行可窃取的分治查找算法" class="headerlink" title="并行可窃取的分治查找算法"></a>并行可窃取的分治查找算法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinTest2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> ForkJoinTest2().testDivideSearch();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDivideSearch</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Integer[] array = <span class="keyword">new</span> Integer[<span class="number">10000000</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++)&#123;</span><br><span class="line">            array[i] = i+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        AtomicReference&lt;Integer&gt; result = <span class="keyword">new</span> AtomicReference&lt;&gt;();</span><br><span class="line">        Integer find = <span class="keyword">new</span> Searcher&lt;&gt;(<span class="keyword">null</span>, array, result, <span class="number">0</span>,</span><br><span class="line">                array.length - <span class="number">1</span>,<span class="keyword">this</span>::match).invoke();</span><br><span class="line">        System.out.println((<span class="string">"查找结束,任务返回:"</span> + find + <span class="string">",result:&#123;"</span> + result.get()) + <span class="string">"&#125;"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Searcher</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">CountedCompleter</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> E[] array; <span class="keyword">final</span> AtomicReference&lt;E&gt; result; <span class="keyword">final</span> <span class="keyword">int</span> lo, hi;</span><br><span class="line">        <span class="keyword">final</span> Function&lt;E,Boolean&gt; matcher;</span><br><span class="line"></span><br><span class="line">        Searcher(CountedCompleter&lt;?&gt; p, E[] array, AtomicReference&lt;E&gt; result,</span><br><span class="line">                 <span class="keyword">int</span> lo, <span class="keyword">int</span> hi,Function&lt;E,Boolean&gt; matcher)&#123;</span><br><span class="line">            <span class="keyword">super</span>(p);</span><br><span class="line">            <span class="keyword">this</span>.array = array;</span><br><span class="line">            <span class="keyword">this</span>.result = result;</span><br><span class="line">            <span class="keyword">this</span>.lo = lo;</span><br><span class="line">            <span class="keyword">this</span>.hi = hi;</span><br><span class="line">            <span class="keyword">this</span>.matcher = matcher;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> l = <span class="keyword">this</span>.lo;<span class="keyword">int</span> h = <span class="keyword">this</span>.hi;</span><br><span class="line">            <span class="keyword">while</span>(result.get() == <span class="keyword">null</span> &amp;&amp; h &gt;= l)&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(h - l &gt;=<span class="number">2</span>)&#123;</span><br><span class="line">                    <span class="keyword">int</span> mid = (l + h)&gt;&gt;&gt;<span class="number">1</span>;</span><br><span class="line">                    <span class="comment">//添加挂起任务数量,这样当出现tryComplete时可以触发root的结束(未查到)</span></span><br><span class="line">                    addToPendingCount(<span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">new</span> Searcher&lt;E&gt;(<span class="keyword">this</span>,array,result,mid,h,matcher).fork();</span><br><span class="line">                    h = mid;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    E x = array[l];</span><br><span class="line">                    <span class="keyword">if</span>(matcher.apply(x) &amp;&amp;  result.compareAndSet(<span class="keyword">null</span>,x))&#123;</span><br><span class="line">                        <span class="keyword">super</span>.quietlyCompleteRoot();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当前未有任何一个线程查到结果,当前任务也完成了子集查找,减少一个挂起数量,若挂起数已减至0则终止.</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">null</span> == result.get())</span><br><span class="line">                tryComplete();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(Integer x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &gt; <span class="number">2000000</span> &amp;&amp;  x%<span class="number">2</span> ==<span class="number">0</span> &amp;&amp; x%<span class="number">3</span> == <span class="number">0</span> &amp;&amp; x%<span class="number">5</span> ==<span class="number">0</span> &amp;&amp; x %<span class="number">7</span> ==<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;1.对任务分治，拆分成为足够多的子任务，剩下的不需要再进行拆分的父任务由当前的线程去执行。</p>
<p>&emsp;&emsp;2.子任务压入工作队列，其他空闲的线程则会进行工作窃取并且完成该任务。</p>
<p>&emsp;&emsp;3.此时若是某个任务的子任务查找到期望数据以后会将它放入<code>result</code>，并且安静的完成根任务。</p>
<p>&emsp;&emsp;4.此刻的任务链处于了一个尴尬的情形：查找到期望数据的子任务将<code>root</code>设置完成态，而整个非<code>root</code>链上的任务都是属于未完成。但是由于不满足条件无法退出循环，但是此刻已经得到了自己所期望的数据，那么任务的<code>status</code>依旧为未完成，是否存在了重复执行的问题？</p>
<p>&emsp;&emsp;5.由于<code>ForkJoinTask</code>肯定是由<code>ForkJoinPool</code>进行统一的调度，在<code>common</code>池中，任务执行前必须出队，尽管<code>compute</code>方法没有将这些任务设置为完成态，但是任务不会重复执行。所以<code>compute</code>方法会因为中止循环而结束，此后的方法都不存在任何的外部引用而会被GC回收，即使存在，用它去获取子孙任务的执行情况或者<code>result</code>也是没有任何实际的意义的。</p>
<h3 id="跨节点（Map-Reduce）"><a href="#跨节点（Map-Reduce）" class="headerlink" title="跨节点（Map,Reduce）"></a>跨节点（Map,Reduce）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinTest3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> ForkJoinTest3().testMapReduce();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMapReduce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Integer[] array = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        <span class="comment">//方法一.</span></span><br><span class="line">        Integer result = <span class="keyword">new</span> MapRed&lt;&gt;(<span class="keyword">null</span>, array, (a)-&gt;a+<span class="number">2</span>, (a,b)-&gt;a+b,  <span class="number">0</span>,array.length).invoke();</span><br><span class="line">        System.out.println(<span class="string">"方法一result:&#123;"</span> + result + <span class="string">"&#125;"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第一种map reduce方式,很好理解.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;E&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">MapRed</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">CountedCompleter</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> E[] array;</span><br><span class="line">        <span class="keyword">final</span> MyMapper&lt;E&gt; mapper;</span><br><span class="line">        <span class="keyword">final</span> MyReducer&lt;E&gt; reducer;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> lo, hi;</span><br><span class="line">        <span class="comment">//兄弟节点的引用</span></span><br><span class="line">        MapRed&lt;E&gt; sibling;</span><br><span class="line">        E result;</span><br><span class="line"></span><br><span class="line">        MapRed(CountedCompleter&lt;?&gt; p, E[] array, MyMapper&lt;E&gt; mapper,</span><br><span class="line">               MyReducer&lt;E&gt; reducer, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi) &#123;</span><br><span class="line">            <span class="keyword">super</span>(p);</span><br><span class="line">            <span class="keyword">this</span>.array = array;</span><br><span class="line">            <span class="keyword">this</span>.mapper = mapper;</span><br><span class="line">            <span class="keyword">this</span>.reducer = reducer;</span><br><span class="line">            <span class="keyword">this</span>.lo = lo;</span><br><span class="line">            <span class="keyword">this</span>.hi = hi;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (hi - lo &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> mid = (lo + hi) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">                MapRed&lt;E&gt; left = <span class="keyword">new</span> MapRed(<span class="keyword">this</span>, array, mapper, reducer, lo, mid);</span><br><span class="line">                MapRed&lt;E&gt; right = <span class="keyword">new</span> MapRed(<span class="keyword">this</span>, array, mapper, reducer, mid, hi);</span><br><span class="line">                left.sibling = right;</span><br><span class="line">                right.sibling = left;</span><br><span class="line">                <span class="comment">//只挂起右任务</span></span><br><span class="line">                setPendingCount(<span class="number">1</span>);</span><br><span class="line">                right.fork();</span><br><span class="line">                <span class="comment">//直接运算左任务.</span></span><br><span class="line">                left.compute();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (hi &gt; lo)</span><br><span class="line">                    result = mapper.apply(array[lo]);</span><br><span class="line">                <span class="comment">//它会依次调用onCompletion.并且是自己调自己或completer调子,</span></span><br><span class="line">                <span class="comment">//且只有左右两个子后完成的能调成功(父任务的挂起数达到0).</span></span><br><span class="line">                tryComplete();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompletion</span><span class="params">(CountedCompleter&lt;?&gt; caller)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//忽略自己调自己.</span></span><br><span class="line">            <span class="keyword">if</span> (caller != <span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="comment">//参数是子任务.</span></span><br><span class="line">                MapRed&lt;E&gt; child = (MapRed&lt;E&gt;) caller;</span><br><span class="line">                MapRed&lt;E&gt; sib = child.sibling;</span><br><span class="line">                <span class="comment">//设置父的result.</span></span><br><span class="line">                <span class="keyword">if</span> (sib == <span class="keyword">null</span> || sib.result == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    result = child.result;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    result = reducer.apply(child.result, sib.result);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> E <span class="title">getRawResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * mapper和reducer简单的不能再简单</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@FunctionalInterface</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyMapper</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function">E <span class="title">apply</span><span class="params">(E e)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@FunctionalInterface</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyReducer</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function">E <span class="title">apply</span><span class="params">(E a, E b)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;1.第一步也是将任务进行分治拆解，将任务拆分成为左边和右边。</p>
<p>&emsp;&emsp;2.左边直接由父任务执行，也可能会再次拆分，右边则加入线程池，每个叶子任务执行完毕后调用<code>tryComplete</code>。</p>
<p>&emsp;&emsp;3.会触发一系列的<code>complete</code>栈元素的挂起数下降或者完成。</p>
<h2 id="WorkQueue"><a href="#WorkQueue" class="headerlink" title="WorkQueue"></a>WorkQueue</h2><h3 id="类声明-2"><a href="#类声明-2" class="headerlink" title="类声明"></a>类声明</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@sun</span>.misc.Contended</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkQueue</span></span></span><br></pre></td></tr></table></figure>

<h3 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化线程池,owner</span></span><br><span class="line">WorkQueue(ForkJoinPool pool, ForkJoinWorkerThread owner) &#123;</span><br><span class="line">    <span class="keyword">this</span>.pool = pool;</span><br><span class="line">    <span class="keyword">this</span>.owner = owner;</span><br><span class="line">    <span class="comment">// Place indices in the center of array (that is not yet allocated)</span></span><br><span class="line">    base = top = INITIAL_QUEUE_CAPACITY &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="相关成员"><a href="#相关成员" class="headerlink" title="相关成员"></a>相关成员</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//队列内部数组的初始容量,默认是2的12次方,它必须是2的几次方,且不能小于4.</span></span><br><span class="line"><span class="comment">//但它应该设置一个较大的值来减少队列间的缓存行共享.</span></span><br><span class="line"><span class="comment">//在前面的java运行时和54篇java官方文档术语中曾提到,jvm通常会将</span></span><br><span class="line"><span class="comment">//数组放在能够共享gc标记(如卡片标记)的位置,这样每一次写都会造成严重内存竞态.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INITIAL_QUEUE_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">13</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最大内部数组容量,默认64M,也必须是2的平方,但不大于1&lt;&lt;(31-数组元素项宽度),</span></span><br><span class="line"><span class="comment">//根据官方注释,这可以确保无需计算索引概括,但定义一个略小于此的值有助于用户在</span></span><br><span class="line"><span class="comment">//系统饱合前捕获失控的程序.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_QUEUE_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">26</span>; <span class="comment">// 64M</span></span><br><span class="line"><span class="comment">// unsafe机制有关的字段.</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe U;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>  ABASE;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>  ASHIFT;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> QTOP;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> QLOCK;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> QCURRENTSTEAL;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例字段</span></span><br><span class="line"><span class="comment">// 版本号,小于0代表不活跃,注释解释奇数代表正在扫描,但从代码语义上看正好相反</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> scanState;    </span><br><span class="line"><span class="comment">// 前一个池栈控制信号(ctl),它保有前一个栈顶记录</span></span><br><span class="line"><span class="keyword">int</span> stackPred;      </span><br><span class="line"><span class="comment">// 偷盗的任务数</span></span><br><span class="line"><span class="keyword">int</span> nsteals;               </span><br><span class="line"><span class="comment">// 一个随机数,用于决定偷取任务的索引</span></span><br><span class="line"><span class="keyword">int</span> hint;        </span><br><span class="line"><span class="comment">// 配置,表示池的索引和模式</span></span><br><span class="line"><span class="keyword">int</span> config;       </span><br><span class="line"><span class="comment">// 队列锁,1表示锁了,小于0表示终止,其他情况是0.</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> qlock;     </span><br><span class="line"><span class="comment">// 底,表示下一个poll操作的插槽索引</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> base;         </span><br><span class="line"><span class="comment">// 顶,表示下一个push操作的插槽索引</span></span><br><span class="line"><span class="keyword">int</span> top;                   </span><br><span class="line"><span class="comment">// 存放任务元素的数组,初始不分配,首扩容会分配</span></span><br><span class="line">ForkJoinTask&lt;?&gt;[] array;   </span><br><span class="line"><span class="comment">// 包含该队列的池,可能在某些时刻是null</span></span><br><span class="line"><span class="keyword">final</span> ForkJoinPool pool;   </span><br><span class="line"><span class="comment">// 持有该队列的线程,如果队列是共享的,owner是null</span></span><br><span class="line"><span class="keyword">final</span> ForkJoinWorkerThread owner;</span><br><span class="line"><span class="comment">// 在调用park阻塞的owner,非阻塞时为null</span></span><br><span class="line"><span class="keyword">volatile</span> Thread parker;    </span><br><span class="line"><span class="comment">// 被在awaitJoin中join的task</span></span><br><span class="line"><span class="keyword">volatile</span> ForkJoinTask&lt;?&gt; currentJoin;  </span><br><span class="line"><span class="comment">// 字面意思当前偷的任务,主要用来helpStealer方法使用</span></span><br><span class="line"><span class="keyword">volatile</span> ForkJoinTask&lt;?&gt; currentSteal;</span><br></pre></td></tr></table></figure>

<h3 id="静态函数"><a href="#静态函数" class="headerlink" title="静态函数"></a>静态函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        U = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">        Class&lt;?&gt; wk = WorkQueue<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        Class&lt;?&gt; ak = ForkJoinTask[]<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        <span class="comment">//top字段的句柄.</span></span><br><span class="line">        QTOP = U.objectFieldOffset</span><br><span class="line">            (wk.getDeclaredField(<span class="string">"top"</span>));</span><br><span class="line">        <span class="comment">//qlock字段的句柄.</span></span><br><span class="line">        QLOCK = U.objectFieldOffset</span><br><span class="line">            (wk.getDeclaredField(<span class="string">"qlock"</span>));</span><br><span class="line">        <span class="comment">//currentSteal的句柄</span></span><br><span class="line">        QCURRENTSTEAL = U.objectFieldOffset</span><br><span class="line">            (wk.getDeclaredField(<span class="string">"currentSteal"</span>));</span><br><span class="line">        <span class="comment">//ABASE是ForkJoinTask数组的首地址.</span></span><br><span class="line">        ABASE = U.arrayBaseOffset(ak);</span><br><span class="line">        <span class="comment">//scale代表数组元素的索引大小.它必须是2的平方.</span></span><br><span class="line">        <span class="keyword">int</span> scale = U.arrayIndexScale(ak);</span><br><span class="line">        <span class="keyword">if</span> ((scale &amp; (scale - <span class="number">1</span>)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"data type scale not a power of two"</span>);</span><br><span class="line">        <span class="comment">//计算ASHIFT,它是31与scale的高位0位数量的差值.因为上一步约定了scale一定是一个正的2的几次方,</span></span><br><span class="line">        <span class="comment">//ASHIFT的结果一定会大于1.可以理解ASHIFT是数组索引大小的有效位数.</span></span><br><span class="line">        ASHIFT = <span class="number">31</span> - Integer.numberOfLeadingZeros(scale);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h3><h4 id="getPoolIndex-1"><a href="#getPoolIndex-1" class="headerlink" title="getPoolIndex"></a>getPoolIndex</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回本队列在池中的索引</span></span><br><span class="line"><span class="comment">//使用config的2至4位表示</span></span><br><span class="line"><span class="comment">//因为config的最后一位是奇偶位,忽略</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getPoolIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (config &amp; <span class="number">0xffff</span>) &gt;&gt;&gt; <span class="number">1</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="queueSize"><a href="#queueSize" class="headerlink" title="queueSize"></a>queueSize</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回队列中的任务数.</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">queueSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//非owner的调用者必须先读base,用base-top,得到的结果小于0则取相反数,否则取0.</span></span><br><span class="line">    <span class="comment">//忽略即时的负数,它并不严格准确.</span></span><br><span class="line">    <span class="keyword">int</span> n = base - top;       </span><br><span class="line">    <span class="keyword">return</span> (n &gt;= <span class="number">0</span>) ? <span class="number">0</span> : -n; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="isEmpty"><a href="#isEmpty" class="headerlink" title="isEmpty"></a>isEmpty</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断队列是否为空队.本方法较为精确</span></span><br><span class="line"><span class="comment">//对于近空队列,要检查是否有至少一个未被占有的任务</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ForkJoinTask&lt;?&gt;[] a; <span class="keyword">int</span> n, m, s;</span><br><span class="line">    <span class="comment">//base大于等于top,说明空了.</span></span><br><span class="line">    <span class="keyword">return</span> ((n = base - (s = top)) &gt;= <span class="number">0</span> ||</span><br><span class="line">            <span class="comment">//有容量,且恰好计算为1,可能只有一个任务.</span></span><br><span class="line">            (n == -<span class="number">1</span> &amp;&amp; </span><br><span class="line">             <span class="comment">//计算为1,再验数组是不是空的.          </span></span><br><span class="line">             ((a = array) == <span class="keyword">null</span> || (m = a.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">              <span class="comment">//取该位置元素的值判空,空则说明isEmpty.</span></span><br><span class="line">              <span class="comment">//取值的方式是取ForkJoinTask.class首地址加上偏移量(数组长度减一(最后一个元素位置,经典案例32-1)与运算top减一左移ASHIFT(索引大小有效位数)位)的值.</span></span><br><span class="line">              U.getObject</span><br><span class="line">              (a, (<span class="keyword">long</span>)((m &amp; (s - <span class="number">1</span>)) &lt;&lt; ASHIFT) + ABASE) == <span class="keyword">null</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="push"><a href="#push" class="headerlink" title="push"></a>push</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将一个任务压入队列,前文提过的fork最终就会压队</span></span><br><span class="line"><span class="comment">//但此方法只能由非共享队列的持有者调用</span></span><br><span class="line"><span class="comment">//当使用线程池的"外部压入"externalPush方法时,压入共享队列.</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(ForkJoinTask&lt;?&gt; task)</span> </span>&#123;</span><br><span class="line">    ForkJoinTask&lt;?&gt;[] a; ForkJoinPool p;</span><br><span class="line">    <span class="comment">//保存当时的base top.</span></span><br><span class="line">    <span class="keyword">int</span> b = base, s = top, n;</span><br><span class="line">    <span class="comment">//如果数组被移除则忽略.</span></span><br><span class="line">    <span class="keyword">if</span> ((a = array) != <span class="keyword">null</span>) &#123; </span><br><span class="line">        <span class="comment">//数组最后一个下标</span></span><br><span class="line">        <span class="comment">//如长度32,则m取31这个质数.此时保存一个m,对于保存后其他push操作相当于打了屏障.</span></span><br><span class="line">        <span class="keyword">int</span> m = a.length - <span class="number">1</span>; </span><br><span class="line">        <span class="comment">//向数组中的指定位置压入该任务</span></span><br><span class="line">        <span class="comment">//位置包含上面的m和s进行与运算(数组中的位置)</span></span><br><span class="line">        <span class="comment">//结果左移索引有效长度位(索引长度),再加上数组首索引偏移量(起始地址).  </span></span><br><span class="line">        U.putOrderedObject(a, ((m &amp; s) &lt;&lt; ASHIFT) + ABASE, task);</span><br><span class="line">        <span class="comment">//将top加1.</span></span><br><span class="line">        U.putOrderedInt(<span class="keyword">this</span>, QTOP, s + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> ((n = s - b) &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//计算旧的任务数量,发现不大于1个</span></span><br><span class="line">            <span class="comment">//说明原来很可能工作线程正在阻塞等待新的任务.需要唤醒它.</span></span><br><span class="line">            <span class="keyword">if</span> ((p = pool) != <span class="keyword">null</span>)</span><br><span class="line">                <span class="comment">//signalWork会根据情况,添加新的工作线程或唤醒等待任务的线程.</span></span><br><span class="line">                p.signalWork(p.workQueues, <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (n &gt;= m)<span class="comment">//2.</span></span><br><span class="line">            <span class="comment">//任务数量超出了,对数组扩容.</span></span><br><span class="line">            growArray();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="growArray"><a href="#growArray" class="headerlink" title="growArray"></a>growArray</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加任务过程主流程无锁,包括可能出现的growArray</span></span><br><span class="line"><span class="comment">//当原队列为空时,它会初始化一个数组,否则扩容一倍</span></span><br><span class="line"><span class="comment">//持有者调用时,不需要加锁</span></span><br><span class="line"><span class="comment">//但当其他线程调用时,需要持有锁.在resize过程中,base可以移动,但top不然</span></span><br><span class="line"><span class="keyword">final</span> ForkJoinTask&lt;?&gt;[] growArray() &#123;</span><br><span class="line">    <span class="comment">//记录老数组.</span></span><br><span class="line">    ForkJoinTask&lt;?&gt;[] oldA = array;</span><br><span class="line">    <span class="comment">//根据老数组决定新容量,老数组空则INITIAL_QUEUE_CAPACITY否则国倍.</span></span><br><span class="line">    <span class="keyword">int</span> size = oldA != <span class="keyword">null</span> ? oldA.length &lt;&lt; <span class="number">1</span> : INITIAL_QUEUE_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (size &gt; MAXIMUM_QUEUE_CAPACITY)</span><br><span class="line">        <span class="comment">//新大小大于最大数组大小则拒绝.</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(<span class="string">"Queue capacity exceeded"</span>);</span><br><span class="line">    <span class="keyword">int</span> oldMask, t, b;</span><br><span class="line">    <span class="comment">//直接将原来的数组引用替换成新的.</span></span><br><span class="line">    ForkJoinTask&lt;?&gt;[] a = array = <span class="keyword">new</span> ForkJoinTask&lt;?&gt;[size];</span><br><span class="line">    <span class="comment">//如果是初次分配,就此打住返回a,是扩容,且老数组非空则进入下面的循环拷贝.</span></span><br><span class="line">    <span class="keyword">if</span> (oldA != <span class="keyword">null</span> &amp;&amp; (oldMask = oldA.length - <span class="number">1</span>) &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (t = top) - (b = base) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//根据前面的运算,size一定是2的幂,减一用来哈希,这是经典处理办法.</span></span><br><span class="line">        <span class="keyword">int</span> mask = size - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123; </span><br><span class="line">            ForkJoinTask&lt;?&gt; x;</span><br><span class="line">            <span class="comment">//老数组base自增过若干次的得到b,它代表的元素对应的索引.</span></span><br><span class="line">            <span class="keyword">int</span> oldj = ((b &amp; oldMask) &lt;&lt; ASHIFT) + ABASE;</span><br><span class="line">            <span class="comment">//用b在新数组中找出索引.</span></span><br><span class="line">            <span class="keyword">int</span> j    = ((b &amp;    mask) &lt;&lt; ASHIFT) + ABASE;</span><br><span class="line">            <span class="comment">//老数组中用索引取出元素.</span></span><br><span class="line">            x = (ForkJoinTask&lt;?&gt;)U.getObjectVolatile(oldA, oldj);</span><br><span class="line">            <span class="keyword">if</span> (x != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                <span class="comment">//老数组置空,放入新数组.</span></span><br><span class="line">                U.compareAndSwapObject(oldA, oldj, x, <span class="keyword">null</span>))</span><br><span class="line">                U.putObjectVolatile(a, j, x);</span><br><span class="line">            <span class="comment">//每处理完一个task,就将base自增1,直到top为止.</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (++b != t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回新数组.</span></span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="pop"><a href="#pop" class="headerlink" title="pop"></a>pop</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//存在下一个任务,弹出,顺序是后进先出.此方法仅限非共享队列的owner调用</span></span><br><span class="line"><span class="keyword">final</span> ForkJoinTask&lt;?&gt; pop() &#123;</span><br><span class="line">    ForkJoinTask&lt;?&gt;[] a; ForkJoinTask&lt;?&gt; t; <span class="keyword">int</span> m;</span><br><span class="line">    <span class="comment">//还有元素.</span></span><br><span class="line">    <span class="keyword">if</span> ((a = array) != <span class="keyword">null</span> &amp;&amp; (m = a.length - <span class="number">1</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//1.top至少比base大一.注意,每次循环都会读出新的top,它是volatile修饰的</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> s; (s = top - <span class="number">1</span>) - base &gt;= <span class="number">0</span>;) &#123;</span><br><span class="line">            <span class="comment">//top对应的索引.</span></span><br><span class="line">            <span class="keyword">long</span> j = ((m &amp; s) &lt;&lt; ASHIFT) + ABASE;</span><br><span class="line">            <span class="comment">//2.该索引没有元素,break,返回null.而且就代表这个位置的确是null,与竞态无关</span></span><br><span class="line">            <span class="comment">//因为此方法仅owner线程使用,不会出现另一个线程计算了同样的j,且先执行了3的情况</span></span><br><span class="line">            <span class="comment">//出现这种情况,则是此位置的任务当先被执行并出栈,或者就从未设置过任务,后续分析这种极端情况</span></span><br><span class="line">            <span class="comment">//故如果出现某个任务在数组的中间</span></span><br><span class="line">            <span class="comment">//提前被执行并置空(非pop或poll方式),那么再对WorkQueue进行pop时将会中断</span></span><br><span class="line">            <span class="comment">//留下一部分null之后的任务不能出栈,所以可以允许任务非pop或poll方式查出并执行</span></span><br><span class="line">            <span class="comment">//但为了能pop出所有任务,不能中间置null.</span></span><br><span class="line">            <span class="keyword">if</span> ((t = (ForkJoinTask&lt;?&gt;)U.getObject(a, j)) == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//3.有元素,将该索引位置置null.若cas失败,说明元素被取出了</span></span><br><span class="line">            <span class="comment">//但下次循环即使在2处break并返回null,也不是因为竞态,因为每次循环到1都会读取新的top</span></span><br><span class="line">            <span class="comment">//也就有新的j</span></span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapObject(a, j, t, <span class="keyword">null</span>)) &#123;</span><br><span class="line">                <span class="comment">//数组位置置null的同时top减1.</span></span><br><span class="line">                U.putOrderedInt(<span class="keyword">this</span>, QTOP, s);</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//循环退出,说明top位置没有元素,也相当于说明数组为空</span></span><br><span class="line">    <span class="comment">//显然此方法的另一个作用是将队列压缩,空队列会将top先降到base+1</span></span><br><span class="line">    <span class="comment">//再循环最后一次将top降到base.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="pollAt"><a href="#pollAt" class="headerlink" title="pollAt"></a>pollAt</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果b是base,使用FIFO的次序尝试无竞态取底部的任务</span></span><br><span class="line"><span class="comment">//它会在ForkJoinPool的scan和helpStealer中使用.</span></span><br><span class="line"><span class="keyword">final</span> ForkJoinTask&lt;?&gt; pollAt(<span class="keyword">int</span> b) &#123;</span><br><span class="line">    ForkJoinTask&lt;?&gt; t; ForkJoinTask&lt;?&gt;[] a;</span><br><span class="line">    <span class="keyword">if</span> ((a = array) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//和前面一样的的方式计算b对应的索引j</span></span><br><span class="line">        <span class="keyword">int</span> j = (((a.length - <span class="number">1</span>) &amp; b) &lt;&lt; ASHIFT) + ABASE;</span><br><span class="line">        <span class="keyword">if</span> ((t = (ForkJoinTask&lt;?&gt;)U.getObjectVolatile(a, j)) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">            <span class="comment">//j对应位置有task且当前base==b,尝试将task出队.</span></span><br><span class="line">            base == b &amp;&amp; U.compareAndSwapObject(a, j, t, <span class="keyword">null</span>)) &#123;</span><br><span class="line">            <span class="comment">//出队成功base增1.不需要额外的同步,因为两个线程不可能同时在上面的cas成功.</span></span><br><span class="line">            <span class="comment">//当一切条件匹配(b就是base且j位置有元素),pollAt同一个b只会有一个返回非空的t.</span></span><br><span class="line">            <span class="comment">//如果多个线程传入的b不相等,在同一时刻只有一个会等于base.</span></span><br><span class="line">            base = b + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用FIFO的次序取下一个任务</span></span><br><span class="line"><span class="keyword">final</span> ForkJoinTask&lt;?&gt; poll() &#123;</span><br><span class="line">    ForkJoinTask&lt;?&gt;[] a; <span class="keyword">int</span> b; ForkJoinTask&lt;?&gt; t;</span><br><span class="line">    <span class="comment">//1.循环从base取任务,当base增长到top或其他操作重置array为null则终止循环</span></span><br><span class="line">    <span class="keyword">while</span> ((b = base) - top &lt; <span class="number">0</span> &amp;&amp; (a = array) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//前面已叙述过取索引的逻辑</span></span><br><span class="line">        <span class="comment">//使用一个top到base间的数与数组长度-1与运算并左移索引长度位再加上数组基准偏移量.后面不再缀述</span></span><br><span class="line">        <span class="keyword">int</span> j = (((a.length - <span class="number">1</span>) &amp; b) &lt;&lt; ASHIFT) + ABASE;</span><br><span class="line">        <span class="comment">//取出task</span></span><br><span class="line">        t = (ForkJoinTask&lt;?&gt;)U.getObjectVolatile(a, j);</span><br><span class="line">        <span class="comment">//2.如果发生竞态,base已经不是b,直接开启下一轮循环把新的base读给b</span></span><br><span class="line">        <span class="keyword">if</span> (base == b) &#123;</span><br><span class="line">            <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//3.当前t是base任务,用cas置空,base+1,返回t.</span></span><br><span class="line">                <span class="comment">//如果此处发生竞态,则只有一个线程可以成功返回t并重置base(4).</span></span><br><span class="line">                <span class="comment">//不成功的线程会开启下一轮循环,此时成功线程可能未来的及执行4更新base,</span></span><br><span class="line">                <span class="comment">//也可能已经更新base,则导致先前失败的线程在2处通过</span></span><br><span class="line">                <span class="comment">//经5种或判队列空返回,或非空再次循环</span></span><br><span class="line">                <span class="comment">//而在当前成功线程执行4成功后,所有前面失败的线程可以在1处读到新的base</span></span><br><span class="line">                <span class="comment">//这些线程在下一次循环中依旧只会有一个成功弹出t并重置base,直到所有线程执行完毕</span></span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapObject(a, j, t, <span class="keyword">null</span>)) &#123;</span><br><span class="line">                    <span class="comment">//4重置加返回</span></span><br><span class="line">                    base = b + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">return</span> t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//5.t取出的是空,发现此时临时变量b(其他成功线程在此轮循环前置的base)已增至top-1</span></span><br><span class="line">            <span class="comment">//且当前线程又没能成功的弹出t,说明一定会有一个线程</span></span><br><span class="line">            <span class="comment">//将t弹出并更新base到top的值,当前线程没必要再开下一个循环了,直接break并返回null</span></span><br><span class="line">            <span class="comment">//t取出的是空,但是没到top,说明只是被提前执行并置空了,那么继续读取新的base并循环</span></span><br><span class="line">            <span class="comment">//且若没有其他线程去更改base,array的长度,或者把top降到</span></span><br><span class="line">            <span class="comment">//base,则当前线程就永远死循环下去了,因为每次循环都是125且每个变量都不变.因此为避免循环,</span></span><br><span class="line">            <span class="comment">//个任务可以提前执行,但一定不能提前离队(置null).</span></span><br><span class="line">            <span class="comment">//也就是说:只能用poll或pop方式弹出任务,其他方式获得任务并执行是允许的</span></span><br><span class="line">            <span class="comment">//但不能在执行后置null,留待后续源码验证一下</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (b + <span class="number">1</span> == top) <span class="comment">// now empty</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从循环退出来有两种情况,可能是在5处满足退出条件,或者在2处发现b已经是脏数据</span></span><br><span class="line">    <span class="comment">//下轮循环不满足循环条件所致.两种都应该返回null.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="nextLocalTask"><a href="#nextLocalTask" class="headerlink" title="nextLocalTask"></a>nextLocalTask</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据mode来取下一个本队列元素.根据模式.</span></span><br><span class="line"><span class="keyword">final</span> ForkJoinTask&lt;?&gt; nextLocalTask() &#123;</span><br><span class="line">    <span class="comment">//当前WorkQueue的配置了FIFO,则poll,否则pop</span></span><br><span class="line">    <span class="comment">//尽管还未看到注册worker的源码,在此提前透露下</span></span><br><span class="line">    <span class="comment">//ForkJoinPool也有一个config(前面讲构造函数提过)</span></span><br><span class="line">    <span class="comment">//该config保存了mode信息,并原样赋给了WorkQueue的mode.注意,相应的任务会出队</span></span><br><span class="line">    <span class="keyword">return</span> (config &amp; FIFO_QUEUE) == <span class="number">0</span> ? pop() : poll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="peek"><a href="#peek" class="headerlink" title="peek"></a>peek</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据模式取出下一个任务,但是不出队</span></span><br><span class="line"><span class="keyword">final</span> ForkJoinTask&lt;?&gt; peek() &#123;</span><br><span class="line">    ForkJoinTask&lt;?&gt;[] a = array; <span class="keyword">int</span> m;</span><br><span class="line">    <span class="comment">//空队,返回null.</span></span><br><span class="line">    <span class="keyword">if</span> (a == <span class="keyword">null</span> || (m = a.length - <span class="number">1</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//根据mode定位要取的索引j</span></span><br><span class="line">    <span class="keyword">int</span> i = (config &amp; FIFO_QUEUE) == <span class="number">0</span> ? top - <span class="number">1</span> : base;</span><br><span class="line">    <span class="keyword">int</span> j = ((i &amp; m) &lt;&lt; ASHIFT) + ABASE;</span><br><span class="line">    <span class="comment">//返回读出的值,不出队</span></span><br><span class="line">    <span class="keyword">return</span> (ForkJoinTask&lt;?&gt;)U.getObjectVolatile(a, j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="tryUnpush"><a href="#tryUnpush" class="headerlink" title="tryUnpush"></a>tryUnpush</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果参数t是当前队的top,则弹出</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryUnpush</span><span class="params">(ForkJoinTask&lt;?&gt; t)</span> </span>&#123;</span><br><span class="line">    ForkJoinTask&lt;?&gt;[] a; <span class="keyword">int</span> s;</span><br><span class="line">    <span class="keyword">if</span> ((a = array) != <span class="keyword">null</span> &amp;&amp; (s = top) != base &amp;&amp;</span><br><span class="line">        <span class="comment">//1.满足非空条件.尝试用t去当当作计算出的索引位置的原任务的值并cas为null来出队</span></span><br><span class="line">        U.compareAndSwapObject</span><br><span class="line">        (a, (((a.length - <span class="number">1</span>) &amp; --s) &lt;&lt; ASHIFT) + ABASE, t, <span class="keyword">null</span>)) &#123;</span><br><span class="line">        <span class="comment">//cas成功,说明t确实是top,将top减一返回true</span></span><br><span class="line">        U.putOrderedInt(<span class="keyword">this</span>, QTOP, s);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.cas失败或不满足1的条件,返回false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="cancelAll"><a href="#cancelAll" class="headerlink" title="cancelAll"></a>cancelAll</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//移除并取消队列中所有已知的任务,忽略异常</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">cancelAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ForkJoinTask&lt;?&gt; t;</span><br><span class="line">    <span class="keyword">if</span> ((t = currentJoin) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//有currentJoin,引用置空,取消并忽略异常</span></span><br><span class="line">        currentJoin = <span class="keyword">null</span>;</span><br><span class="line">        ForkJoinTask.cancelIgnoringExceptions(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((t = currentSteal) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//有currentSteal,引用置空,取消并忽略异常</span></span><br><span class="line">        currentSteal = <span class="keyword">null</span>;</span><br><span class="line">        ForkJoinTask.cancelIgnoringExceptions(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//除了上面两个,就只剩下数组中的任务了.按LILO的顺序弹出并依次取消,忽略所有异常</span></span><br><span class="line">    <span class="keyword">while</span> ((t = poll()) != <span class="keyword">null</span>)</span><br><span class="line">        ForkJoinTask.cancelIgnoringExceptions(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="pollAndExecAll"><a href="#pollAndExecAll" class="headerlink" title="pollAndExecAll"></a>pollAndExecAll</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按FIFO顺序从队首弹出任务并执行所有非空任务</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">pollAndExecAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (ForkJoinTask&lt;?&gt; t; (t = poll()) != <span class="keyword">null</span>;)</span><br><span class="line">        <span class="comment">//很明显,如果未按严格顺序执行,先执行中间的一个任务</span></span><br><span class="line">        <span class="comment">//再调用本方法,则会半路中止</span></span><br><span class="line">        t.doExec();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="execLocalTasks"><a href="#execLocalTasks" class="headerlink" title="execLocalTasks"></a>execLocalTasks</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//移除并执行完所有本队列的任务,如果是先进先出,则执行前面的pollAndExecAll方法</span></span><br><span class="line"><span class="comment">//否则pop循环执行到空为止.按前面的分析,只要坚持只能pop或poll弹出,其他方式执行任务但不能置空的原则</span></span><br><span class="line"><span class="comment">//可以保证pop或poll出现空的情况只能是竞态发生的情况</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">execLocalTasks</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> b = base, m, s;</span><br><span class="line">    ForkJoinTask&lt;?&gt;[] a = array;</span><br><span class="line">    <span class="comment">//初始满足条件,top至少比base大1.队列非空</span></span><br><span class="line">    <span class="keyword">if</span> (b - (s = top - <span class="number">1</span>) &lt;= <span class="number">0</span> &amp;&amp; a != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">        (m = a.length - <span class="number">1</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//不是FIFO模式.</span></span><br><span class="line">        <span class="keyword">if</span> ((config &amp; FIFO_QUEUE) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (ForkJoinTask&lt;?&gt; t;;) &#123;</span><br><span class="line">                <span class="comment">//原子getAndSet,查出并弹出原本的task</span></span><br><span class="line">                <span class="keyword">if</span> ((t = (ForkJoinTask&lt;?&gt;)U.getAndSetObject</span><br><span class="line">                     (a, ((m &amp; s) &lt;&lt; ASHIFT) + ABASE, <span class="keyword">null</span>)) == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="comment">//弹出的task是空,break.说明整个工作流程中,如果未保证严格有序</span></span><br><span class="line">                    <span class="comment">//如先从中间的某个任务开始执行并且出队了,再调用execLocalTasks,会导致中间停顿</span></span><br><span class="line">                    <span class="comment">//只执行不出队,则至少不会中断.出现t是null的情况只能是竞态或末尾</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">//top减一,执行任务</span></span><br><span class="line">                U.putOrderedInt(<span class="keyword">this</span>, QTOP, s);</span><br><span class="line">                t.doExec();</span><br><span class="line">                <span class="comment">//如果base大于等于top,则中止</span></span><br><span class="line">                <span class="keyword">if</span> (base - (s = top - <span class="number">1</span>) &gt; <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//是FIFO模式,pollAndExecAll.</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pollAndExecAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="runTask"><a href="#runTask" class="headerlink" title="runTask"></a>runTask</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//重点入口方法来了,前面留下诸多关于执行任务是否出队的讨论,下面来分析入口方法</span></span><br><span class="line"><span class="comment">//该方法的入口是每个工作线程的run方法,因此只有一个线程</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runTask</span><span class="params">(ForkJoinTask&lt;?&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//传入task是空直接不理会.</span></span><br><span class="line">    <span class="keyword">if</span> (task != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//标记成忙.scanState是WorkQueue的成员变量,每个WorkQueue只有一个值</span></span><br><span class="line">        <span class="comment">//前面说过,一般情况下,每个线程会有一个WorkQueue,所以某种情况来讲也可以标记为</span></span><br><span class="line">        <span class="comment">//当前ForkJoinWorkerThread繁忙.</span></span><br><span class="line">        <span class="comment">//SCANNING常量值是1,这个操作实质上就是将scanState变量的个位置0</span></span><br><span class="line">        <span class="comment">//也就是变成了偶数并标记它要忙了</span></span><br><span class="line">        <span class="comment">//显然偶数才表示忙碌,这也是为什么前面觉得官方注释scanState是奇数表示"正在扫描"很奇怪.</span></span><br><span class="line">        scanState &amp;= ~SCANNING; </span><br><span class="line">        <span class="comment">//将currentSteal设置为传入的任务,并运行该任务,若该任务内部进行了分叉,则进入相应的入队逻辑</span></span><br><span class="line">        (currentSteal = task).doExec();</span><br><span class="line">        <span class="comment">//执行完该任务后,将currentSteal置空.将该task释放掉,帮助gc</span></span><br><span class="line">        U.putOrderedObject(<span class="keyword">this</span>, QCURRENTSTEAL, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//调用前面提到的,根据mode选择依次pop或poll的方式将自己的工作队列内的任务出队并执行的方法</span></span><br><span class="line">        execLocalTasks();</span><br><span class="line">        <span class="comment">//到此,自己队列中的所有任务都已经完成.包含偷来的任务fork后又入队到自己队列的子任务</span></span><br><span class="line">        <span class="comment">//取出owner线程.处理偷取任务有关的一些信息</span></span><br><span class="line">        ForkJoinWorkerThread thread = owner;</span><br><span class="line">        <span class="keyword">if</span> (++nsteals &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//发现当前WorkQueue偷来的任务数即将溢出了,将它转到线程池    </span></span><br><span class="line">            transferStealCount(pool);</span><br><span class="line">        <span class="comment">//取消忙碌标记.</span></span><br><span class="line">        scanState |= SCANNING;</span><br><span class="line">        <span class="keyword">if</span> (thread != <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">//执行afterTopLevelExec勾子方法,上一节中介绍ForkJoinWorkerThread时已介绍</span></span><br><span class="line">            thread.afterTopLevelExec();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//方法结束,注意,没有任何操作将task从所在的数组中移除,不论这个task是哪个WorkQueue中的元素</span></span><br><span class="line">    <span class="comment">//同时,此方法原则上讲可以多次调用(尽管事实上就一次调用)</span></span><br><span class="line">    <span class="comment">//入口处和出口处分别用忙碌标记来标记scanState,但重复标记显然不影响执行.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="transferStealCount"><a href="#transferStealCount" class="headerlink" title="transferStealCount"></a>transferStealCount</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果线程池中已经初始化了用于记录的stealCounter</span></span><br><span class="line"><span class="comment">//则用它加上当前WorkQueue的nsteals/或最大整数(发生溢出时)</span></span><br><span class="line"><span class="comment">//并初始化当前WorkQueue的nsteals</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">transferStealCount</span><span class="params">(ForkJoinPool p)</span> </span>&#123;</span><br><span class="line">    AtomicLong sc;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="keyword">null</span> &amp;&amp; (sc = p.stealCounter) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//线程池中存放了stealCounter,它是一个原子整数</span></span><br><span class="line">        <span class="keyword">int</span> s = nsteals;</span><br><span class="line">        nsteals = <span class="number">0</span>; <span class="comment">//恢复0</span></span><br><span class="line">        <span class="comment">//若nsteals是负,增加最大整数,否则增加nsteal         </span></span><br><span class="line">        sc.getAndAdd((<span class="keyword">long</span>)(s &lt; <span class="number">0</span> ? Integer.MAX_VALUE : s));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="tryRemoveAndExec"><a href="#tryRemoveAndExec" class="headerlink" title="tryRemoveAndExec"></a>tryRemoveAndExec</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//简单梳理一下tryRemoveAndExec的执行流程和生命周期.</span></span><br><span class="line"><span class="comment">//a.显然,一上来就判队列的空和参数的空,如果第一个if都进不去,按约定返回true</span></span><br><span class="line"><span class="comment">//b.经过1初始化一个内层循环,并初始化了n,它决定内循环最多跑n次</span></span><br><span class="line"><span class="comment">//如果内循环一直不break(9找到任务或12发现顶部任务是完成态),也假定一般碰不到14(发现目标任务完成了)</span></span><br><span class="line"><span class="comment">//也没有出现几种return(3查出null,14某轮内循环目标task发现被完成了)</span></span><br><span class="line"><span class="comment">//那么最终只会耗尽次数,遍历到底,在13处return false(确定此轮循环task不在队列)</span></span><br><span class="line"><span class="comment">//c.如果出现了几种break(9,12),9其实代表查到任务,12代表顶部任务已完成(官方说取消)</span></span><br><span class="line"><span class="comment">//那就会停止内循环,重新开启一轮外循环,初始化n,继续从新的top到base遍历(b).</span></span><br><span class="line"><span class="comment">//但此时,可能找不到task了(它已经在上一轮内循环出队或被替换成代理)</span></span><br><span class="line"><span class="comment">//但也可能实际上未出队(该task不是top,即4,base也发生了改变造成7未执行),那么可能在本轮循环</span></span><br><span class="line"><span class="comment">//找到任务,在b中进入相应的break,并且成功移除并会进入d,也可能没进入break而是再重复一次b</span></span><br><span class="line"><span class="comment">//d.如果某一次break成功删除了任务,那么外循环更新了n,base,top</span></span><br><span class="line"><span class="comment">//重启了一次内循环,但是所有找到task的分支不会再有了,如果接下来不再碰到被完成(取消)的顶部任务11-12</span></span><br><span class="line"><span class="comment">//同样也没发现目标task完成了(不进14),那么最终的结果就是n次内循环后n降低到0,直接return false.</span></span><br><span class="line"><span class="comment">//e.从b-d任何一次内循环在最后发现了task结束,立即返回false</span></span><br><span class="line"><span class="comment">//否则,它可能在某一次内循环中弹出并执行了该任务,却可能一直在等待它完成,因此这个机制可以让等待task完成前,</span></span><br><span class="line"><span class="comment">//帮助当前WorkQueue清理顶部无效任务等操作.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果task存在,则将它从队列中移除并执行,发现有位于顶部的取消任务,则移除之,只用于awaitJoin</span></span><br><span class="line"><span class="comment">//如果队列空并且任务不知道完成了,则返回true</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRemoveAndExec</span><span class="params">(ForkJoinTask&lt;?&gt; task)</span> </span>&#123;</span><br><span class="line">    ForkJoinTask&lt;?&gt;[] a; <span class="keyword">int</span> m, s, b, n;</span><br><span class="line">    <span class="comment">//进入if的条件,存在非空任务数组,参数task非空</span></span><br><span class="line">    <span class="keyword">if</span> ((a = array) != <span class="keyword">null</span> &amp;&amp; (m = a.length - <span class="number">1</span>) &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">        task != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//循环条件,队列非空.从s开始遍历到b,也就是从顶到底.后进先出</span></span><br><span class="line">        <span class="keyword">while</span> ((n = (s = top) - (b = base)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//1.内层循环.</span></span><br><span class="line">            <span class="keyword">for</span> (ForkJoinTask&lt;?&gt; t;;) &#123;</span><br><span class="line">                <span class="comment">//2.从顶开始的索引j,每次向下找一个.    </span></span><br><span class="line">                <span class="keyword">long</span> j = ((--s &amp; m) &lt;&lt; ASHIFT) + ABASE;</span><br><span class="line">                <span class="keyword">if</span> ((t = (ForkJoinTask&lt;?&gt;)U.getObject(a, j)) == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="comment">//3.取出的是空,返回值取决于top是不是内层循环是第一次运行</span></span><br><span class="line">                    <span class="comment">//外循环每次会将s更新为新top,</span></span><br><span class="line">                    <span class="comment">//内循环则会每次将s减一.内循环只跑了一次的情况,显然会返回true</span></span><br><span class="line">                    <span class="comment">//显然这种情况下top也没有被其他线程更新</span></span><br><span class="line">                    <span class="comment">//内循环又是第一次跑,那么将足以说明当前队列为空,该为false</span></span><br><span class="line">                    <span class="comment">//true的情况,向下遍历了几个元素打到了底</span></span><br><span class="line">                    <span class="comment">//未进入46 10这三种要重开启一轮外循环的情况,也没找到task.</span></span><br><span class="line">                    <span class="comment">//不管怎样,发现空任务就返回</span></span><br><span class="line">                    <span class="keyword">return</span> s + <span class="number">1</span> == top;<span class="comment">// 比预期短,第一个或第n个出现了空值,但循环条件未false</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (t == task) &#123;</span><br><span class="line">                    <span class="comment">//找到的任务t不是空,且是目标任务</span></span><br><span class="line">                    <span class="keyword">boolean</span> removed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (s + <span class="number">1</span> == top) &#123;</span><br><span class="line">                        <span class="comment">//4.发现是首轮内循环,s+1==top成立,进行pop操作,将task弹出并将top减一</span></span><br><span class="line">                        <span class="comment">//显然,task是最顶任务,可以用pop方式,将它置空</span></span><br><span class="line">                        <span class="keyword">if</span> (U.compareAndSwapObject(a, j, task, <span class="keyword">null</span>)) &#123;</span><br><span class="line">                            U.putOrderedInt(<span class="keyword">this</span>, QTOP, s);</span><br><span class="line">                            <span class="comment">//5.置removed为true.</span></span><br><span class="line">                            removed = <span class="keyword">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//6.不是首轮循环,而且base没有在处理期间发生改变</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (base == b) </span><br><span class="line">                        <span class="comment">//7.尝试将task替换成一个EmptyTask实例.成功则removed是true</span></span><br><span class="line">                        <span class="comment">//这样虽然该任务出了队,但在队上还有一个空的任务,而不会出现前面担心的中间null</span></span><br><span class="line">                        <span class="comment">//的情况,也不改变top或base的值</span></span><br><span class="line">                        removed = U.compareAndSwapObject(</span><br><span class="line">                        a, j, task, <span class="keyword">new</span> EmptyTask());</span><br><span class="line">                    <span class="keyword">if</span> (removed)</span><br><span class="line">                        <span class="comment">//8.只要任务成功出队(不论是4还是7,则执行</span></span><br><span class="line">                        task.doExec();</span><br><span class="line">                    <span class="comment">//9.只要找到任务,退出内循环,回到外循环重置相应的条件</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//10.本轮内循环没找到匹配task的任务.</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (t.status &lt; <span class="number">0</span> &amp;&amp; s + <span class="number">1</span> == top) &#123;<span class="comment">//官方注释是取消</span></span><br><span class="line">                    <span class="comment">//11.若t是完成的任务且是首轮内循环且top未变动,将该任务出队并令top减一</span></span><br><span class="line">                    <span class="keyword">if</span> (U.compareAndSwapObject(a, j, t, <span class="keyword">null</span>))</span><br><span class="line">                        U.putOrderedInt(<span class="keyword">this</span>, QTOP, s);</span><br><span class="line">                    <span class="comment">//12.只要进入此分支就退出内循环</span></span><br><span class="line">                    <span class="keyword">break</span>; </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (--n == <span class="number">0</span>)</span><br><span class="line">                    <span class="comment">//13.内循环每执行到此一次,就说明有一次没找到目标任务</span></span><br><span class="line">                    <span class="comment">//减少n(开始时的base top差值).达0时返回false停止循环</span></span><br><span class="line">                    <span class="comment">//即每个内循环都只能执行n次,进入外循环时重置n</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//14.结束了任何一轮内循环时,发现目标task已经完成,则停止外循环返回false</span></span><br><span class="line">            <span class="keyword">if</span> (task.status &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//15.task参数传空,或者当前WorkQueue没有任务,直接返回true</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="popCC"><a href="#popCC" class="headerlink" title="popCC"></a>popCC</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此方法适用于不论共享或者独有的模式,只在helpComplete时使用.</span></span><br><span class="line"><span class="comment">//它会弹出和task相同的CountedCompleter,在前一节讲解CountedCompleter时已介绍过此方法</span></span><br><span class="line"><span class="comment">//父Completer仅能在栈链上找到它的父和祖先completer并帮助减挂起任务数或完成root,但在此处</span></span><br><span class="line"><span class="comment">//它可以帮助栈链上的前置(子任务),前提是要popCC弹出.</span></span><br><span class="line"><span class="keyword">final</span> CountedCompleter&lt;?&gt; popCC(CountedCompleter&lt;?&gt; task, <span class="keyword">int</span> mode) &#123;</span><br><span class="line">    <span class="keyword">int</span> s; ForkJoinTask&lt;?&gt;[] a; Object o;</span><br><span class="line">    <span class="comment">//当前队列有元素.</span></span><br><span class="line">    <span class="keyword">if</span> (base - (s = top) &lt; <span class="number">0</span> &amp;&amp; (a = array) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//老逻辑从顶部确定j.</span></span><br><span class="line">        <span class="keyword">long</span> j = (((a.length - <span class="number">1</span>) &amp; (s - <span class="number">1</span>)) &lt;&lt; ASHIFT) + ABASE;</span><br><span class="line">        <span class="keyword">if</span> ((o = U.getObjectVolatile(a, j)) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">            (o <span class="keyword">instanceof</span> CountedCompleter)) &#123;</span><br><span class="line">            <span class="comment">//当前队列中存在类型为CountedCompleter的元素.对该completer栈链开启一个循环</span></span><br><span class="line">            CountedCompleter&lt;?&gt; t = (CountedCompleter&lt;?&gt;)o;</span><br><span class="line">            <span class="keyword">for</span> (CountedCompleter&lt;?&gt; r = t;;) &#123;</span><br><span class="line">                <span class="comment">//对该CountedCompleter及它的completer栈元素进行遍历,每一个遍历到的临时存放r.</span></span><br><span class="line">                <span class="comment">//找到r==task,说明有一个completer位于task的执行路径.</span></span><br><span class="line">                <span class="keyword">if</span> (r == task) &#123;</span><br><span class="line">                    <span class="comment">//mode小于0,这个mode其实有误解性</span></span><br><span class="line">                    <span class="comment">//它的调用者其实是将一个WorkQueue的config传给了这个mode.</span></span><br><span class="line">                    <span class="comment">//而config只有两处初始化,一是将线程注册到池的时候,初始化WorkQueue</span></span><br><span class="line">                    <span class="comment">//二是外部提交的任务,使用externalSubmit时新建的WorkQueue</span></span><br><span class="line">                    <span class="comment">//config会是负值且没有owner</span></span><br><span class="line">                    <span class="comment">//它也说明是共享队列,需要有锁定机制</span></span><br><span class="line">                    <span class="keyword">if</span> (mode &lt; <span class="number">0</span>) &#123; </span><br><span class="line">                        <span class="comment">//另一个字段qlock派上了用场,将它置为1表示加锁</span></span><br><span class="line">                        <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, QLOCK, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                            <span class="comment">//加锁成功,在top和array这过程中未发生变动的情况下,尝试</span></span><br><span class="line">                            <span class="comment">//将t出队,此时t是栈顶上的元素,它的completer栈链前方有task</span></span><br><span class="line">                            <span class="keyword">if</span> (top == s &amp;&amp; array == a &amp;&amp;</span><br><span class="line">                                U.compareAndSwapObject(a, j, t, <span class="keyword">null</span>)) &#123;</span><br><span class="line">                                U.putOrderedInt(<span class="keyword">this</span>, QTOP, s - <span class="number">1</span>);</span><br><span class="line">                                U.putOrderedInt(<span class="keyword">this</span>, QLOCK, <span class="number">0</span>);</span><br><span class="line">                                <span class="keyword">return</span> t;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">//不论出队成功还是失败,解锁</span></span><br><span class="line">                            U.compareAndSwapInt(<span class="keyword">this</span>, QLOCK, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//非共享队列,直接将t出列</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapObject(a, j, t, <span class="keyword">null</span>)) &#123;</span><br><span class="line">                        U.putOrderedInt(<span class="keyword">this</span>, QTOP, s - <span class="number">1</span>);</span><br><span class="line">                        <span class="keyword">return</span> t;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//只要找到,哪怕两处cas出现不成功的情况,也是竞态失败,break终止循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//r不等于task,找出r的父并开始下轮循环,直到root或找到task为止</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((r = r.completer) == <span class="keyword">null</span>) <span class="comment">// try parent</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//空队列,顶部不是Completer或者不是task的子任务,返回null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="pollAndExecCC"><a href="#pollAndExecCC" class="headerlink" title="pollAndExecCC"></a>pollAndExecCC</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//尝试在无竞态下偷取此WorkQueue中与给定task处于同一个completer栈链上的任务并运行它</span></span><br><span class="line"><span class="comment">//若不成功,返回一个校验合/控制信号给调用它的helpComplete方法</span></span><br><span class="line"><span class="comment">//返回规则,成功偷取则返回1;返回2代表可重试(被其他小偷击败),如果队列非空但未找到匹配task,返回-1</span></span><br><span class="line"><span class="comment">//其他情况返回一个强制负的基准索引.</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">pollAndExecCC</span><span class="params">(CountedCompleter&lt;?&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> b, h; ForkJoinTask&lt;?&gt;[] a; Object o;</span><br><span class="line">    <span class="keyword">if</span> ((b = base) - top &gt;= <span class="number">0</span> || (a = array) == <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">//空队列,与最小整数(负值)取或作为信号h</span></span><br><span class="line">        h = b | Integer.MIN_VALUE;  <span class="comment">// to sense movement on re-poll</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//从底部取索引j</span></span><br><span class="line">        <span class="keyword">long</span> j = (((a.length - <span class="number">1</span>) &amp; b) &lt;&lt; ASHIFT) + ABASE;</span><br><span class="line">        <span class="comment">//用该索引取task取出null,说明被捷足先登了,信号置为可重试</span></span><br><span class="line">        <span class="keyword">if</span> ((o = U.getObjectVolatile(a, j)) == <span class="keyword">null</span>)</span><br><span class="line">            h = <span class="number">2</span>;                  <span class="comment">// retryable</span></span><br><span class="line">        <span class="comment">//取出的非空任务类型不是CountedCompleter.说明不匹配,信号-1</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> CountedCompleter))</span><br><span class="line">            h = -<span class="number">1</span>;                 <span class="comment">// unmatchable</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//是CountedCompleter类型</span></span><br><span class="line">            CountedCompleter&lt;?&gt; t = (CountedCompleter&lt;?&gt;)o;</span><br><span class="line">            <span class="keyword">for</span> (CountedCompleter&lt;?&gt; r = t;;) &#123;</span><br><span class="line">                <span class="comment">//基本同上个方法的逻辑,只是上个方法t取的是top,这里取base.</span></span><br><span class="line">                <span class="comment">//r从t开始找它的父,直到它本身或它的父等于task.将它从底端出队.</span></span><br><span class="line">                <span class="keyword">if</span> (r == task) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (base == b &amp;&amp;</span><br><span class="line">                        U.compareAndSwapObject(a, j, t, <span class="keyword">null</span>)) &#123;</span><br><span class="line">                        <span class="comment">//出队成功,因为我们找的是base,且竞态成功,直接更新base即可</span></span><br><span class="line">                        base = b + <span class="number">1</span>;</span><br><span class="line">                        <span class="comment">//出队后执行该出队的任务.返回1代表成功</span></span><br><span class="line">                        t.doExec();</span><br><span class="line">                        h = <span class="number">1</span>;      <span class="comment">// success</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//base被其他线程修改了,或者cas竞态失败.(其实是一个情况),信号2</span></span><br><span class="line">                    <span class="comment">//可以从新的base开始重试.</span></span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        h = <span class="number">2</span>;      <span class="comment">// lost CAS</span></span><br><span class="line">                    <span class="comment">//只要找到task的子任务就break,返回竞态成功或可重试的信号</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//迭代函数,当前r不是task,将r指向它的父,直到某一个r的父是task或者是null进入else if</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((r = r.completer) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//能够进来,说明r已经指向了root,却没有找到整条链上有这个task,返回信号为未匹配到</span></span><br><span class="line">                    h = -<span class="number">1</span>;         <span class="comment">// unmatched</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="isApparentlyUnblocked"><a href="#isApparentlyUnblocked" class="headerlink" title="isApparentlyUnblocked"></a>isApparentlyUnblocked</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果当前线程拥有此队列且明显未被锁定,返回true</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isApparentlyUnblocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread wt; Thread.State s;</span><br><span class="line">    <span class="comment">//前面提过的scanState会在一上来runTask时和1的反码取与运算,直到运行完任务才会反向运算</span></span><br><span class="line">    <span class="comment">//这个过程,scanState的最后一位会置0,但这与此判断条件关系不大</span></span><br><span class="line">    <span class="comment">//前面对scanState有所注释,小于0代表不活跃</span></span><br><span class="line">    <span class="keyword">return</span> (scanState &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">            <span class="comment">//队列处于活跃态且当前线程的状态不是阻塞,不是等待,不是定时等待,则返回true</span></span><br><span class="line">            (wt = owner) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">            (s = wt.getState()) != Thread.State.BLOCKED &amp;&amp;</span><br><span class="line">            s != Thread.State.WAITING &amp;&amp;</span><br><span class="line">            s != Thread.State.TIMED_WAITING);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;1.规避了伪共享</p>
<p>&emsp;&emsp;2.使用<code>scanState</code>表示运行的状态，版本号。小于0表示：不活跃维护了忙碌标记。忙碌(偶数)，取消忙碌(奇数)。</p>
<p>&emsp;&emsp;3.维护了可变的数组，以及base-top,任务压入队列以后进行数组的容量检测，进行数组的容量扩容，并且保证扩容后元素的索引保持不变。</p>
<p>&emsp;&emsp;4.维护了任务窃取的记录和个数，在溢出等情况及时的累加给线程池。</p>
<p>&emsp;&emsp;5.维护了队列锁，在<code>popCC</code>且当前为共享队列的情形下使用。保证争抢的同步。</p>
<h2 id="ForkJoinPool详解"><a href="#ForkJoinPool详解" class="headerlink" title="ForkJoinPool详解"></a>ForkJoinPool详解</h2><p><img src="/image/hexo/image-20200719215142068.png" alt="image-20200719215142068"></p>
<h3 id="类声明-3"><a href="#类声明-3" class="headerlink" title="类声明"></a>类声明</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@sun</span>.misc.Contended</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinPool</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span></span></span><br></pre></td></tr></table></figure>

<h3 id="构造函数-2"><a href="#构造函数-2" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造函数</span></span><br><span class="line">ForkJoinPool f1 = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">ForkJoinPool f2 = ForkJoinPool.commonPool();</span><br><span class="line"><span class="comment">//parallelism并行级别、默认为CPU核心数</span></span><br><span class="line">ForkJoinPool f3 = <span class="keyword">new</span> ForkJoinPool(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> parallelism      并行级别, 默认为CPU核心数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> factory          工作线程工厂</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> handler          异常处理器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mode        调度模式: true表示FIFO_QUEUE; false表示LIFO_QUEUE</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> workerNamePrefix 工作线程的名称前缀</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">ForkJoinPool</span><span class="params">(<span class="keyword">int</span> parallelism, ForkJoinWorkerThreadFactory factory, UncaughtExceptionHandler handler,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">int</span> mode, String workerNamePrefix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.workerNamePrefix = workerNamePrefix;</span><br><span class="line">    <span class="keyword">this</span>.factory = factory;</span><br><span class="line">    <span class="keyword">this</span>.ueh = handler;</span><br><span class="line">    <span class="keyword">this</span>.config = (parallelism &amp; SMASK) | mode;</span><br><span class="line">    <span class="keyword">long</span> np = (<span class="keyword">long</span>) (-parallelism); <span class="comment">// offset ctl counts</span></span><br><span class="line">    <span class="keyword">this</span>.ctl = ((np &lt;&lt; AC_SHIFT) &amp; AC_MASK) | ((np &lt;&lt; TC_SHIFT) &amp; TC_MASK);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>parallelism</strong>：默认值为CPU核心数，ForkJoinPool里工作线程数量与该参数有关，但它不表示最大线程数；</li>
<li><strong>factory</strong>：工作线程工厂，默认是DefaultForkJoinWorkerThreadFactory，其实就是用来创建工作线程对象——ForkJoinWorkerThread；</li>
<li><strong>handler</strong>：异常处理器；</li>
<li><strong>config</strong>：保存parallelism和mode信息，供后续读取；</li>
<li><strong>ctl</strong>：线程池的核心控制字段</li>
</ul>
<p>这些入参目前不用关注，我们重点是<code>mode</code>这个字段，ForkJoinPool支持两种模式：</p>
<ol>
<li>同步模式（默认方式）：对于工作线程（Worker）自身队列中的任务，采用<strong>后进先出（LIFO）</strong>的方式执行</li>
<li>异步模式：对于工作线程（Worker）自身队列中的任务，采用<strong>先进先出（FIFO）</strong>的方式执行</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mode  &#x3D; asyncMode ? FIFO_QUEUE : LIFO_QUEUE</span><br></pre></td></tr></table></figure>

<h3 id="Executors构建"><a href="#Executors构建" class="headerlink" title="Executors构建"></a>Executors构建</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Executors方法,显然ForkJoinPool被称作工作窃取线程池.参数指定了并行度.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newWorkStealingPool</span><span class="params">(<span class="keyword">int</span> parallelism)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ForkJoinPool</span><br><span class="line">        (parallelism,</span><br><span class="line">        <span class="comment">//默认线程工厂,前文中已提过默认的ForkJoinWorkerThread</span></span><br><span class="line">         ForkJoinPool.defaultForkJoinWorkerThreadFactory,</span><br><span class="line">         <span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//不提供并行度.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newWorkStealingPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ForkJoinPool</span><br><span class="line">        <span class="comment">//使用所有可用的处理器</span></span><br><span class="line">        (Runtime.getRuntime().availableProcessors(),</span><br><span class="line">         ForkJoinPool.defaultForkJoinWorkerThreadFactory,</span><br><span class="line">         <span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对应的,ForkJoinPool的构造器们.</span></span><br><span class="line"><span class="comment">//不指定任何参数.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ForkJoinPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//并行度取MAX_CAP和可用处理器数的最小值.</span></span><br><span class="line">    <span class="keyword">this</span>(Math.min(MAX_CAP, Runtime.getRuntime().availableProcessors()),</span><br><span class="line">        <span class="comment">//默认的线程工厂.无异常处理器,非异步模式.</span></span><br><span class="line">         defaultForkJoinWorkerThreadFactory, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//同上,只是使用参数中的并行度.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ForkJoinPool</span><span class="params">(<span class="keyword">int</span> parallelism)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(parallelism, defaultForkJoinWorkerThreadFactory, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ForkJoinPool</span><span class="params">(<span class="keyword">int</span> parallelism,</span></span></span><br><span class="line"><span class="function"><span class="params">                    ForkJoinWorkerThreadFactory factory,</span></span></span><br><span class="line"><span class="function"><span class="params">                    UncaughtExceptionHandler handler,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">boolean</span> asyncMode)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//并行度需要校验</span></span><br><span class="line">    <span class="keyword">this</span>(checkParallelism(parallelism),</span><br><span class="line">        <span class="comment">//校验线程工厂</span></span><br><span class="line">         checkFactory(factory),</span><br><span class="line">        <span class="comment">//参数指定的未捕获异常处理器.</span></span><br><span class="line">         handler,</span><br><span class="line">        <span class="comment">//前面的几处代码asyncMode都是false,会选用LIFO队列,是true是会选用FIFO队列,后面详述.</span></span><br><span class="line">         asyncMode ? FIFO_QUEUE : LIFO_QUEUE,</span><br><span class="line">        <span class="comment">//线程名前缀</span></span><br><span class="line">         <span class="string">"ForkJoinPool-"</span> + nextPoolId() + <span class="string">"-worker-"</span>);</span><br><span class="line">    <span class="comment">//检查许可,不关心.</span></span><br><span class="line">    checkPermission();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//检查方法很简单.</span></span><br><span class="line"><span class="comment">//并行度不能大于MAX_CAP不能不大于0.</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">checkParallelism</span><span class="params">(<span class="keyword">int</span> parallelism)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parallelism &lt;= <span class="number">0</span> || parallelism &gt; MAX_CAP)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">return</span> parallelism;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//线程工厂非空即可.</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ForkJoinWorkerThreadFactory checkFactory</span><br><span class="line">    (ForkJoinWorkerThreadFactory factory) &#123;</span><br><span class="line">    <span class="keyword">if</span> (factory == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">return</span> factory;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最终构造器,私有.待介绍完一些基础字段后再述.</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">ForkJoinPool</span><span class="params">(<span class="keyword">int</span> parallelism,</span></span></span><br><span class="line"><span class="function"><span class="params">                     ForkJoinWorkerThreadFactory factory,</span></span></span><br><span class="line"><span class="function"><span class="params">                     UncaughtExceptionHandler handler,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">int</span> mode,</span></span></span><br><span class="line"><span class="function"><span class="params">                     String workerNamePrefix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.workerNamePrefix = workerNamePrefix;</span><br><span class="line">    <span class="keyword">this</span>.factory = factory;</span><br><span class="line">    <span class="keyword">this</span>.ueh = handler;</span><br><span class="line">    <span class="comment">//config初始化值,用并行度与mode取或,显然mode是FIFO时,将有一个第17位的1.</span></span><br><span class="line">    <span class="keyword">this</span>.config = (parallelism &amp; SMASK) | mode;</span><br><span class="line">    <span class="comment">//np保存并行度(正数)的相反数(补码).</span></span><br></pre></td></tr></table></figure>

<h3 id="线程工厂"><a href="#线程工厂" class="headerlink" title="线程工厂"></a>线程工厂</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ForkJoinWorkerThread的线程工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">interface</span> <span class="title">ForkJoinWorkerThreadFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建新线程要实现的方法.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ForkJoinWorkerThread <span class="title">newThread</span><span class="params">(ForkJoinPool pool)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//前面看到的默认线程工厂</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultForkJoinWorkerThreadFactory</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">ForkJoinWorkerThreadFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ForkJoinWorkerThread <span class="title">newThread</span><span class="params">(ForkJoinPool pool)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ForkJoinWorkerThread(pool);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建InnocuousForkJoinWorkerThread的线程工厂,上一文已经介绍过</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">InnocuousForkJoinWorkerThreadFactory</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">ForkJoinWorkerThreadFactory</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AccessControlContext innocuousAcc;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        Permissions innocuousPerms = <span class="keyword">new</span> Permissions();</span><br><span class="line">        innocuousPerms.add(modifyThreadPermission);</span><br><span class="line">        innocuousPerms.add(<span class="keyword">new</span> RuntimePermission(</span><br><span class="line">                               <span class="string">"enableContextClassLoaderOverride"</span>));</span><br><span class="line">        innocuousPerms.add(<span class="keyword">new</span> RuntimePermission(</span><br><span class="line">                               <span class="string">"modifyThreadGroup"</span>));</span><br><span class="line">        innocuousAcc = <span class="keyword">new</span> AccessControlContext(<span class="keyword">new</span> ProtectionDomain[] &#123;</span><br><span class="line">                <span class="keyword">new</span> ProtectionDomain(<span class="keyword">null</span>, innocuousPerms)</span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ForkJoinWorkerThread <span class="title">newThread</span><span class="params">(ForkJoinPool pool)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (ForkJoinWorkerThread.InnocuousForkJoinWorkerThread)</span><br><span class="line">            java.security.AccessController.doPrivileged(</span><br><span class="line">                <span class="keyword">new</span> java.security.PrivilegedAction&lt;ForkJoinWorkerThread&gt;() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> ForkJoinWorkerThread <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> ForkJoinWorkerThread.</span><br><span class="line">                        InnocuousForkJoinWorkerThread(pool);</span><br><span class="line">                &#125;&#125;, innocuousAcc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//空任务</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EmptyTask</span> <span class="keyword">extends</span> <span class="title">ForkJoinTask</span>&lt;<span class="title">Void</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">7721805057305804111L</span>;</span><br><span class="line">    EmptyTask() &#123; status = ForkJoinTask.NORMAL; &#125; <span class="comment">//状态直接是已正常完成.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Void <span class="title">getRawResult</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">null</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setRawResult</span><span class="params">(Void x)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">exec</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">true</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 与边界有关的常量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SMASK        = <span class="number">0xffff</span>;        <span class="comment">// 后16位.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_CAP      = <span class="number">0x7fff</span>;        <span class="comment">// 前面在定并行度时参考的最大容量.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EVENMASK     = <span class="number">0xfffe</span>;        <span class="comment">// 后16位验偶数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SQMASK       = <span class="number">0x007e</span>;        <span class="comment">// 最大64个偶数槽,从第2位至7位共6位,2的6次方.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 与WorkQueue有关</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SCANNING     = <span class="number">1</span>;             <span class="comment">// 对WorkQueue正在运行任务的标记</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INACTIVE     = <span class="number">1</span> &lt;&lt; <span class="number">31</span>;       <span class="comment">// 标记负数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SS_SEQ       = <span class="number">1</span> &lt;&lt; <span class="number">16</span>;       <span class="comment">// 版本号使用,第17位1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ForkJoinPool和WorkQueue的config有关常量.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MODE_MASK    = <span class="number">0xffff</span> &lt;&lt; <span class="number">16</span>;  <span class="comment">// 能滤取前16位.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LIFO_QUEUE   = <span class="number">0</span>;<span class="comment">//前面提到过的,非async模式(false),值取0.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FIFO_QUEUE   = <span class="number">1</span> &lt;&lt; <span class="number">16</span>;<span class="comment">//async模式(true),值取1.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_QUEUE = <span class="number">1</span> &lt;&lt; <span class="number">31</span>;       <span class="comment">// 共享队列标识,符号位表示负.</span></span><br></pre></td></tr></table></figure>

<h3 id="提交任务"><a href="#提交任务" class="headerlink" title="提交任务"></a>提交任务</h3><h4 id="invoke-1"><a href="#invoke-1" class="headerlink" title="invoke"></a>invoke</h4><p>&emsp;&emsp;同步方法：调用线程等待任务执行完毕才会返回。</p>
<h4 id="execute"><a href="#execute" class="headerlink" title="execute"></a>execute</h4><p>&emsp;&emsp;异步方法：调用线程立即返回且没有返回值。</p>
<h4 id="submit"><a href="#submit" class="headerlink" title="submit"></a>submit</h4><p>&emsp;&emsp;异步方法：调用线程立即返回且有返回值（<code>Future</code>）。</p>
<h3 id="方法-2"><a href="#方法-2" class="headerlink" title="方法"></a>方法</h3><h4 id="lockRunState"><a href="#lockRunState" class="headerlink" title="lockRunState"></a>lockRunState</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//尝试对runState进行加锁操作</span></span><br><span class="line"><span class="comment">//runState：原值或者新值(竞态且成功)</span></span><br><span class="line"><span class="comment">//简单来说：锁住runState</span></span><br><span class="line"><span class="comment">//标志位设置为1：尝试lock的线程可以更改runState的信号位等</span></span><br><span class="line"><span class="comment">//lockRunState成功的线程则是去更改ctl控制信号、工作队列等</span></span><br><span class="line"><span class="comment">//runState也可以称为：运行状态锁</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">lockRunState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rs;</span><br><span class="line">    <span class="comment">//runState为奇数、表示已经上锁进入awaitRunStateLock</span></span><br><span class="line">    <span class="keyword">return</span> ((((rs = runState) &amp; RSLOCK) != <span class="number">0</span> ||</span><br><span class="line">             <span class="comment">//否则尝试进行CAS：rs+1更改为奇数</span></span><br><span class="line">             !U.compareAndSwapInt(<span class="keyword">this</span>, RUNSTATE, rs, rs |= RSLOCK)) ?</span><br><span class="line">            <span class="comment">//runState已经锁住或者CAS更新rs失败进入awaitRunStateLock等待加锁成功</span></span><br><span class="line">            <span class="comment">//否则返回rs</span></span><br><span class="line">            awaitRunStateLock() : rs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="awaitRunStateLock"><a href="#awaitRunStateLock" class="headerlink" title="awaitRunStateLock"></a>awaitRunStateLock</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//主要自旋或者进行阻塞等待runState锁可用</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">awaitRunStateLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Object lock;</span><br><span class="line">    <span class="keyword">boolean</span> wasInterrupted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> spins = SPINS, r = <span class="number">0</span>, rs, ns;;) &#123;</span><br><span class="line">        <span class="comment">//进入循环再次重新读取rs</span></span><br><span class="line">        <span class="keyword">if</span> (((rs = runState) &amp; RSLOCK) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//rs依旧还是偶数、CAS尝试设置其为奇数、主要为了锁定runState</span></span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, RUNSTATE, rs, ns = rs | RSLOCK)) &#123;</span><br><span class="line">                <span class="comment">//锁成功以后发现了扰动</span></span><br><span class="line">                <span class="comment">//打断当前线程</span></span><br><span class="line">                <span class="keyword">if</span> (wasInterrupted) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.currentThread().interrupt();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//返回一个新的runState、奇数</span></span><br><span class="line">                <span class="comment">//表示已经锁住唯一的出口、也说明了一定要拿到锁</span></span><br><span class="line">                <span class="keyword">return</span> ns;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//被锁住或者出现了CAS竞争失败</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (r == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//循环中仅此执行一次</span></span><br><span class="line">            <span class="comment">//nextSecondarySeed主要是生成一个伪随机码不会返回0</span></span><br><span class="line">            <span class="comment">//其中r的初始值为0</span></span><br><span class="line">            r = ThreadLocalRandom.nextSecondarySeed();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (spins &gt; <span class="number">0</span>) &#123;</span><br><span class="line">             <span class="comment">//将r的值进行一些转换并开启下轮循环.默认spins是0,不会有自旋次数</span></span><br><span class="line">            <span class="comment">//从源码来看,自旋的唯一作用就是改变r的值,使之可能重新进入</span></span><br><span class="line">            <span class="comment">//也会根据r的结果决定是否减少一次自旋.</span></span><br><span class="line">            <span class="comment">//r的算法,将当前r的后6位保留,用r的后26位与前26位异或被保存为r的前26位(a)</span></span><br><span class="line">            <span class="comment">//再将(a)的结果处理,r的前21位保持不变,后11位与前11位异或并保存为r的后11位(b)</span></span><br><span class="line">            <span class="comment">//再将(b)的结果处理,r的后7位保持不变,用前25位与后25位异或并保存为r的前25位(c)</span></span><br><span class="line">            <span class="comment">//个中数学原理,有兴趣的研究一下吧</span></span><br><span class="line">            <span class="comment">//显然,自旋次数并不是循环次数,它只能决定进入6中锁代码块前要运行至少几轮循环</span></span><br><span class="line">            r ^= r &lt;&lt; <span class="number">6</span>; r ^= r &gt;&gt;&gt; <span class="number">21</span>; r ^= r &lt;&lt; <span class="number">7</span>; <span class="comment">// xorshift</span></span><br><span class="line">            <span class="keyword">if</span> (r &gt;= <span class="number">0</span>)</span><br><span class="line">                <span class="comment">//r依旧大于等于0则自旋次数-1</span></span><br><span class="line">                --spins;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//r不为0，</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((rs &amp; STARTED) == <span class="number">0</span> || (lock = stealCounter) == <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">//线程的runState还没有开启或者说还没有初始化锁stealCounter</span></span><br><span class="line">            <span class="comment">//处于了初始化的竞态让出当前线程的执行去</span></span><br><span class="line">            <span class="comment">//再次获取到执行权、重新进入循环</span></span><br><span class="line">            Thread.yield();   <span class="comment">// initialization race</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, RUNSTATE, rs, rs | RSIGNAL)) &#123;</span><br><span class="line">        	<span class="comment">//没能对runState加锁,也不是5中的初始化时竞态的情况,尝试加上信号位</span></span><br><span class="line">            <span class="comment">//以stealCounter进行加锁.</span></span><br><span class="line">            <span class="comment">//显然,这种加信号位的加法不会因为信号位而失败而会因为runState的其他字段比如锁标识位失败              //重新开始循环即可</span></span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                <span class="comment">//double check</span></span><br><span class="line">                <span class="keyword">if</span> ((runState &amp; RSIGNAL) != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//runState拥有信号位的值</span></span><br><span class="line">                    <span class="comment">//说明没有线程去释放信号位</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                      	<span class="comment">//runState期间没有被除去信号位陷入等待</span></span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                        <span class="comment">//等待中出现了异常情况、会中断线程</span></span><br><span class="line">                        <span class="keyword">if</span> (!(Thread.currentThread() <span class="keyword">instanceof</span></span><br><span class="line">                              ForkJoinWorkerThread))</span><br><span class="line">                            wasInterrupted = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="comment">//当前的runState没有信号位的值</span></span><br><span class="line">                    <span class="comment">//说明已经被释放了、唤醒等待的同步块里面的线程</span></span><br><span class="line">                    <span class="comment">//</span></span><br><span class="line">                    lock.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;1.主要针对<code>runState</code>操作，对该字段进行标识。严格意义上来讲，这是为了<code>ctl\工作队列</code>等运行时数据服务的。对运行时数据的修改权限加锁。</p>
<p>&emsp;&emsp;2.加锁的过程：自旋+阻塞的方式，如果线程池还处于初始话状态则让出执行权。</p>
<p>&emsp;&emsp;3.同时也设定了自旋的次数,使用随机数判断是否需要减少自旋次数，其降低为0之前不会阻塞。</p>
<p>&emsp;&emsp;4.加锁的流程主要是进行了一轮又一轮的循环，尝试去设置锁标志位，修改成功返回新的标识，否则去修改信号位（原子性操作）。唯一可能失败的主要是<code>runState</code>的其他位发生了改变，并且很可能是因为锁标识位被释放的缘故。</p>
<p>&emsp;&emsp;5.如果没有其他的线程竞争去修改<code>runState</code>,那么直接CAS可以成功，并且不需要唤醒其他的线程。否则CAS尝试失败，那么直接暴力重置了<code>newState</code>并且唤醒阻塞的线程。</p>
<h4 id="createWorker"><a href="#createWorker" class="headerlink" title="createWorker"></a>createWorker</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//尝试工作线程的构建和开启</span></span><br><span class="line"><span class="comment">//它假定已经有别处维护了预留的增加总数</span></span><br><span class="line"><span class="comment">//创建和启动过程中出现任何异常,就执行工作线程的卸载</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">createWorker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//前面构造器传入的factory.</span></span><br><span class="line">    ForkJoinWorkerThreadFactory fac = factory;</span><br><span class="line">    Throwable ex = <span class="keyword">null</span>;</span><br><span class="line">    ForkJoinWorkerThread wt = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//创建线程成功</span></span><br><span class="line">        <span class="keyword">if</span> (fac != <span class="keyword">null</span> &amp;&amp; (wt = fac.newThread(<span class="keyword">this</span>)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//启动该线程.</span></span><br><span class="line">            wt.start();</span><br><span class="line">            <span class="comment">//启动也成功,返回true</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable rex) &#123;</span><br><span class="line">        <span class="comment">//出现异常,保存</span></span><br><span class="line">        ex = rex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//用前面的异常卸载</span></span><br><span class="line">    deregisterWorker(wt, ex);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="tryAddWorker"><a href="#tryAddWorker" class="headerlink" title="tryAddWorker"></a>tryAddWorker</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//尝试添加一个worker</span></span><br><span class="line"><span class="comment">//并在完成前增加ctl里面记录的数量(AC参数</span></span><br><span class="line"><span class="comment">//增加过程是否进行决定于createWorker返回的true还是false</span></span><br><span class="line"><span class="comment">//参数c是一个进入控制信号ctl</span></span><br><span class="line"><span class="comment">//它的总计数为负且没有空闲worker,cas(增加ctl)失败时,若ctl未改变,则可以刷新重试</span></span><br><span class="line"><span class="comment">//否则说明被添加了一个worker,那么它也就不需要再继续了</span></span><br><span class="line"><span class="comment">//从方法的实现上看,c似乎可以传任何值</span></span><br><span class="line"><span class="comment">//如果c传入的值不等于当前ctl,则会多一次循环重读ctl到c</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">tryAddWorker</span><span class="params">(<span class="keyword">long</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//标记add成功与否</span></span><br><span class="line">    <span class="keyword">boolean</span> add = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">//根据参数c生成一个新的ctrl/nc</span></span><br><span class="line">        <span class="comment">//c源自参数或者某一次循环读取的ctl.</span></span><br><span class="line">        <span class="comment">//nc的值计算结果:c加上一个活跃单位1&lt;&lt;48,并对结果保留前16位</span></span><br><span class="line">        <span class="comment">//c加上一个总数单位1&lt;&lt;32,并对结果保留第二个16位(33到48位)</span></span><br><span class="line">        <span class="comment">//nc等于上两步的结果和.显然,nc的后32位全部是0</span></span><br><span class="line">        <span class="keyword">long</span> nc = ((AC_MASK &amp; (c + AC_UNIT)) |</span><br><span class="line">                   (TC_MASK &amp; (c + TC_UNIT)));</span><br><span class="line">        <span class="comment">//ctl未改变</span></span><br><span class="line">        <span class="keyword">if</span> (ctl == c) &#123;</span><br><span class="line">            <span class="comment">//阻塞加锁并判断是否已在终止</span></span><br><span class="line">            <span class="keyword">int</span> rs, stop;                 <span class="comment">// check if terminating</span></span><br><span class="line">            <span class="keyword">if</span> ((stop = (rs = lockRunState()) &amp; STOP) == <span class="number">0</span>)</span><br><span class="line">                <span class="comment">//加锁成功且未终止,尝试cas掉ctl.</span></span><br><span class="line">                add = U.compareAndSwapLong(<span class="keyword">this</span>, CTL, c, nc);</span><br><span class="line">            <span class="comment">//加锁成功,不论cas ctl是否成功,解锁</span></span><br><span class="line">            unlockRunState(rs, rs &amp; ~RSLOCK);</span><br><span class="line">            <span class="comment">//如果已stop,break退出添加worker的步骤</span></span><br><span class="line">            <span class="keyword">if</span> (stop != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (add) &#123;</span><br><span class="line">                <span class="comment">//加锁成功,cas也成功,线程池未进入终止流程,创建worker</span></span><br><span class="line">                createWorker();</span><br><span class="line">                <span class="comment">//创建成功立即break</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这时为前32位发生了变化,只能在新一轮循环处理.注:ADD_WORKER位是第48位,前面已提到</span></span><br><span class="line">        <span class="comment">//它是TC_MASK能负责的最高位</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (((c = ctl) &amp; ADD_WORKER) != <span class="number">0L</span> &amp;&amp; (<span class="keyword">int</span>)c == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="registerWorker"><a href="#registerWorker" class="headerlink" title="registerWorker"></a>registerWorker</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将线程注册入池,同时返回一个WorkQueue,工作线程会在内部记录这个队列.</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> WorkQueue <span class="title">registerWorker</span><span class="params">(ForkJoinWorkerThread wt)</span> </span>&#123;</span><br><span class="line">    UncaughtExceptionHandler handler;</span><br><span class="line">    <span class="comment">//设置成守护线程,这样保证用户线程都已释放的情况下关闭虚拟机</span></span><br><span class="line">    wt.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">if</span> ((handler = ueh) != <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">//构造器提供了异常处理器</span></span><br><span class="line">        wt.setUncaughtExceptionHandler(handler);</span><br><span class="line">    <span class="comment">//构建工作队列</span></span><br><span class="line">    WorkQueue w = <span class="keyword">new</span> WorkQueue(<span class="keyword">this</span>, wt);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>; </span><br><span class="line">    <span class="comment">//取出池config的17-32位保存为mode,</span></span><br><span class="line">    <span class="comment">//前面提过,config在构造时由并行度(后15位)和模式(第17位)表示,根据17位是否有值决定FIFO或LIFO</span></span><br><span class="line">    <span class="comment">//这个与运算进行后,相当于滤掉了并行度信息.                                 </span></span><br><span class="line">    <span class="keyword">int</span> mode = config &amp; MODE_MASK;</span><br><span class="line">    <span class="comment">//创建完队列之后要加锁,尤其后面涉及到可能的数组扩容拷贝,以及一些判断和重设随机数等</span></span><br><span class="line">    <span class="keyword">int</span> rs = lockRunState();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        WorkQueue[] ws; <span class="keyword">int</span> n;      </span><br><span class="line">        <span class="comment">//前面构造器我们看过,没有初始化workQueues,所以如果一个线程此时来注册是被忽略的</span></span><br><span class="line">        <span class="comment">//显然,使用它们的方法一定做了相应的保证.我们后续再看.              </span></span><br><span class="line">        <span class="keyword">if</span> ((ws = workQueues) != <span class="keyword">null</span> &amp;&amp; (n = ws.length) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//队列非空,递增种子.</span></span><br><span class="line">            <span class="comment">//indexSeed值是0,SEED_INCREMENT是每次相加的增量,它的值默认是0x9e3779b9(2654435769)</span></span><br><span class="line">            <span class="comment">//这是一个特殊的值,它的使用不仅此一处,后面稍微介绍.这样减少碰撞可能性</span></span><br><span class="line">            <span class="keyword">int</span> s = indexSeed += SEED_INCREMENT;  </span><br><span class="line">            <span class="keyword">int</span> m = n - <span class="number">1</span>;<span class="comment">//ws数组长度-1,数组长度一定是偶数(后面介绍)</span></span><br><span class="line">            i = ((s &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>) &amp; m;<span class="comment">//奇数位i.</span></span><br><span class="line">            <span class="keyword">if</span> (ws[i] != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//满足这个条件就是发生碰撞了,i已被占用.初始化probes为0</span></span><br><span class="line">                <span class="keyword">int</span> probes = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">//定义步长,数组长度不大于4,步长2,否则取n一半的第2至16位的结果(偶数)再加上2作为步长</span></span><br><span class="line">                <span class="keyword">int</span> step = (n &lt;= <span class="number">4</span>) ? <span class="number">2</span> : ((n &gt;&gt;&gt; <span class="number">1</span>) &amp; EVENMASK) + <span class="number">2</span>;</span><br><span class="line">                <span class="comment">//开启循环,每次对i加上步长并与m求与运算,直到无碰撞为止</span></span><br><span class="line">                <span class="keyword">while</span> (ws[i = (i + step) &amp; m] != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//每次循环增加probes,表示对同一个数组最多只循环n次,达到次数要进行扩容重试</span></span><br><span class="line">                    <span class="keyword">if</span> (++probes &gt;= n) &#123;</span><br><span class="line">                        <span class="comment">//当前数组已经尝试n次,还没有找到无碰撞点,扩容数组一倍,原位置拷贝</span></span><br><span class="line">                        <span class="comment">//此处没有任何加锁动作,与循环之外创建好队列之后的代码共享一个锁,也是lockRunState</span></span><br><span class="line">                        <span class="comment">//可见只有指派索引相关的动作才需要加锁.</span></span><br><span class="line">                        workQueues = ws = Arrays.copyOf(ws, n &lt;&lt;= <span class="number">1</span>);</span><br><span class="line">                        <span class="comment">//重置条件.</span></span><br><span class="line">                        m = n - <span class="number">1</span>;</span><br><span class="line">                        probes = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//s值保存给队列的hint作为随机数种子</span></span><br><span class="line">            <span class="comment">//可见,此处至少可说明每个注册线程时创建的队列都会有不同的hint,它也算是一个标识</span></span><br><span class="line">            w.hint = s;    </span><br><span class="line">            <span class="comment">//队列的配置,i与mode取或,mode只能是0或1&lt;&lt;16 </span></span><br><span class="line">            <span class="comment">//这个结果是将mode可能存放在队列config的17位,从而和池中的config在模式这一块保持一致.</span></span><br><span class="line">            <span class="comment">//i一定是一个不大于m(n-1)的奇数,而n一定不超过后16位(后面叙述),它和mode互不影响.  </span></span><br><span class="line">            <span class="comment">//故队列的config相当于同时保存了在池的workQueues数组的索引和所属池的FIFO或LIFO.                    </span></span><br><span class="line">            w.config = i | mode;</span><br><span class="line">            <span class="comment">//初始化scanState,以奇数i(索引)当值.相当于发布了初始屏障.</span></span><br><span class="line">            <span class="comment">//(不理解?参考runState方法,一上来就将它的末位置0成偶数)</span></span><br><span class="line">            w.scanState = i; </span><br><span class="line">            <span class="comment">//新建的队列置于i处.</span></span><br><span class="line">            ws[i] = w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//解锁.</span></span><br><span class="line">        unlockRunState(rs, rs &amp; ~RSLOCK);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//线程名,这里看到一个有趣的事,无符号右移,i一定是个奇数,假定右移后的值是j,则2*j=i</span></span><br><span class="line">    wt.setName(workerNamePrefix.concat(Integer.toString(i &gt;&gt;&gt; <span class="number">1</span>)));</span><br><span class="line">    <span class="comment">//返回队列给线程</span></span><br><span class="line">    <span class="keyword">return</span> w;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="nextSecondarySeed"><a href="#nextSecondarySeed" class="headerlink" title="nextSecondarySeed"></a>nextSecondarySeed</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">nextSecondarySeed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="keyword">if</span> ((r = UNSAFE.getInt(t, SECONDARY)) != <span class="number">0</span>) &#123;</span><br><span class="line">        r ^= r &lt;&lt; <span class="number">13</span>;   <span class="comment">// xorshift</span></span><br><span class="line">        r ^= r &gt;&gt;&gt; <span class="number">17</span>;</span><br><span class="line">        r ^= r &lt;&lt; <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//原来secondary是0,localInit一个值.</span></span><br><span class="line">        localInit();</span><br><span class="line">        <span class="keyword">if</span> ((r = (<span class="keyword">int</span>)UNSAFE.getLong(t, SEED)) == <span class="number">0</span>)</span><br><span class="line">            r = <span class="number">1</span>; <span class="comment">// avoid zero</span></span><br><span class="line">    &#125;</span><br><span class="line">    UNSAFE.putInt(t, SECONDARY, r);</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="localInit"><a href="#localInit" class="headerlink" title="localInit"></a>localInit</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//localInit</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">localInit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//生成器是一个AtomicLong,从0开始,每次加入PROBE_INCREMENT.</span></span><br><span class="line">    <span class="keyword">int</span> p = probeGenerator.addAndGet(PROBE_INCREMENT);</span><br><span class="line">    <span class="keyword">int</span> probe = (p == <span class="number">0</span>) ? <span class="number">1</span> : p; <span class="comment">// skip 0</span></span><br><span class="line">    <span class="keyword">long</span> seed = mix64(seeder.getAndAdd(SEEDER_INCREMENT));</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    UNSAFE.putLong(t, SEED, seed);</span><br><span class="line">    UNSAFE.putInt(t, PROBE, probe);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//初值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROBE_INCREMENT = <span class="number">0x9e3779b9</span></span><br></pre></td></tr></table></figure>

<h4 id="deregisterWorker"><a href="#deregisterWorker" class="headerlink" title="deregisterWorker"></a>deregisterWorker</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//解除注册操作.它是一个要终止的工作线程的最终回调,或者创建失败时也会回调.在介绍ForkJoinWorkerThread和前面createWorker时提过.</span></span><br><span class="line"><span class="comment">//这会从数组中移除worker记录,调整数量.如果池已经处在关闭进行中,尝试帮助完成池的关闭.</span></span><br><span class="line"><span class="comment">//参数wt是工作线程,构建失败会是null,ex是造成失败的异常.它也可以是null.</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">deregisterWorker</span><span class="params">(ForkJoinWorkerThread wt, Throwable ex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//处理队列从池的队列数组中的移除.</span></span><br><span class="line">    WorkQueue w = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (wt != <span class="keyword">null</span> &amp;&amp; (w = wt.workQueue) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//存在工作线程且该工作线程有队列的逻辑.</span></span><br><span class="line">        WorkQueue[] ws;            </span><br><span class="line">        <span class="comment">//前面说过,队列的config后16位表示索引,第17位表示mode.         </span></span><br><span class="line">        <span class="keyword">int</span> idx = w.config &amp; SMASK;</span><br><span class="line">        <span class="comment">//加运行时状态锁.</span></span><br><span class="line">        <span class="keyword">int</span> rs = lockRunState();</span><br><span class="line">        <span class="keyword">if</span> ((ws = workQueues) != <span class="keyword">null</span> &amp;&amp; ws.length &gt; idx &amp;&amp; ws[idx] == w)</span><br><span class="line">            <span class="comment">//简单的置空操作.</span></span><br><span class="line">            ws[idx] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//解锁.</span></span><br><span class="line">        unlockRunState(rs, rs &amp; ~RSLOCK);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//处理控制信号中保存的数量.</span></span><br><span class="line">    <span class="keyword">long</span> c; </span><br><span class="line">    <span class="comment">//循环直到减数成功. 哪怕有别的线程在竞态减少,当前方法也要在新的ctl中减少数量                                    </span></span><br><span class="line">    <span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (!U.compareAndSwapLong</span><br><span class="line">                 <span class="comment">//第49位减1.</span></span><br><span class="line">                 (<span class="keyword">this</span>, CTL, c = ctl, ((AC_MASK &amp; (c - AC_UNIT)) |</span><br><span class="line">                                       <span class="comment">//第33位减1.</span></span><br><span class="line">                                       (TC_MASK &amp; (c - TC_UNIT)) |</span><br><span class="line">                                       <span class="comment">//保留后32位.</span></span><br><span class="line">                                       (SP_MASK &amp; c))));</span><br><span class="line">    <span class="comment">//该工作线程有队列,且已经在1出了数组</span></span><br><span class="line">    <span class="keyword">if</span> (w != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//把队列锁设定负数.</span></span><br><span class="line">        w.qlock = -<span class="number">1</span>;                            </span><br><span class="line">        <span class="comment">//把队列中记录的偷取任务数加到池中.前面已论述过此方法</span></span><br><span class="line">        w.transferStealCount(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">//取消队列中所有存活的任务.</span></span><br><span class="line">        w.cancelAll();                         </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//进入循环尝试帮助关闭池或释放阻塞线程,补偿线程等</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;                                   </span><br><span class="line">        WorkQueue[] ws; <span class="keyword">int</span> m, sp;</span><br><span class="line">        <span class="comment">// tryTerminate后面介绍,第一个参数true代表无条件立即结束,第二个参数true</span></span><br><span class="line">        <span class="comment">//代表下次tryTerminate将可以结束.</span></span><br><span class="line">        <span class="keyword">if</span> (tryTerminate(<span class="keyword">false</span>, <span class="keyword">false</span>) || w == <span class="keyword">null</span> || w.array == <span class="keyword">null</span> ||</span><br><span class="line">            (runState &amp; STOP) != <span class="number">0</span> || (ws = workQueues) == <span class="keyword">null</span> ||</span><br><span class="line">            (m = ws.length - <span class="number">1</span>) &lt; <span class="number">0</span>)              </span><br><span class="line">            <span class="comment">//进入if,说明正在结束或已结束,没什么可做的了.</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//控制信号后32位有数值,进尝试释放逻辑.这不是第一次看到ctl的后32了.对于ctl的前32位,</span></span><br><span class="line">        <span class="comment">//我们已经通过构造函数和前面的代码说明,它初始化时与并行度有关,并在后面存放了添加worker数量</span></span><br><span class="line">        <span class="comment">//的值(但不能说存放了并行度,因为添加worker会改变相应的位),后32位的真相也开始浮出水面,</span></span><br><span class="line">        <span class="comment">//在前面的tryAddWorker中,第二轮及以后的循环条件要求后32位不能存在值.而且添加成功也会</span></span><br><span class="line">        <span class="comment">//将后32位置0,故tryAddWorker的第一轮循环会清空后32位,与此有所影响.</span></span><br><span class="line">        <span class="keyword">if</span> ((sp = (<span class="keyword">int</span>)(c = ctl)) != <span class="number">0</span>) &#123; </span><br><span class="line">            <span class="comment">//后32位有值,尝试release,tryRealease方法会将activeCount数量添加第三个参数的值</span></span><br><span class="line">            <span class="comment">//如果第二个参数代表的队列是空闲worker的栈顶,则释放其内的阻塞者</span></span><br><span class="line">            <span class="keyword">if</span> (tryRelease(c, ws[sp &amp; m], AC_UNIT))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//仅有此处释放失败的情况下,开启下一轮循环,其他分支均会退出循环.</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ex != <span class="keyword">null</span> &amp;&amp; (c &amp; ADD_WORKER) != <span class="number">0L</span>) &#123;</span><br><span class="line">            <span class="comment">//此次解除注册是因为异常,且当前添加worker信号依旧满足,则添加一个worker代替原来并退出</span></span><br><span class="line">            tryAddWorker(c);                      </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="comment">// 不需要添加补偿worker,退出循环                             </span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ex == <span class="keyword">null</span>) </span><br><span class="line">        <span class="comment">//前面记录的异常不存在,帮助清理脏异常节点                             </span></span><br><span class="line">        ForkJoinTask.helpExpungeStaleExceptions();</span><br><span class="line">    <span class="keyword">else</span>   </span><br><span class="line">        <span class="comment">//存在异常,重抛.                                     </span></span><br><span class="line">        ForkJoinTask.rethrow(ex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="signalWork"><a href="#signalWork" class="headerlink" title="signalWork"></a>signalWork</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果当前活跃线程数过少,尝试去创建或活化一个worker.</span></span><br><span class="line"><span class="comment">//参数ws是想要找到被唤醒者的队列数组(也就是任何一个ForkJoinPool的成员变量),</span></span><br><span class="line"><span class="comment">//参数q是个非空的队列,则方法只尝试一次,不会重试</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signalWork</span><span class="params">(WorkQueue[] ws, WorkQueue q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> c; <span class="keyword">int</span> sp, i; WorkQueue v; Thread p;</span><br><span class="line">    <span class="keyword">while</span> ((c = ctl) &lt; <span class="number">0L</span>) &#123; </span><br><span class="line">        <span class="comment">//添加worker步骤                      </span></span><br><span class="line">        <span class="comment">//ctl小于0,表示active的太少.但似乎也只能最多加上并行度的数量</span></span><br><span class="line">        <span class="keyword">if</span> ((sp = (<span class="keyword">int</span>)c) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//取ctl的后32位,终于,终于看明白了,这里有一个注释,sp==0代表无闲置worker</span></span><br><span class="line">            <span class="comment">//但不代表后32位全部与闲置worker有关.</span></span><br><span class="line">            <span class="keyword">if</span> ((c &amp; ADD_WORKER) != <span class="number">0L</span>) </span><br><span class="line">                <span class="comment">//ADD_WORKER位有值,说明总worker数量未达到.</span></span><br><span class="line">                <span class="comment">//经过三重关,添加worker.          </span></span><br><span class="line">                tryAddWorker(c);</span><br><span class="line">            <span class="comment">//满足添加worker的第一个条件,无闲置worker,不论有没有成功创建新的worker</span></span><br><span class="line">            <span class="comment">//就都一定会退出循环</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//不存在空闲worker,验证不满足唤醒流程的情况.</span></span><br><span class="line">        <span class="keyword">if</span> (ws == <span class="keyword">null</span>)  </span><br><span class="line">            <span class="comment">//队列数组都还没初始化,显然池不满足条件.                          </span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (ws.length &lt;= (i = sp &amp; SMASK))<span class="comment">// </span></span><br><span class="line">            <span class="comment">//队列数组长度不大于ctl后16位.说明已进入终止态.退出(多像数组的length一定要大于索引)</span></span><br><span class="line">            <span class="comment">//又一次大揭密,ctl后16位似乎与队列数组的长度有关,而且存放的是一个索引. </span></span><br><span class="line">            <span class="comment">//此处隐含条件,ctl后32位不是0,将它的后16位取出来当索引i,要结合1处的条件.      </span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> ((v = ws[i]) == <span class="keyword">null</span>) </span><br><span class="line">            <span class="comment">//队列数组长度正常, 使用索引(ctl的后15位)从ws中取不出队列.</span></span><br><span class="line">            <span class="comment">//说明正在终止,退出.</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//满足了唤醒流程</span></span><br><span class="line">        <span class="comment">//计算数据,第一个为下一个scanState,在前面的addWorker流程,我们看到</span></span><br><span class="line">        <span class="comment">//scanState的第一个值是在队列数组中的索引.显然索引不能乱变.</span></span><br><span class="line">        <span class="comment">//新的scanState值计算,老ctl的整数位在17位加1(SS_SEQ)再取它的后31位.显然每次被唤醒都会走一次这个逻辑.</span></span><br><span class="line">        <span class="keyword">int</span> vs = (sp + SS_SEQ) &amp; ~INACTIVE; </span><br><span class="line">        <span class="keyword">int</span> d = sp - v.scanState; <span class="comment">//屏蔽不必要的cas.   </span></span><br><span class="line">        <span class="comment">//计算nc,它用老的ctl加一个活跃位(48位),然后只取出前32位</span></span><br><span class="line">        <span class="comment">//对后32位取出队列v在上次扫描时存放的值(也是当时ctl的后32位)</span></span><br><span class="line">        <span class="comment">//这里我们又见到一个熟人:stackPred,接下来会有重要的方法使用它.          </span></span><br><span class="line">        <span class="keyword">long</span> nc = (UC_MASK &amp; (c + AC_UNIT)) | (SP_MASK &amp; v.stackPred);</span><br><span class="line">        <span class="comment">//d是0说明ctl的后32位相对于原来v中存放的scanState没有变化,那么也就不需要cas</span></span><br><span class="line">        <span class="comment">//d不是0,需要cas,用nc替换掉c</span></span><br><span class="line">        <span class="keyword">if</span> (d == <span class="number">0</span> &amp;&amp; U.compareAndSwapLong(<span class="keyword">this</span>, CTL, c, nc)) &#123;</span><br><span class="line">            <span class="comment">//把v的scanDate置换成vs,激活了v</span></span><br><span class="line">            v.scanState = vs;                      </span><br><span class="line">            <span class="keyword">if</span> ((p = v.parker) != <span class="keyword">null</span>)</span><br><span class="line">                <span class="comment">//有线程阻塞,唤醒</span></span><br><span class="line">                U.unpark(p);</span><br><span class="line">            <span class="comment">//激活成功,退出循环.</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4.上述过程没有成功,看q是否提供,如果提供了不循环第二次</span></span><br><span class="line">        <span class="keyword">if</span> (q != <span class="keyword">null</span> &amp;&amp; q.base == q.top)        </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="tryRelease"><a href="#tryRelease" class="headerlink" title="tryRelease"></a>tryRelease</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//唤醒并释放worker v(队列),如果它处于空闲worker栈的顶部,此方法是当至少有一个空闲worker</span></span><br><span class="line"><span class="comment">//时的一个快速唤醒方式.</span></span><br><span class="line"><span class="comment">//它的参数,c应当传入此前读取的ctl,v是一个工作队列,如果不传空,应当传一个worker过来,inc代表活跃数的增加数</span></span><br><span class="line"><span class="comment">//如果成功释放,则返回true</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">long</span> c, WorkQueue v, <span class="keyword">long</span> inc)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//类似上面的signalWork方法的计算方式,sp保存ctl的后32位,vs为队列v的下一个scanState.</span></span><br><span class="line">    <span class="comment">//值依旧是sp在17位加1并只取结果的31位.</span></span><br><span class="line">    <span class="keyword">int</span> sp = (<span class="keyword">int</span>)c, vs = (sp + SS_SEQ) &amp; ~INACTIVE; Thread p;</span><br><span class="line">    <span class="comment">//判断是否满足条件,v存在且v的scanState是sp</span></span><br><span class="line">    <span class="comment">//(言外之意sp保存的是一个v的scanState,别急,我们离真相越来越近了,注释说此条件代表v是栈顶)</span></span><br><span class="line">    <span class="keyword">if</span> (v != <span class="keyword">null</span> &amp;&amp; v.scanState == sp) &#123;</span><br><span class="line">        <span class="comment">//满足了前述的条件,v是当前"栈顶",这个栈顶的含义有些奇怪,没有栈,何来栈顶?别急</span></span><br><span class="line">        <span class="comment">//计算新的ctl,算法同上,老ctl加上inc的结果的前32位给nc的前32位</span></span><br><span class="line">        <span class="comment">//v保存的stackPred作为nc的后32位</span></span><br><span class="line">        <span class="comment">//在前面deregisterWorker中,tryRelease方法传入的inc为一个AC_UNIT.相当于增加一个活跃数</span></span><br><span class="line">        <span class="keyword">long</span> nc = (UC_MASK &amp; (c + inc)) | (SP_MASK &amp; v.stackPred);</span><br><span class="line">        <span class="comment">//尝试用前面计算的结果更新为新值.</span></span><br><span class="line">        <span class="keyword">if</span> (U.compareAndSwapLong(<span class="keyword">this</span>, CTL, c, nc)) &#123;</span><br><span class="line">            <span class="comment">//控制信号成功更新为nc,则将v的scanState保存为vs.</span></span><br><span class="line">            v.scanState = vs;</span><br><span class="line">            <span class="keyword">if</span> ((p = v.parker) != <span class="keyword">null</span>)</span><br><span class="line">                <span class="comment">//存在parker,唤醒.</span></span><br><span class="line">                U.unpark(p);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="runWorker"><a href="#runWorker" class="headerlink" title="runWorker"></a>runWorker</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//runWorker方法是线程运行的最顶层方法,它由ForkJoinWorkerThread在注册成功后调用,也是全部生命周期</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(WorkQueue w)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//一上来初始化数组,前面说过,WorkQueue内部的任务数组初始化是null</span></span><br><span class="line">    w.growArray();  </span><br><span class="line">    <span class="comment">//用seed保留构建时的hint随机数,在registerWorker方法中曾介绍过</span></span><br><span class="line">    <span class="comment">//会有一个随机数s是保证每个队列不同的,且其中有一个每次增加一个值的成份,该值是个数学中很奇异的数字</span></span><br><span class="line">    <span class="comment">//而hint的初值即这个s,它同时也被用于确定队列在ws中的索引,间接决定是否扩容      </span></span><br><span class="line">    <span class="keyword">int</span> seed = w.hint; </span><br><span class="line">    <span class="comment">//初始化r,并避免异或时出现0</span></span><br><span class="line">    <span class="keyword">int</span> r = (seed == <span class="number">0</span>) ? <span class="number">1</span> : seed;  </span><br><span class="line">    <span class="comment">//循环</span></span><br><span class="line">    <span class="keyword">for</span> (ForkJoinTask&lt;?&gt; t;;) &#123;</span><br><span class="line">        <span class="comment">//尝试"scan"(终于出现了有没有)队列w,使用随机数r</span></span><br><span class="line">        <span class="keyword">if</span> ((t = scan(w, r)) != <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">//scan到了一个任务t,则运行它.这是进入一个任务处理的主流程</span></span><br><span class="line">            <span class="comment">//前面已介绍过WorkQueue的runTask方法</span></span><br><span class="line">            <span class="comment">//回忆一下,它会在过程中把scanState标记为忙碌</span></span><br><span class="line">            w.runTask(t);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!awaitWork(w, r))</span><br><span class="line">            <span class="comment">//scan不到,尝试等待任务,如果等待过一段时间还未等待,进入8重置r,继续下轮循环scan.若awaitWork返回false代表应break结束worker</span></span><br><span class="line">            <span class="comment">//关于awaitWork的返回我们后面详解</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//或许只能说just math</span></span><br><span class="line">        r ^= r &lt;&lt; <span class="number">13</span>; r ^= r &gt;&gt;&gt; <span class="number">17</span>; r ^= r &lt;&lt; <span class="number">5</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="scan"><a href="#scan" class="headerlink" title="scan"></a>scan</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//尝试扫描队列,并偷取一个"顶级"的任务.扫描开始于一个随机位置(与r有关),如果在扫描过程中发生了</span></span><br><span class="line"><span class="comment">//竞态,则移动到一个随机的位置继续,否则线性地扫描,这个过程持续到在所有相同校验和</span></span><br><span class="line"><span class="comment">//(校验和的计算会采样每个队列的base索引,而base索引会在每次偷的时候移动)的队列上有两次</span></span><br><span class="line"><span class="comment">//连续的空传递,此时worker会尝试对队列进行灭活并重新扫描,如果能找到一个task,则尝试重新</span></span><br><span class="line"><span class="comment">//激活(重新激活可以由别的线程完成),如果找不到task,则返回null用于等待任务.扫描过程应当减少内</span></span><br><span class="line"><span class="comment">//存使用,以及与其他正在扫描的线程的冲突.</span></span><br><span class="line"><span class="comment">//参数w为目标队列,r是前面传递的种子,返回task或null.</span></span><br><span class="line"><span class="keyword">private</span> ForkJoinTask&lt;?&gt; scan(WorkQueue w, <span class="keyword">int</span> r) &#123;</span><br><span class="line">    WorkQueue[] ws; <span class="keyword">int</span> m;</span><br><span class="line">    <span class="comment">//当前工作线程必须是已经完成注册的,即存在工作队列,且r&amp;m能取得它的队列,否则直接返回null.</span></span><br><span class="line">    <span class="keyword">if</span> ((ws = workQueues) != <span class="keyword">null</span> &amp;&amp; (m = ws.length - <span class="number">1</span>) &gt; <span class="number">0</span> &amp;&amp; w != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//1.scan方法是在runWorker的循环中调用的,初次调用时,scanState的值是i(前面说过),是个非负值.</span></span><br><span class="line">        <span class="keyword">int</span> ss = w.scanState;  </span><br><span class="line">        <span class="comment">//scan方法内部开始循环. 用r&amp;m,即w的索引给origin和k,初始化oldSum和checkSum为0.                  </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> origin = r &amp; m, k = origin, oldSum = <span class="number">0</span>, checkSum = <span class="number">0</span>;;) &#123;</span><br><span class="line">            WorkQueue q; ForkJoinTask&lt;?&gt;[] a; ForkJoinTask&lt;?&gt; t;</span><br><span class="line">            <span class="keyword">int</span> b, n; <span class="keyword">long</span> c;</span><br><span class="line">            <span class="comment">//2.选择队列q存在的逻辑.</span></span><br><span class="line">            <span class="keyword">if</span> ((q = ws[k]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//2.1 目标队列q非空(本身base到top间至少存在1个,任务数组非空.</span></span><br><span class="line">                <span class="keyword">if</span> ((n = (b = q.base) - q.top) &lt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">                    (a = q.array) != <span class="keyword">null</span>) &#123; </span><br><span class="line">                    <span class="comment">//计算任务数组的base索引(参考WorkQueue源码).</span></span><br><span class="line">                    <span class="keyword">long</span> i = (((a.length - <span class="number">1</span>) &amp; b) &lt;&lt; ASHIFT) + ABASE;</span><br><span class="line">                    <span class="comment">//2.2数组中取出base对应task存在,base未改变的逻辑.</span></span><br><span class="line">                    <span class="keyword">if</span> ((t = ((ForkJoinTask&lt;?&gt;)</span><br><span class="line">                              U.getObjectVolatile(a, i))) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                        q.base == b) &#123;</span><br><span class="line">                        <span class="comment">//2.3 初始记录的scanState不小于0,代表存活的逻辑.</span></span><br><span class="line">                        <span class="keyword">if</span> (ss &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">//2.4尝试cas掉base处的任务,注意,一定只能从base开始,不会将任务数组中间的元素置空.</span></span><br><span class="line">                            <span class="keyword">if</span> (U.compareAndSwapObject(a, i, t, <span class="keyword">null</span>)) &#123;</span><br><span class="line">                                <span class="comment">//cas成功,更新base.</span></span><br><span class="line">                                q.base = b + <span class="number">1</span>;</span><br><span class="line">                                <span class="keyword">if</span> (n &lt; -<span class="number">1</span>) </span><br><span class="line">                                    <span class="comment">//2.5发现队列q的base到top间不止一个任务元素,则唤醒它可能存在的parker.</span></span><br><span class="line">                                    <span class="comment">//重温一下signalWork的简要逻辑,ctl后32位0且满足加worker条件,tryAddWorker,</span></span><br><span class="line">                                    <span class="comment">//条件不满足(忽略终止等判断逻辑),则计算新的scanState(使用到原ctl的后32位)和ctl(使用原ctl的前32位和q的stackPred),</span></span><br><span class="line">                                    <span class="comment">//在cas为新的ctl成功的前提下,换掉新的scanState.</span></span><br><span class="line">                                    signalWork(ws, q);</span><br><span class="line">                                <span class="comment">//2.6 只要2.4成功,返回弹出的任务.</span></span><br><span class="line">                                <span class="keyword">return</span> t;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//2.7 从scanState看已经是inactive的情况.尝试活化.</span></span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (oldSum == <span class="number">0</span> &amp;&amp;   </span><br><span class="line">                                 w.scanState &lt; <span class="number">0</span>)</span><br><span class="line">                            <span class="comment">//tryRelease前面已介绍过.尝试释放掉栈顶,显然ws[m&amp;(int)c]被视为栈顶,即ctl的后32位(严格来说似乎是后16位)代表栈顶的索引.</span></span><br><span class="line">                            <span class="comment">//释放时对ctl的增量是一个AC_UNIT.</span></span><br><span class="line">                            tryRelease(c = ctl, ws[m &amp; (<span class="keyword">int</span>)c], AC_UNIT);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//2.8 只要没有进入2.4-&gt;2.6,重置origin,k,r,校验和等参数并开启下轮,但整个2工作线用不到,进入3工作线才有用.</span></span><br><span class="line">                    <span class="keyword">if</span> (ss &lt; <span class="number">0</span>)                   <span class="comment">// refresh</span></span><br><span class="line">                        <span class="comment">//可能会有其他抢到同一个队列的worker在2.5/2.7处重活化了scanState,因此当它是inactive的情况,重刷新一次.</span></span><br><span class="line">                        ss = w.scanState;</span><br><span class="line">                    r ^= r &lt;&lt; <span class="number">1</span>; r ^= r &gt;&gt;&gt; <span class="number">3</span>; r ^= r &lt;&lt; <span class="number">10</span>;</span><br><span class="line">                    origin = k = r &amp; m;           <span class="comment">// move and rescan</span></span><br><span class="line">                    oldSum = checkSum = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//2.9校验和增加b</span></span><br><span class="line">                checkSum += b;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//3.持续迭代到稳定的逻辑.</span></span><br><span class="line">            <span class="comment">//这个表达式大概可以理解,线性的增加k,每次加1,直到发现已经从一个origin转满了一圈或n圈.</span></span><br><span class="line">            <span class="keyword">if</span> ((k = (k + <span class="number">1</span>) &amp; m) == origin) &#123;</span><br><span class="line">                <span class="comment">//条件:scanState表示活跃,或者满足当前线程工作队列w的ss未改变,oldSum依旧等于最新的checkSum(校验和未改变)</span></span><br><span class="line">                <span class="keyword">if</span> ((ss &gt;= <span class="number">0</span> || (ss == (ss = w.scanState))) &amp;&amp;</span><br><span class="line">                    oldSum == (oldSum = checkSum)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (ss &lt; <span class="number">0</span> || w.qlock &lt; <span class="number">0</span>)    <span class="comment">// already inactive</span></span><br><span class="line">                    <span class="comment">//3.1满足前面注释的条件,且w已经inactive,终止循环,返回null.</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="comment">//3.2又是这一段计算和替换的逻辑,只不过ns(new scanState)要加上非active标记.</span></span><br><span class="line">                    <span class="keyword">int</span> ns = ss | INACTIVE;       <span class="comment">// try to inactivate</span></span><br><span class="line">                    <span class="comment">//3.3尝试计算用来替换的ctl,它的后32位为ss加上非活跃标记,前32位减去一个活跃数单元.(终于到这了,参考前面分析的ctl前32后32位,验证了)</span></span><br><span class="line">                    <span class="keyword">long</span> nc = ((SP_MASK &amp; ns) |</span><br><span class="line">                               (UC_MASK &amp; ((c = ctl) - AC_UNIT)));</span><br><span class="line">                    <span class="comment">//原来ctl的后32位存给队列的stackPred.</span></span><br><span class="line">                    <span class="comment">//注意,此时w.stackPred和新的ctl的后32位都有一个共性,那就是它们的后31位都可以用来运算并计算得w在ws的索引.</span></span><br><span class="line">                    w.stackPred = (<span class="keyword">int</span>)c;         <span class="comment">// hold prev stack top</span></span><br><span class="line">                    <span class="comment">//3.4先把w的scanState换成ns,再用cas换ctl为nc.</span></span><br><span class="line">                    U.putInt(w, QSCANSTATE, ns);</span><br><span class="line">                    <span class="keyword">if</span> (U.compareAndSwapLong(<span class="keyword">this</span>, CTL, c, nc))</span><br><span class="line">                        <span class="comment">//替换ctl成功,ss直接指向ns,省去一次volatile读.</span></span><br><span class="line">                        ss = ns;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        <span class="comment">//3.5替换失败,再把w的scanState设置回ss.</span></span><br><span class="line">                        w.scanState = ss;         <span class="comment">// back out</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//3.6每发现回了一轮,校验和置0.</span></span><br><span class="line">                checkSum = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="awaitWork"><a href="#awaitWork" class="headerlink" title="awaitWork"></a>awaitWork</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字面意思,等待有工作可做.</span></span><br><span class="line"><span class="comment">//它其实可能会阻塞一个worker偷取任务的过程,如果worker应当关闭则直接返回false.</span></span><br><span class="line"><span class="comment">//如果worker已经处于非活睡在态,且引起了线程池的静寂,则检查线程池的终结态,只要当前worker</span></span><br><span class="line"><span class="comment">//不是唯一一个worker就等待一段时间.如果等待超时后ctl未改变(前32位的数量信息未变,后32位的栈信息也未变),</span></span><br><span class="line"><span class="comment">//则终止当前worker,它可能会唤醒另一个可能重复这个过程的worker</span></span><br><span class="line"><span class="comment">//参数w,调用者worker,r是一个自旋用的随机数种子,如果worker应当关闭,返回false.</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">awaitWork</span><span class="params">(WorkQueue w, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (w == <span class="keyword">null</span> || w.qlock &lt; <span class="number">0</span>)                 <span class="comment">// w is terminating</span></span><br><span class="line">        <span class="comment">//一个线程从注册入池起就有队列,如果它为空或者qlock被置为负(-1),应当终结.</span></span><br><span class="line">        <span class="comment">//前面提过,在deregisterWorker或tryTerminate时会将qlock置-1.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//初始化相关值,保留队列中保存的前一个栈,取出队列的ss,赋值自旋数.SPINS在前面分析</span></span><br><span class="line">    <span class="comment">//运行状态加锁时介绍过,它的值当前就是0,参考awaitRunState方法,在等待runState锁的时候,也可以根据它先自旋.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> pred = w.stackPred, spins = SPINS, ss;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((ss = w.scanState) &gt;= <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//1.队列的scanState大于0,回忆一下,前面介绍tryRelease和signal中计算vs的方法,其中一步是与~INACTIVE,而INACTIVE是1&lt;&lt;31</span></span><br><span class="line">            <span class="comment">//在前面的scan方法中已经遍历一轮且未找到task又未出现竞态未更改校验和的情况,会将scanState加上INACTIVE.</span></span><br><span class="line">            <span class="comment">//因此此处scanState突然不小于0,说明是经历过类似tryRelease或signal的释放唤醒动作,退出循环等待.</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (spins &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//2.当前未被活化,依旧处于INACTIVE态,则首先尝试自旋.使用r这个随机数来决定是否对自旋次数减1.</span></span><br><span class="line">            r ^= r &lt;&lt; <span class="number">6</span>; r ^= r &gt;&gt;&gt; <span class="number">21</span>; r ^= r &lt;&lt; <span class="number">7</span>;</span><br><span class="line">            <span class="keyword">if</span> (r &gt;= <span class="number">0</span> &amp;&amp; --spins == <span class="number">0</span>) &#123;         <span class="comment">// randomize spins</span></span><br><span class="line">                <span class="comment">//2.1自旋次数达到0时做了勾子操作.</span></span><br><span class="line">                WorkQueue v; WorkQueue[] ws; <span class="keyword">int</span> s, j; AtomicLong sc;</span><br><span class="line">                <span class="keyword">if</span> (pred != <span class="number">0</span> &amp;&amp; (ws = workQueues) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                    (j = pred &amp; SMASK) &lt; ws.length &amp;&amp;</span><br><span class="line">                    (v = ws[j]) != <span class="keyword">null</span> &amp;&amp;        <span class="comment">// see if pred parking</span></span><br><span class="line">                    (v.parker == <span class="keyword">null</span> || v.scanState &gt;= <span class="number">0</span>))</span><br><span class="line">                    <span class="comment">//2.2自旋次数降到0时,若满足几个条件:</span></span><br><span class="line">                    <span class="comment">//当前队列保存的栈下一个队列的索引(pred)存在,线程池队列非空,pred未溢出队列数组,</span></span><br><span class="line">                    <span class="comment">//取出pred对应的ws的队列(它其实是当前w在栈向栈底前进一个的元素,它存在说明当前w不是栈底.</span></span><br><span class="line">                    <span class="comment">//如果该元素存在,且它没有阻塞者或它还保持active,则重置自旋次数,继续自旋.</span></span><br><span class="line">                    spins = SPINS;                <span class="comment">// continue spinning</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (w.qlock &lt; <span class="number">0</span>)                     <span class="comment">// recheck after spins</span></span><br><span class="line">            <span class="comment">//3.自旋结束后,再次检查w的队列锁,看它是不是已经被终止了.(deregisterWorker或tryTerminate).</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!Thread.interrupted()) &#123;</span><br><span class="line">            <span class="comment">//4.如果当前线程还未被扰动.</span></span><br><span class="line">            <span class="comment">//目前我们只在一个地方看到过线程扰动的情况:awaitRunStateLock,即当一个线程尝试去修改池的运行时状态,它会去获取一个runState锁,</span></span><br><span class="line">            <span class="comment">//获取失败,发生竞态,也经过自旋等辅助策略无效的阶段,则会尝试使用stealCounter来当作锁加锁,unlock时也会在确认竞态的情况下去用它唤醒.</span></span><br><span class="line">            <span class="comment">//而在awaitRunStateLock中阻塞的线程如果正在进行stealCounter.wait时,wait操作被中断,则会扰动当前线程,这将去除进入此分支的可能.</span></span><br><span class="line">            <span class="comment">//此外,tryTerminate本身也有扰动其他工作线程的步骤.如果用户不在相应的实现代码(如ForkJoinTask的exec函数或CountedCompleter的compute函数)</span></span><br><span class="line">            <span class="comment">//中手动去扰动当前工作线程,可以理解awaitRunStateLock的扰动事件可能与tryTerminate有关.</span></span><br><span class="line">            <span class="keyword">long</span> c, prevctl, parkTime, deadline;</span><br><span class="line">            <span class="comment">//计算新的活跃数,它是原ctl的前16位(负)加上并行度.</span></span><br><span class="line">            <span class="keyword">int</span> ac = (<span class="keyword">int</span>)((c = ctl) &gt;&gt; AC_SHIFT) + (config &amp; SMASK);</span><br><span class="line">            <span class="keyword">if</span> ((ac &lt;= <span class="number">0</span> &amp;&amp; tryTerminate(<span class="keyword">false</span>, <span class="keyword">false</span>)) ||</span><br><span class="line">                (runState &amp; STOP) != <span class="number">0</span>)           <span class="comment">// pool terminating</span></span><br><span class="line">                <span class="comment">//5.发现活跃数已降至0,尝试调用tryTerminate,方法返回true表明已终止或正在终止;或发现runState已经进入终结程序.</span></span><br><span class="line">                <span class="comment">//这两种情况直接返回false,线程执行完毕终止.</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (ac &lt;= <span class="number">0</span> &amp;&amp; ss == (<span class="keyword">int</span>)c) &#123;        <span class="comment">// is last waiter</span></span><br><span class="line">                <span class="comment">//6.前面分析scan方法时讨论过,栈顶元素的scanState体现在ctl的最新后32位,它的stackPred则是ctl之前的后32位值.</span></span><br><span class="line">                <span class="comment">//进入6,说明当前worker是栈顶,即最后一个等待者.</span></span><br><span class="line">                <span class="comment">//用pred计算出之前的ctl.</span></span><br><span class="line">                prevctl = (UC_MASK &amp; (c + AC_UNIT)) | (SP_MASK &amp; pred);</span><br><span class="line">                <span class="comment">//取ctl的17-32位,即worker总数.</span></span><br><span class="line">                <span class="keyword">int</span> t = (<span class="keyword">short</span>)(c &gt;&gt;&gt; TC_SHIFT);  <span class="comment">// shrink excess spares</span></span><br><span class="line">                <span class="keyword">if</span> (t &gt; <span class="number">2</span> &amp;&amp; U.compareAndSwapLong(<span class="keyword">this</span>, CTL, c, prevctl))</span><br><span class="line">                    <span class="comment">//6.1如果发现线程总数大于2,将ctl回滚,返回false让线程终止.</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;                 <span class="comment">// else use timed wait</span></span><br><span class="line">                <span class="comment">//6.2计算deadLine和parkTime,用于后续的定时等待,暂不终结当前线程,而是作为parker.</span></span><br><span class="line">                <span class="comment">//IDLE_TIMEOUT最开始说过,它就是起这个作用的一个时间单位,把gc时间也考虑在内,默认为2秒.</span></span><br><span class="line">                parkTime = IDLE_TIMEOUT * ((t &gt;= <span class="number">0</span>) ? <span class="number">1</span> : <span class="number">1</span> - t);</span><br><span class="line">                deadline = System.nanoTime() + parkTime - TIMEOUT_SLOP;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">//7.存在active的worker或当前w不是栈顶.</span></span><br><span class="line">                prevctl = parkTime = deadline = <span class="number">0L</span>;</span><br><span class="line">            <span class="comment">//8.做线程停段的工作.</span></span><br><span class="line">            Thread wt = Thread.currentThread();</span><br><span class="line">            <span class="comment">//把当前线程池作为parker设置给线程,当使用LockSupport.park时,它将被当作一个参数传递(参考Thread类注释,在java方法签名处看不出来).</span></span><br><span class="line">            U.putObject(wt, PARKBLOCKER, <span class="keyword">this</span>);   <span class="comment">// emulate LockSupport</span></span><br><span class="line">            <span class="comment">//设置parker.</span></span><br><span class="line">            w.parker = wt;</span><br><span class="line">            <span class="keyword">if</span> (w.scanState &lt; <span class="number">0</span> &amp;&amp; ctl == c)      <span class="comment">// recheck before park</span></span><br><span class="line">                <span class="comment">//8.1重新检查非active.合格则停顿.</span></span><br><span class="line">                U.park(<span class="keyword">false</span>, parkTime);</span><br><span class="line">            <span class="comment">//归置.</span></span><br><span class="line">            U.putOrderedObject(w, QPARKER, <span class="keyword">null</span>);</span><br><span class="line">            U.putObject(wt, PARKBLOCKER, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (w.scanState &gt;= <span class="number">0</span>)</span><br><span class="line">                <span class="comment">//8.2停顿(或未停顿)重检查发现w被重新active,则退出循环返回true(非false代表不能终结当前线程).</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (parkTime != <span class="number">0L</span> &amp;&amp; ctl == c &amp;&amp;</span><br><span class="line">                deadline - System.nanoTime() &lt;= <span class="number">0L</span> &amp;&amp;</span><br><span class="line">                U.compareAndSwapLong(<span class="keyword">this</span>, CTL, c, prevctl))</span><br><span class="line">                <span class="comment">//8.3发现没有时间了,ctl也未在等待的时间发生变化,将ctl设置为w入栈前的结果,返回false让终结此线程(类似出栈).</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;                     <span class="comment">// shrink pool</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="helpComplete"><a href="#helpComplete" class="headerlink" title="helpComplete"></a>helpComplete</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//帮助完成,调用者可以是一个池中的工作线程,也可以是池外的.在JDK8版本中,有三处调用:</span></span><br><span class="line"><span class="comment">//1.CountedCompleter::helpComplete,该方法的调用由我们决定.</span></span><br><span class="line"><span class="comment">//2.ForkJoinPool::awaitJoin,等待结果的同时可以尝试帮助完成,只由池中线程调用,传入的队列是该线程的队列.该方法由ForkJoinTask的join/invoke/get调用.</span></span><br><span class="line"><span class="comment">//3.ForkJoinPool::externalHelpComplete,用于外部线程操作,前面在CountedCompleter的文章已粗略介绍,传入的w为ws中用一个随机数与n-1和0x007e取与运算</span></span><br><span class="line"><span class="comment">//的结果,很明显,即使w不是null,也只能是一个偶数位的元素,这意味着w不会是registerWoker时生成的带有工作线程的WorkQueue.也就是不能帮助池中线程完成自己的队列.</span></span><br><span class="line"><span class="comment">//本方法会尝试从当前的计算目标之内偷取一个任务,它使用顶层算法的变种,限制偷出来的任务必须是给定任务的后代,但是也有一些细节要注意.</span></span><br><span class="line"><span class="comment">//首先,它会尝试从自己的工作队列中找合格的任务(用前面讲过的WorkQueue::popCC),若不能找到则扫描其他队列,当发生竞态时随机移动指针,依照校验和机制决定是否放弃</span></span><br><span class="line"><span class="comment">//帮助执行(这取决于前面介绍的pollAndExecCC的返回码).参数maxTasks是对外部使用的支持参数,内部调用它会传入0,允许无界的次数(外部调用时,捕获非法的非正数).</span></span><br><span class="line"><span class="comment">//参数w,队列,在内部调用的情况下可以理解为当前线程的工作队列,参数maxTasks如果非0,指代最大的可运行的其他任务.退出时方法返回任务状态.</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">helpComplete</span><span class="params">(WorkQueue w, CountedCompleter&lt;?&gt; task,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">int</span> maxTasks)</span> </span>&#123;</span><br><span class="line">    WorkQueue[] ws; <span class="keyword">int</span> s = <span class="number">0</span>, m;</span><br><span class="line">    <span class="comment">//变量初始化和验证,队列和参数w必须非空才能进入if.</span></span><br><span class="line">    <span class="keyword">if</span> ((ws = workQueues) != <span class="keyword">null</span> &amp;&amp; (m = ws.length - <span class="number">1</span>) &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">        task != <span class="keyword">null</span> &amp;&amp; w != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//介绍popCC时曾专门强调过这个mode其实是config.</span></span><br><span class="line">        <span class="keyword">int</span> mode = w.config;                 <span class="comment">// for popCC</span></span><br><span class="line">        <span class="keyword">int</span> r = w.hint ^ w.top;              <span class="comment">// arbitrary seed for origin</span></span><br><span class="line">        <span class="keyword">int</span> origin = r &amp; m;                  <span class="comment">// first queue to scan</span></span><br><span class="line">        <span class="comment">//初始时赋h为1,在每一轮循环中,它取1代表正在正常运行,大于1代表发生了竞态,小于0将增加到校验和,代表pollAndExecCC达到了根元素.</span></span><br><span class="line">        <span class="comment">//详细参考前面论述过的pollAndExecCC.</span></span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">1</span>;                           <span class="comment">// 1:ran, &gt;1:contended, &lt;0:hash</span></span><br><span class="line">        <span class="comment">//初始化条件循环条件,记录origin的值,初始化oldSum和checkSum</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = origin, oldSum = <span class="number">0</span>, checkSum = <span class="number">0</span>;;) &#123;</span><br><span class="line">            CountedCompleter&lt;?&gt; p; WorkQueue q;</span><br><span class="line">            <span class="comment">//1.传入的任务已经是完成的,break返回s(负).</span></span><br><span class="line">            <span class="keyword">if</span> ((s = task.status) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//2.h未经过更改或经历过若干次更改,但在上一轮循环代表了pollAndExecCC成功执行task(h取1),则</span></span><br><span class="line">            <span class="comment">//在当轮循环尝试对w进行popCC,并根据mode决定从base还是top出队.</span></span><br><span class="line">            <span class="keyword">if</span> (h == <span class="number">1</span> &amp;&amp; (p = w.popCC(task, mode)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//2.1本队列有满足条件的任务,执行之.</span></span><br><span class="line">                p.doExec();                  <span class="comment">// run local task</span></span><br><span class="line">                <span class="keyword">if</span> (maxTasks != <span class="number">0</span> &amp;&amp; --maxTasks == <span class="number">0</span>)</span><br><span class="line">                    <span class="comment">//减少maxTask并在它降到0时break.(前提是传入了正数的maxTasks).</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">//2.2没降到0,把origin和校验和参数重设为循环初始化的值.</span></span><br><span class="line">                origin = k;                  <span class="comment">// reset</span></span><br><span class="line">                oldSum = checkSum = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//3.某轮循环h代表出现竞态等问题或不能使用popCC方式从本地队列出任务执行.尝试从其他队列poll执行.</span></span><br><span class="line">            <span class="keyword">else</span> &#123;                           <span class="comment">// poll other queues</span></span><br><span class="line">                <span class="comment">//3.1 找不出任务,h置0,这将使它在随后的循环中不会再进入2</span></span><br><span class="line">                <span class="keyword">if</span> ((q = ws[k]) == <span class="keyword">null</span>)</span><br><span class="line">                    h = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">//3.2尝试从q的base处poll并执行task.返回-1代表不匹配,对校验和增加h(负数).</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((h = q.pollAndExecCC(task)) &lt; <span class="number">0</span>)</span><br><span class="line">                    checkSum += h;</span><br><span class="line">                <span class="comment">//3.3 h大于0,可能是等于1但popCC未成功的情况.也可能是pollAndExecCC成功了一次或cas失败.</span></span><br><span class="line">                <span class="keyword">if</span> (h &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (h == <span class="number">1</span> &amp;&amp; maxTasks != <span class="number">0</span> &amp;&amp; --maxTasks == <span class="number">0</span>)</span><br><span class="line">                        <span class="comment">//h是1减maxTask,当它达到0终止循环.(前提是没传了正数的maxTasks)</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="comment">//h不等于1,一般是poll时cas失败,重置r,origin,checkSum等,开下一轮循环.</span></span><br><span class="line">                    r ^= r &lt;&lt; <span class="number">13</span>; r ^= r &gt;&gt;&gt; <span class="number">17</span>; r ^= r &lt;&lt; <span class="number">5</span>; <span class="comment">// xorshift</span></span><br><span class="line">                    origin = k = r &amp; m;      <span class="comment">// move and restart</span></span><br><span class="line">                    oldSum = checkSum = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//3.4前面见过类似的代码,发现已经转完了一轮,校验和未改变过(任何一个队列都未进3.2/3.3,也就是查找任何一个下标ws[k]都是null),break.</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((k = (k + <span class="number">1</span>) &amp; m) == origin) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (oldSum == (oldSum = checkSum))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="comment">//发现校验和有变更,说明有一轮循环未进入3.1,再次循环.</span></span><br><span class="line">                    checkSum = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返架退出循环是task的status.</span></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="helpStealer"><a href="#helpStealer" class="headerlink" title="helpStealer"></a>helpStealer</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字面意思:尝试帮助一个"小偷".</span></span><br><span class="line"><span class="comment">//本方法会尝试定位到task的偷盗者,并尝试执行偷盗者(可能偷盗者的偷盗者)的任务.它会追踪currentSteal(前面runTask时提过,会将参数task置为currentSteal)-&gt;</span></span><br><span class="line"><span class="comment">//currentJoin(当前队列等待的任务,后面会介绍awaitJoin方法),这样追寻一个线程在给定的task的后续工作,它会使用非空队列偷回和执行任务.方法的第一次从等待join调用</span></span><br><span class="line"><span class="comment">//通常意味着scan搜索,因为joiner没有什么更适合做的,这种做法也是ok的.本方法会在worker中留下hint标识来加速后续的调用.</span></span><br><span class="line"><span class="comment">//参数w代表caller的队列,task是要join的任务.</span></span><br><span class="line"><span class="comment">//方法共分三层循环,最外层是一个do-while循环,其内是两个for循环.</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helpStealer</span><span class="params">(WorkQueue w, ForkJoinTask&lt;?&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//初始化和进入if的条件,没什么可说的.</span></span><br><span class="line">    WorkQueue[] ws = workQueues;</span><br><span class="line">    <span class="keyword">int</span> oldSum = <span class="number">0</span>, checkSum, m;</span><br><span class="line">    <span class="keyword">if</span> (ws != <span class="keyword">null</span> &amp;&amp; (m = ws.length - <span class="number">1</span>) &gt;= <span class="number">0</span> &amp;&amp; w != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">        task != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//循环一:方法最外层的while循环.它的条件是task未完成且校验和未发生变化.</span></span><br><span class="line">        <span class="keyword">do</span> &#123;                                       <span class="comment">// restart point</span></span><br><span class="line">            <span class="comment">//每次循环一的起点,校验和重置为0.用j保存w.</span></span><br><span class="line">            checkSum = <span class="number">0</span>;                          <span class="comment">// for stability check</span></span><br><span class="line">            ForkJoinTask&lt;?&gt; subtask;</span><br><span class="line">            WorkQueue j = w, v;                    <span class="comment">// v is subtask stealer</span></span><br><span class="line">            <span class="comment">//循环二:外部for循环,subtask初始指向参数task,循环条件是subtask未完成.</span></span><br><span class="line">            <span class="comment">//在每次循环四中会校验当前小偷的队列是否空了,如果空了则换它的小偷继续偷(交给subtask指向).</span></span><br><span class="line">            descent: <span class="keyword">for</span> (subtask = task; subtask.status &gt;= <span class="number">0</span>; ) &#123;</span><br><span class="line">                <span class="comment">//循环三:内部第一个for循环,初始化变量h,用hint加上奇数位,保证从奇数索引取队列.k初始为0,每次循环结束加2.</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> h = j.hint | <span class="number">1</span>, k = <span class="number">0</span>, i; ; k += <span class="number">2</span>) &#123;</span><br><span class="line">                    <span class="comment">//1.循环三内的逻辑.</span></span><br><span class="line">                    <span class="comment">//1.1发现k已经递增到大于最大索引m了,直接终止循环二,若发现task还未完成,校验和也未更改,则进行上面的重置操作并重新开始循环二.</span></span><br><span class="line">                    <span class="keyword">if</span> (k &gt; m)                     <span class="comment">// can't find stealer</span></span><br><span class="line">                        <span class="keyword">break</span> descent;</span><br><span class="line">                    <span class="comment">//1.2i位置标记为h+k的结果与运算m,因为k每次增2,h又是奇数,故保证只取有线程主的队列.</span></span><br><span class="line">                    <span class="keyword">if</span> ((v = ws[i = (h + k) &amp; m]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (v.currentSteal == subtask) &#123;</span><br><span class="line">                            <span class="comment">//发现偷取currentSteal的worker v,将它的索引i交给j(初始为w,在2内会更改为"等待队列"的元素,在while循环中会重置为w)的hint,</span></span><br><span class="line">                            <span class="comment">//方便下一次再进入循环三时的查找.并终止循环三,进入循环四的判断入口.</span></span><br><span class="line">                            j.hint = i;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//1.3存在非空v,但是v未偷取subtask,将v的base加给校验和.这将影响到循环一的判真条件.显然从循环三退出循环二,或后续循环四退出循环二</span></span><br><span class="line">                        <span class="comment">//将导致循环一也一并因while条件不满而退出.</span></span><br><span class="line">                        checkSum += v.base;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//循环四:迭代subtask的循环,它必须经循环三中的1.2走出.</span></span><br><span class="line">                <span class="comment">//2.到达循环四,一定已经在循环三中找到了一个v,此处会尝试帮助v或者它的产生的"后裔".</span></span><br><span class="line">                <span class="keyword">for</span> (;;) &#123;                         <span class="comment">// help v or descend</span></span><br><span class="line">                    ForkJoinTask&lt;?&gt;[] a; <span class="keyword">int</span> b;</span><br><span class="line">                    <span class="comment">//2.1类似1.3的逻辑,校验和增加v.base,初始化next,增加校验和意味着,只要从循环四退出了循环二,则最外的循环一的while条件将不满足.</span></span><br><span class="line">                    checkSum += (b = v.base);</span><br><span class="line">                    <span class="comment">//next取v的currentJoin.</span></span><br><span class="line">                    ForkJoinTask&lt;?&gt; next = v.currentJoin;</span><br><span class="line">                    <span class="keyword">if</span> (subtask.status &lt; <span class="number">0</span> || j.currentJoin != subtask ||</span><br><span class="line">                        v.currentSteal != subtask) <span class="comment">// stale</span></span><br><span class="line">                        <span class="comment">//2.2如果subtask已是完成态,或发现竞态等情况造成数据已脏,如发现本轮循环中j的当前join已不是当前subtask,</span></span><br><span class="line">                        <span class="comment">//或v的当前steal不是subtask,说明出现了脏数据,直接终止循环二,重新进入while循环重初始化jv.</span></span><br><span class="line">                        <span class="keyword">break</span> descent;</span><br><span class="line">                    <span class="comment">//2.3发现队列v已空的逻辑.</span></span><br><span class="line">                    <span class="keyword">if</span> (b - v.top &gt;= <span class="number">0</span> || (a = v.array) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> ((subtask = next) == <span class="keyword">null</span>)</span><br><span class="line">                            <span class="comment">//2.3.1 v已空,且不存在next,即"等待队列"已空,退出循环二,重新while判定循环条件,重初始化jv.</span></span><br><span class="line">                            <span class="keyword">break</span> descent;</span><br><span class="line">                        <span class="comment">//2.3.2 还有next,将subtask指向next的同时,用v替换掉j.这是明显的迭代语句.</span></span><br><span class="line">                        <span class="comment">//在前面的代码中可以看出,循环一就是为subtask找出小偷v的,关系是v.currentSteal=subtask.同时j.currentJoin=subtask.</span></span><br><span class="line">                        <span class="comment">//因为next=v.currentJoin,将v赋给j后,仍旧满足j.currentJoin=next=subtask,此时break掉循环四,重新开启循环二的新一轮</span></span><br><span class="line">                        <span class="comment">//正好对v进行重新初始化,而找到v的条件又是v.currentSteal=subtask,也即等于j.currentJoin.</span></span><br><span class="line">                        <span class="comment">//此处break掉的循环四将导致循环二的下轮将在循环三处重新为新的j找到v(v.currentSteal==subtask).</span></span><br><span class="line">                        j = v;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//2.4未进入2.3.1/2.3.2的情况,显然进入这两者会break到循环一或二.</span></span><br><span class="line">                    <span class="comment">//取出base索引位置i和相应的任务元素.</span></span><br><span class="line">                    <span class="keyword">int</span> i = (((a.length - <span class="number">1</span>) &amp; b) &lt;&lt; ASHIFT) + ABASE;</span><br><span class="line">                    ForkJoinTask&lt;?&gt; t = ((ForkJoinTask&lt;?&gt;)</span><br><span class="line">                                         U.getObjectVolatile(a, i));</span><br><span class="line">                    <span class="comment">//2.5,接2.4,判断竞态,v.base!=b说明已经被别的线程将base元素出队.这种情况下直接进入下一轮的循环二.</span></span><br><span class="line">                    <span class="keyword">if</span> (v.base == b) &#123;</span><br><span class="line">                        <span class="comment">//2.5.1 取出任务t,发现空为脏数据,从while循环重新初始化.</span></span><br><span class="line">                        <span class="keyword">if</span> (t == <span class="keyword">null</span>)             <span class="comment">// stale</span></span><br><span class="line">                            <span class="keyword">break</span> descent;</span><br><span class="line">                        <span class="comment">//2.5.2,将t出队并进行后续流程.</span></span><br><span class="line">                        <span class="keyword">if</span> (U.compareAndSwapObject(a, i, t, <span class="keyword">null</span>)) &#123;</span><br><span class="line">                            <span class="comment">//2.5.3首先将v的base增1.</span></span><br><span class="line">                            v.base = b + <span class="number">1</span>;</span><br><span class="line">                            <span class="comment">//2.5.4取出w(方法参数,当前worker)的currentSteal保存到ps.</span></span><br><span class="line">                            ForkJoinTask&lt;?&gt; ps = w.currentSteal;</span><br><span class="line">                            <span class="keyword">int</span> top = w.top;</span><br><span class="line">                            <span class="keyword">do</span> &#123;</span><br><span class="line">                                <span class="comment">//2.5.5此循环不和循环一至四一块罗列,因为它本质上只是任务的出队与执行.</span></span><br><span class="line">                                <span class="comment">//首先会尝试将w队列的currentSteal置为刚刚从v的任务数组中出队的t</span></span><br><span class="line">                                U.putOrderedObject(w, QCURRENTSTEAL, t);</span><br><span class="line">                                <span class="comment">//执行t.执行后顺带循环处理自己刚压入队列w的任务.执行后,也跳出当前while循环的情况下会在下次重新判断2.3,</span></span><br><span class="line">                                <span class="comment">//非空继续找base(i),为空则迭代v为next(2.3.2).</span></span><br><span class="line">                                t.doExec();        <span class="comment">// clear local tasks too</span></span><br><span class="line">                            <span class="comment">//2.5.6循环条件,只要参数task还未完成,w新压入了任务,则依次尝试从w中pop元素,和前面的t一样按序执行(此处顺带执行自己的任务).</span></span><br><span class="line">                            &#125; <span class="keyword">while</span> (task.status &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">                                     w.top != top &amp;&amp;</span><br><span class="line">                                     (t = w.pop()) != <span class="keyword">null</span>);</span><br><span class="line">                            <span class="comment">//2.5.7偷了小偷v的base任务并执行成功,则恢复w的currentSteal.</span></span><br><span class="line">                            U.putOrderedObject(w, QCURRENTSTEAL, ps);</span><br><span class="line">                            <span class="keyword">if</span> (w.base != w.top)</span><br><span class="line">                                <span class="comment">//2.5.8偷完并执行完当前v的base任务或者某一轮的等待队列上的元素v的base任务后,发现自己的队列非空了,就不再帮助对方,方法return.</span></span><br><span class="line">                                <span class="comment">//可以参考awaitJoin方法,因为helpStealer只在awaitJoin中调用,调用的前提就是w.base==w.top.</span></span><br><span class="line">                                <span class="comment">//这显然与2.5.6有所纠结(尽管一个判断top,一个判断top和base的相等),只要到了2.5.8,队列非空将返回.</span></span><br><span class="line">                                <span class="keyword">return</span>;            <span class="comment">// can't further help</span></span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//出队失败同2.5.1一样,竞态失败重新循环二,但在下一轮循环中会在2.5.1break回while循环.</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">//最外层的while循环条件,task未完成,校验和未发生更改.</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (task.status &gt;= <span class="number">0</span> &amp;&amp; oldSum != (oldSum = checkSum));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="tryCompensate"><a href="#tryCompensate" class="headerlink" title="tryCompensate"></a>tryCompensate</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字面意思:尝试补偿.</span></span><br><span class="line"><span class="comment">//方法会尝试减少活跃数(有时是隐式的)并可能会因阻塞释放或创建一个补偿worker.</span></span><br><span class="line"><span class="comment">//在出现竞态,发现脏数据,不稳定,终止的情况下返回false,并可重试.参数w代表调用者.</span></span><br><span class="line"><span class="comment">//方法实现比较简单,为简单的if else模式,只有一个分支可以执行.</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">tryCompensate</span><span class="params">(WorkQueue w)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//canBlock为返回值.</span></span><br><span class="line">    <span class="keyword">boolean</span> canBlock;</span><br><span class="line">    WorkQueue[] ws; <span class="keyword">long</span> c; <span class="keyword">int</span> m, pc, sp;</span><br><span class="line">    <span class="comment">//1.发现调用者终止了,线程池队列数组为空,或者禁用了并行度,则返回false.</span></span><br><span class="line">    <span class="keyword">if</span> (w == <span class="keyword">null</span> || w.qlock &lt; <span class="number">0</span> ||           <span class="comment">// caller terminating</span></span><br><span class="line">        (ws = workQueues) == <span class="keyword">null</span> || (m = ws.length - <span class="number">1</span>) &lt;= <span class="number">0</span> ||</span><br><span class="line">        (pc = config &amp; SMASK) == <span class="number">0</span>)           <span class="comment">// parallelism disabled</span></span><br><span class="line">        canBlock = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//2.发现当前ctl表示有worker正等待任务(空闲,位于scan),则尝试释放它,让它回来工作.</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((sp = (<span class="keyword">int</span>)(c = ctl)) != <span class="number">0</span>)      <span class="comment">// release idle worker</span></span><br><span class="line">        canBlock = tryRelease(c, ws[sp &amp; m], <span class="number">0L</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//3.当前所有worker都在忙碌.</span></span><br><span class="line">        <span class="comment">//3.1计算活跃数,总数,计算方法前面已经论述多次.</span></span><br><span class="line">        <span class="keyword">int</span> ac = (<span class="keyword">int</span>)(c &gt;&gt; AC_SHIFT) + pc;</span><br><span class="line">        <span class="keyword">int</span> tc = (<span class="keyword">short</span>)(c &gt;&gt; TC_SHIFT) + pc;</span><br><span class="line">        <span class="comment">//记录nbusy,注释表示用于验证饱合度.</span></span><br><span class="line">        <span class="keyword">int</span> nbusy = <span class="number">0</span>;                        <span class="comment">// validate saturation</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; ++i) &#123;        <span class="comment">// two passes of odd indices</span></span><br><span class="line">            WorkQueue v;</span><br><span class="line">            <span class="comment">//3.2nbusy的计算方法,遍历线程池的队列数组(每次增1),验证则以1-3-5这个顺序开始,发现有处于SCANNING态的,就停掉循环,否则加1.</span></span><br><span class="line">            <span class="keyword">if</span> ((v = ws[((i &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>) &amp; m]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((v.scanState &amp; SCANNING) != <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                ++nbusy;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.3如果非稳态(饱合度不是tc的2倍),或者ctl脏读,则返回false.</span></span><br><span class="line">        <span class="keyword">if</span> (nbusy != (tc &lt;&lt; <span class="number">1</span>) || ctl != c)</span><br><span class="line">            canBlock = <span class="keyword">false</span>;                 <span class="comment">// unstable or stale</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (tc &gt;= pc &amp;&amp; ac &gt; <span class="number">1</span> &amp;&amp; w.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">//3.4处于稳态且ctl还有效,总worker数大于并行度且活跃数大于1而且当前w又是空的.尝试将ctl减去一个活跃位.</span></span><br><span class="line">            <span class="keyword">long</span> nc = ((AC_MASK &amp; (c - AC_UNIT)) |</span><br><span class="line">                       (~AC_MASK &amp; c));       <span class="comment">// uncompensated 反补偿,初看莫名其妙,调用者会在之后增加ac.</span></span><br><span class="line">            <span class="comment">//返回值为cas是否成功.</span></span><br><span class="line">            canBlock = U.compareAndSwapLong(<span class="keyword">this</span>, CTL, c, nc);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (tc &gt;= MAX_CAP ||</span><br><span class="line">                 (<span class="keyword">this</span> == common &amp;&amp; tc &gt;= pc + commonMaxSpares))</span><br><span class="line">            <span class="comment">//3.5普通ForkJoinPool,总worker数达到MAX_CAP,或common池,总worker数量达到并行度+commonMaxSpares(默认256),抛出拒绝异常.</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(</span><br><span class="line">                <span class="string">"Thread limit exceeded replacing blocked worker"</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;                                <span class="comment">// similar to tryAddWorker</span></span><br><span class="line">            <span class="keyword">boolean</span> add = <span class="keyword">false</span>; <span class="keyword">int</span> rs;      <span class="comment">// CAS within lock</span></span><br><span class="line">            <span class="comment">//3.6.计算新的ctl,增加一个总worker数.</span></span><br><span class="line">            <span class="keyword">long</span> nc = ((AC_MASK &amp; c) |</span><br><span class="line">                       (TC_MASK &amp; (c + TC_UNIT)));</span><br><span class="line">            <span class="comment">//加运行状态锁,池未进入终止态的情况下,进行cas,随后解锁.</span></span><br><span class="line">            <span class="keyword">if</span> (((rs = lockRunState()) &amp; STOP) == <span class="number">0</span>)</span><br><span class="line">                add = U.compareAndSwapLong(<span class="keyword">this</span>, CTL, c, nc);</span><br><span class="line">            unlockRunState(rs, rs &amp; ~RSLOCK);</span><br><span class="line">            <span class="comment">//cas成功,则创建worker</span></span><br><span class="line">            canBlock = add &amp;&amp; createWorker(); <span class="comment">// throws on exception</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> canBlock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="awaitJoin"><a href="#awaitJoin" class="headerlink" title="awaitJoin"></a>awaitJoin</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前面提过它很多次了,awaitJoin方法会在指定任务完成或者超时前尝试帮助或阻塞自身.</span></span><br><span class="line"><span class="comment">//参数w代表调用者,task为目标任务,参数deadline是超时目标(非0).它会返回退出时的任务状态.</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">awaitJoin</span><span class="params">(WorkQueue w, ForkJoinTask&lt;?&gt; task, <span class="keyword">long</span> deadline)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//返回值.</span></span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (task != <span class="keyword">null</span> &amp;&amp; w != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//1.若未进入if必然返回0,进入条件是提供了task和w.</span></span><br><span class="line">        <span class="comment">//保存currentJoin</span></span><br><span class="line">        ForkJoinTask&lt;?&gt; prevJoin = w.currentJoin;</span><br><span class="line">        <span class="comment">//将w的currentJoin暂时设置为task.</span></span><br><span class="line">        U.putOrderedObject(w, QCURRENTJOIN, task);</span><br><span class="line">        <span class="comment">//如果task是CountedCompleter类型,转化并存放到cc.</span></span><br><span class="line">        CountedCompleter&lt;?&gt; cc = (task <span class="keyword">instanceof</span> CountedCompleter) ?</span><br><span class="line">            (CountedCompleter&lt;?&gt;)task : <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//2.循环.</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((s = task.status) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="comment">//2.1目标task已完成,返回task的status.</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (cc != <span class="keyword">null</span>)</span><br><span class="line">                <span class="comment">//2.2目标task是CountedCompleter,调用前面介绍过的helpComplete方法,maxTasks不限(0).</span></span><br><span class="line">                helpComplete(w, cc, <span class="number">0</span>);</span><br><span class="line">            <span class="comment">//2.3否则发现队列w已空,或者非空,则尝试从w中移除并执行task,若出现队列w是空且任务不知道是否完成的情况(t.doExec只是执行,不等结果),</span></span><br><span class="line">            <span class="comment">//此处也会拿到一个true,则调用前面介绍过的helpStealer去帮助小偷.</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (w.base == w.top || w.tryRemoveAndExec(task))</span><br><span class="line">                helpStealer(w, task);</span><br><span class="line">            <span class="comment">//2.4.帮助需要时间,double check,同2.1.</span></span><br><span class="line">            <span class="keyword">if</span> ((s = task.status) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//2.5计算deadline有关的停顿时间ms.</span></span><br><span class="line">            <span class="keyword">long</span> ms, ns;</span><br><span class="line">            <span class="keyword">if</span> (deadline == <span class="number">0L</span>)</span><br><span class="line">                ms = <span class="number">0L</span>;<span class="comment">//未指定deadline,ms为0</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((ns = deadline - System.nanoTime()) &lt;= <span class="number">0L</span>)</span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">//要指定的deadline已经早于当前时间了,break返回上面的status</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((ms = TimeUnit.NANOSECONDS.toMillis(ns)) &lt;= <span class="number">0L</span>)</span><br><span class="line">                ms = <span class="number">1L</span>;<span class="comment">//用上面的ns计算ms发现负数,重置ms为1</span></span><br><span class="line">            <span class="comment">//2.6,调用上面提到过的tryCompensate方法,传入当前worker,如果得到true的返回值,等待超时,</span></span><br><span class="line">            <span class="comment">//超时结束增加一个活跃位(前面提到tryCompensate方法最后加增加tc并创建worker,不增加ac,或者莫名其妙地减去了一个ac).</span></span><br><span class="line">            <span class="keyword">if</span> (tryCompensate(w)) &#123;</span><br><span class="line">                task.internalWait(ms);</span><br><span class="line">                U.getAndAddLong(<span class="keyword">this</span>, CTL, AC_UNIT);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.最后恢复原来的currentJoin.</span></span><br><span class="line">        U.putOrderedObject(w, QCURRENTJOIN, prevJoin);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="findNonEmptyStealQueue"><a href="#findNonEmptyStealQueue" class="headerlink" title="findNonEmptyStealQueue"></a>findNonEmptyStealQueue</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//简单的方法,尝试找一个非空的偷盗队列.使用类似简化的scan的方式查取,可能返回null.</span></span><br><span class="line"><span class="comment">//如果调用者想要尝试使用队列,必须在得到空后多次尝试.</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> WorkQueue <span class="title">findNonEmptyStealQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    WorkQueue[] ws; <span class="keyword">int</span> m;  </span><br><span class="line">    <span class="comment">//随机数r</span></span><br><span class="line">    <span class="keyword">int</span> r = ThreadLocalRandom.nextSecondarySeed();</span><br><span class="line">    <span class="comment">//线程池不具备队列,直接返回null.</span></span><br><span class="line">    <span class="keyword">if</span> ((ws = workQueues) != <span class="keyword">null</span> &amp;&amp; (m = ws.length - <span class="number">1</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//循环开始.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> origin = r &amp; m, k = origin, oldSum = <span class="number">0</span>, checkSum = <span class="number">0</span>;;) &#123;</span><br><span class="line">            WorkQueue q; <span class="keyword">int</span> b;</span><br><span class="line">            <span class="keyword">if</span> ((q = ws[k]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((b = q.base) - q.top &lt; <span class="number">0</span>)</span><br><span class="line">                    <span class="comment">//查到q这个WorkQueue,并且q非空,则将q返回.</span></span><br><span class="line">                    <span class="keyword">return</span> q;</span><br><span class="line">                <span class="comment">//查到了空队列q,则校验和加上q的base.</span></span><br><span class="line">                checkSum += b;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//前面多次见过的判断进入第二轮的办法.发现ws从头到尾都是null则break返回null,否则出现非null的空队列则将校验和置0继续循环.</span></span><br><span class="line">            <span class="keyword">if</span> ((k = (k + <span class="number">1</span>) &amp; m) == origin) &#123;</span><br><span class="line">                <span class="keyword">if</span> (oldSum == (oldSum = checkSum))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                checkSum = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="helpQuiescePool"><a href="#helpQuiescePool" class="headerlink" title="helpQuiescePool"></a>helpQuiescePool</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//运行任务,直到isQuiescent,本方法顺带维护ctl中的活跃数,但是全过程不会在任务不能找到的情况下</span></span><br><span class="line"><span class="comment">//进行阻塞,而是进行重新扫描,直到所有其他worker的队列中都不能找出任务为止.</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">helpQuiescePool</span><span class="params">(WorkQueue w)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//保存当前偷取的任务.</span></span><br><span class="line">    ForkJoinTask&lt;?&gt; ps = w.currentSteal; <span class="comment">// save context</span></span><br><span class="line">    <span class="comment">//循环开始,active置true.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">boolean</span> active = <span class="keyword">true</span>;;) &#123;</span><br><span class="line">        <span class="keyword">long</span> c; WorkQueue q; ForkJoinTask&lt;?&gt; t; <span class="keyword">int</span> b;</span><br><span class="line">        <span class="comment">//1.先把本地任务执行完毕(每次循环扫描).</span></span><br><span class="line">        w.execLocalTasks();   </span><br><span class="line">        <span class="comment">//2.查找到非空队列的情况,除了2以外的34在cas成功的情况下都会终止循环.</span></span><br><span class="line">        <span class="keyword">if</span> ((q = findNonEmptyStealQueue()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//2.1经过3中成功减少了活跃数的情况,下一次循环又扫描到了新的非空队列,需要重激活.</span></span><br><span class="line">            <span class="keyword">if</span> (!active) &#123;      </span><br><span class="line">                active = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">//活跃数重新加1.</span></span><br><span class="line">                U.getAndAddLong(<span class="keyword">this</span>, CTL, AC_UNIT);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//2.2再次判断队列非空,并从队列内部数组的base起取出task</span></span><br><span class="line">            <span class="keyword">if</span> ((b = q.base) - q.top &lt; <span class="number">0</span> &amp;&amp; (t = q.pollAt(b)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//将task置于currentSteal</span></span><br><span class="line">                U.putOrderedObject(w, QCURRENTSTEAL, t);</span><br><span class="line">                <span class="comment">//执行task</span></span><br><span class="line">                t.doExec();</span><br><span class="line">                <span class="comment">//如果w的偷取任务数溢出,转到池中.</span></span><br><span class="line">                <span class="keyword">if</span> (++w.nsteals &lt; <span class="number">0</span>)</span><br><span class="line">                    w.transferStealCount(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.仍旧保持active的情况.</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (active) &#123; </span><br><span class="line">            <span class="comment">//3.1能进到这里,肯定本轮循环未能进入2,说明未能发现非空队列,计算新的ctl即nc,它是原ctl减去一个活跃单位.  </span></span><br><span class="line">            <span class="keyword">long</span> nc = (AC_MASK &amp; ((c = ctl) - AC_UNIT)) | (~AC_MASK &amp; c);</span><br><span class="line">            <span class="keyword">if</span> ((<span class="keyword">int</span>)(nc &gt;&gt; AC_SHIFT) + (config &amp; SMASK) &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="comment">//3.2新的活跃数加上并行度还不大于0,即不能溢出,说明没有活跃数,不进行cas了,直接break.</span></span><br><span class="line">                <span class="comment">//很明显,上面计算nc的方法,首先ctl正常本身是负,若上面表达式为正,唯一的解释是线程池有活跃线程(前面讲过,活跃一个加一个活跃单元,直到并行度为止)</span></span><br><span class="line">                <span class="comment">//因为两个表达式分别是前16位(在前面再补上16个1)和后16位求和.</span></span><br><span class="line">                <span class="keyword">break</span>;  </span><br><span class="line">            <span class="comment">//3.3未能从3.2退出,说明nc表示当前有活跃数存在,进行cas,成功后active置false,不退出循环.</span></span><br><span class="line">            <span class="comment">//若下轮循环发现新的非空队列,会在2.1处增加回来.若未能发现,会在4处加回来.       </span></span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapLong(<span class="keyword">this</span>, CTL, c, nc))</span><br><span class="line">                active = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4.前一轮循环进了3.3,当前循环未能进入2.1的情况,判断当前ctl活跃数加上并行度是非正,说明再创建并行度个数的worker也不能溢出.则再加回一个活跃数.</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="keyword">int</span>)((c = ctl) &gt;&gt; AC_SHIFT) + (config &amp; SMASK) &lt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">                 U.compareAndSwapLong(<span class="keyword">this</span>, CTL, c, c + AC_UNIT))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//5.重新恢复currentSteal</span></span><br><span class="line">    U.putOrderedObject(w, QCURRENTSTEAL, ps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="nextTaskFor"><a href="#nextTaskFor" class="headerlink" title="nextTaskFor"></a>nextTaskFor</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取并移除一个本地或偷来的任务.</span></span><br><span class="line"><span class="keyword">final</span> ForkJoinTask&lt;?&gt; nextTaskFor(WorkQueue w) &#123;</span><br><span class="line">    <span class="keyword">for</span> (ForkJoinTask&lt;?&gt; t;;) &#123;</span><br><span class="line">        WorkQueue q; <span class="keyword">int</span> b;</span><br><span class="line">        <span class="comment">//首先尝试nextLocalTask本地任务.</span></span><br><span class="line">        <span class="keyword">if</span> ((t = w.nextLocalTask()) != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        <span class="comment">//获取不到本地任务,尝试从其他队列获取非空队列,获取不到非空队列,返回null.</span></span><br><span class="line">        <span class="keyword">if</span> ((q = findNonEmptyStealQueue()) == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//获取到了非空队列,从base处取任务,非空则返回,为空则重复循环.</span></span><br><span class="line">        <span class="keyword">if</span> ((b = q.base) - q.top &lt; <span class="number">0</span> &amp;&amp; (t = q.pollAt(b)) != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="tryTerminate"><a href="#tryTerminate" class="headerlink" title="tryTerminate"></a>tryTerminate</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前面不止一次提到过tryTerminate,说过它会尝试终止或完成终止.</span></span><br><span class="line"><span class="comment">//参数now如果设置为true,则表示在runState进入SHUTDOWN关闭态(负)时无条件终止,否则需要在进入SHUTDOWN同时没有work也没有活跃worker的情况下终止.</span></span><br><span class="line"><span class="comment">//如果设置enable为true,则下次调用时runState为负,可直接进入关闭流程(如果有now为true,则立即关).</span></span><br><span class="line"><span class="comment">//如果当前线程池进入终止流程或已终止,返回true.</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">tryTerminate</span><span class="params">(<span class="keyword">boolean</span> now, <span class="keyword">boolean</span> enable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rs;</span><br><span class="line">    <span class="comment">//common池不可关.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == common)                       <span class="comment">// cannot shut down</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//1.runState拦截和处理.</span></span><br><span class="line">    <span class="keyword">if</span> ((rs = runState) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!enable)</span><br><span class="line">            <span class="comment">//1.1对于当前runState非负的情况,如果没有指定enable,返回false.</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//1.2如果指定了enable,将加运行状态锁并更新runState的首位为1,即runState下次进入时为负.不再进入1的拦截处理流程.</span></span><br><span class="line">        rs = lockRunState();                 </span><br><span class="line">        unlockRunState(rs, (rs &amp; ~RSLOCK) | SHUTDOWN);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.终止的处理流程.</span></span><br><span class="line">    <span class="keyword">if</span> ((rs &amp; STOP) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//2.1.没有指定即刻关闭,检查是否线程池已进入静寂态.</span></span><br><span class="line">        <span class="keyword">if</span> (!now) &#123; </span><br><span class="line">            <span class="comment">//循环重复直到稳态.初始化校验和机制.                          </span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">long</span> oldSum = <span class="number">0L</span>;;) &#123;        </span><br><span class="line">                WorkQueue[] ws; WorkQueue w; <span class="keyword">int</span> m, b; <span class="keyword">long</span> c;</span><br><span class="line">                <span class="keyword">long</span> checkSum = ctl;<span class="comment">//校验和取ctl</span></span><br><span class="line">                <span class="keyword">if</span> ((<span class="keyword">int</span>)(checkSum &gt;&gt; AC_SHIFT) + (config &amp; SMASK) &gt; <span class="number">0</span>)</span><br><span class="line">                    <span class="comment">//2.1.1当前线程池还有活跃的worker(前面解释过).此时应返回false</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;            </span><br><span class="line">                <span class="keyword">if</span> ((ws = workQueues) == <span class="keyword">null</span> || (m = ws.length - <span class="number">1</span>) &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="comment">//2.1.2线程池已经没有队列,直接break进入后续流程.</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">//2.1.3从0开始遍历到ws的最后一个队列. </span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((w = ws[i]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> ((b = w.base) != w.top || w.scanState &gt;= <span class="number">0</span> ||</span><br><span class="line">                            w.currentSteal != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="comment">//只要发现任何一个队列非空,或队列未进入非活跃态(负)或队列仍有偷来的任务未完成.</span></span><br><span class="line">                            <span class="comment">//尝试释放栈顶worker并增加一个活跃数.并返回false,可以据此重新检查.</span></span><br><span class="line">                            tryRelease(c = ctl, ws[m &amp; (<span class="keyword">int</span>)c], AC_UNIT);</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">false</span>;   </span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//队列非null但是空队列,给校验和增加base.</span></span><br><span class="line">                        checkSum += b;</span><br><span class="line">                        <span class="keyword">if</span> ((i &amp; <span class="number">1</span>) == <span class="number">0</span>)</span><br><span class="line">                            <span class="comment">//发现非worker的队列,直接让外部禁用.</span></span><br><span class="line">                            w.qlock = -<span class="number">1</span>;    </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//2.1.4校验和一轮不变,break掉进入后置流程.即2.1.3中每一次取ws[i]都是null.</span></span><br><span class="line">                <span class="keyword">if</span> (oldSum == (oldSum = checkSum))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2.2.到这一步,已经保证了所有的关闭条件.若还没有给运行状态锁加上stop标记,</span></span><br><span class="line">        <span class="comment">//则给它加上标记.此时再有其他线程去尝试关闭,会进不来2这个分支.</span></span><br><span class="line">        <span class="keyword">if</span> ((runState &amp; STOP) == <span class="number">0</span>) &#123;</span><br><span class="line">            rs = lockRunState();              <span class="comment">// enter STOP phase</span></span><br><span class="line">            unlockRunState(rs, (rs &amp; ~RSLOCK) | STOP);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.经过前面的阶段,已完成预处理或now检查,可进入后置流程.</span></span><br><span class="line">    <span class="keyword">int</span> pass = <span class="number">0</span>;                             <span class="comment">// 3 passes to help terminate</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> oldSum = <span class="number">0L</span>;;) &#123;                <span class="comment">// or until done or stable</span></span><br><span class="line">        WorkQueue[] ws; WorkQueue w; ForkJoinWorkerThread wt; <span class="keyword">int</span> m;</span><br><span class="line">        <span class="keyword">long</span> checkSum = ctl;</span><br><span class="line">        <span class="comment">//3.1前面解释过这个状态表示当前无活跃worker.</span></span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">short</span>)(checkSum &gt;&gt;&gt; TC_SHIFT) + (config &amp; SMASK) &lt;= <span class="number">0</span> ||</span><br><span class="line">            (ws = workQueues) == <span class="keyword">null</span> || (m = ws.length - <span class="number">1</span>) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((runState &amp; TERMINATED) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//在确保无worker活跃的情况,直接将线程池置为TERMINATED.并唤醒所有等待终结的线程.</span></span><br><span class="line">                rs = lockRunState();       </span><br><span class="line">                unlockRunState(rs, (rs &amp; ~RSLOCK) | TERMINATED);</span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123; notifyAll(); &#125; </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//到此一定是终结态了,退出循环,结束方法返回true.</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.2内循环处理存在活跃worker的情况.从第一个队列开始遍历.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((w = ws[i]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//3.2.1对每个非null队列,增加一次校验和并禁用队列.</span></span><br><span class="line">                checkSum += w.base;</span><br><span class="line">                w.qlock = -<span class="number">1</span>;               </span><br><span class="line">                <span class="keyword">if</span> (pass &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//3.2.2内循环初次pass为0不能进入.</span></span><br><span class="line">                    <span class="comment">//pass大于0,取消队列上的所有任务,清理队列.</span></span><br><span class="line">                    w.cancelAll();  </span><br><span class="line">                    <span class="keyword">if</span> (pass &gt; <span class="number">1</span> &amp;&amp; (wt = w.owner) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">//3.2.3 pass大于1并且队列当前存在owner,扰动它.</span></span><br><span class="line">                        <span class="keyword">if</span> (!wt.isInterrupted()) &#123;</span><br><span class="line">                            <span class="keyword">try</span> &#123;           </span><br><span class="line">                                wt.interrupt();</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (Throwable ignore) &#123;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (w.scanState &lt; <span class="number">0</span>)</span><br><span class="line">                            <span class="comment">//3.2.4如果w代表的worker正在等待任务,让它取消停顿,进入结束流程.</span></span><br><span class="line">                            U.unpark(wt); </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.3如果校验和在几轮(最大为3或m的最大值)循环中改变过,说明并未进入稳态.将oldSum赋值为新的checkSum并重置pass为0.</span></span><br><span class="line">        <span class="keyword">if</span> (checkSum != oldSum) &#123;   </span><br><span class="line">            oldSum = checkSum;</span><br><span class="line">            pass = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.4pass从未被归置为0,稳态增加到大于3且大于m的情况,不能再帮助了,退出循环返回true.</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pass &gt; <span class="number">3</span> &amp;&amp; pass &gt; m) </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//3.5pass未到临界值,加1.</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (++pass &gt; <span class="number">1</span>) &#123; </span><br><span class="line">            <span class="keyword">long</span> c; <span class="keyword">int</span> j = <span class="number">0</span>, sp;</span><br><span class="line">            <span class="comment">//每一次进入3.5都会执行一次循环.如果ctl表示有worker正在scan,最多m次尝试release掉栈顶worker.</span></span><br><span class="line">            <span class="comment">//因为最多只有m个worker在栈中阻塞.因此3.4是合理的.</span></span><br><span class="line">            <span class="keyword">while</span> (j++ &lt;= m &amp;&amp; (sp = (<span class="keyword">int</span>)(c = ctl)) != <span class="number">0</span>)</span><br><span class="line">                tryRelease(c, ws[sp &amp; m], AC_UNIT);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="externalSubmit"><a href="#externalSubmit" class="headerlink" title="externalSubmit"></a>externalSubmit</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字面意思,从外面提交一任务入池.有前面的基础后,此方法很容易理解.</span></span><br><span class="line"><span class="comment">//此方法会处理一些不常见的case,比如辅助进行池的一些初始化过程(首次提交任务),</span></span><br><span class="line"><span class="comment">//如果发现是首次外部线程提交任务,在ws的目标索引位置为空或者出现竞态,它会尝试创建新的共享队列.</span></span><br><span class="line"><span class="comment">//参数task是目标任务,调用者必须保证非空.</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">externalSubmit</span><span class="params">(ForkJoinTask&lt;?&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r; </span><br><span class="line">    <span class="comment">//初始化一个用于定位的随机数r,前面曾简单介绍过它和localInit,许多公司的分布式id也是有它的成份.     </span></span><br><span class="line">    <span class="comment">//而这个随机数与线程相当于绑定在了一起,因此,可以使用它表示一个线程特有的东西.                             </span></span><br><span class="line">    <span class="keyword">if</span> ((r = ThreadLocalRandom.getProbe()) == <span class="number">0</span>) &#123;</span><br><span class="line">        ThreadLocalRandom.localInit();</span><br><span class="line">        r = ThreadLocalRandom.getProbe();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//循环尝试压入任务.</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        WorkQueue[] ws; WorkQueue q; <span class="keyword">int</span> rs, m, k;</span><br><span class="line">        <span class="keyword">boolean</span> move = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> ((rs = runState) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//1.发现此时线程池的运行状态已经进入SHUTDOWN,帮助终止线程池,并抛出拒绝异常.</span></span><br><span class="line">            tryTerminate(<span class="keyword">false</span>, <span class="keyword">false</span>);     <span class="comment">// help terminate</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2.发现线程池还未初始化,辅助初始化.STARTED为第三位.</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((rs &amp; STARTED) == <span class="number">0</span> ||     <span class="comment">// initialize</span></span><br><span class="line">                 ((ws = workQueues) == <span class="keyword">null</span> || (m = ws.length - <span class="number">1</span>) &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">int</span> ns = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//加锁.</span></span><br><span class="line">            rs = lockRunState();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//double check并尝试初台化stealCounter.它在awaitRunStateLock(尝试加锁)的时候会用来wait,</span></span><br><span class="line">                <span class="comment">//同时也处理了初始化阶段的竞态,还记得在awaitRunStateLock方法中发现stealCounter为null时的注释(初始化竞态)吗?</span></span><br><span class="line">                <span class="keyword">if</span> ((rs &amp; STARTED) == <span class="number">0</span>) &#123;</span><br><span class="line">                    U.compareAndSwapObject(<span class="keyword">this</span>, STEALCOUNTER, <span class="keyword">null</span>,</span><br><span class="line">                                           <span class="keyword">new</span> AtomicLong());</span><br><span class="line">                    <span class="comment">//创建workQueues数组,大小是2的幂.并保证至少有两个插槽(语义理解,如果是4个的话,两个share两个独有).</span></span><br><span class="line">                    <span class="keyword">int</span> p = config &amp; SMASK;</span><br><span class="line">                    <span class="comment">//下面这个比较好理解,总之,最小的情况下,n也会是(1+1)&lt;&lt;1=4,这样保证有两个位置给SHARE两个位置给工作线程.</span></span><br><span class="line">                    <span class="comment">//n的初始值取决于并行度.</span></span><br><span class="line">                    <span class="keyword">int</span> n = (p &gt; <span class="number">1</span>) ? p - <span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">                    n |= n &gt;&gt;&gt; <span class="number">1</span>; n |= n &gt;&gt;&gt; <span class="number">2</span>;  n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">                    n |= n &gt;&gt;&gt; <span class="number">8</span>; n |= n &gt;&gt;&gt; <span class="number">16</span>; n = (n + <span class="number">1</span>) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">                    workQueues = <span class="keyword">new</span> WorkQueue[n];</span><br><span class="line">                    <span class="comment">//新的运行状态.</span></span><br><span class="line">                    ns = STARTED;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//完成了辅助初始化,则解锁,并置runState加上STARTED标识.</span></span><br><span class="line">                unlockRunState(rs, (rs &amp; ~RSLOCK) | ns);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.某轮循环发现早已完成初始化,使用本线程的随机数r计算索引,发现ws[k]存在.说明已被别的线程在此初始化了一个队列.</span></span><br><span class="line">        <span class="comment">//注意索引k的值的计算,它与m进行与运算,保证不大于m,同时与SQMASK,即share-queue mask,它的值是0X007e,前面说过,</span></span><br><span class="line">        <span class="comment">//很明显,它是整数的2至7位,保证了共享队列只能放在ws的偶数位.</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((q = ws[k = r &amp; m &amp; SQMASK]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//3.1对队列加锁.</span></span><br><span class="line">            <span class="keyword">if</span> (q.qlock == <span class="number">0</span> &amp;&amp; U.compareAndSwapInt(q, QLOCK, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="comment">//取队列的数组和top</span></span><br><span class="line">                ForkJoinTask&lt;?&gt;[] a = q.array;</span><br><span class="line">                <span class="keyword">int</span> s = q.top;</span><br><span class="line">                <span class="comment">//初始化提交或者扩容.</span></span><br><span class="line">                <span class="keyword">boolean</span> submitted = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;                      <span class="comment">// locked version of push</span></span><br><span class="line">                    <span class="comment">//||左边的语句指符合添加元素的条件,右边表示如果不符合添加条件,则进行扩容.</span></span><br><span class="line">                    <span class="keyword">if</span> ((a != <span class="keyword">null</span> &amp;&amp; a.length &gt; s + <span class="number">1</span> - q.base) ||</span><br><span class="line">                        (a = q.growArray()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">//符合添加条件或扩容成功,取top对应的索引j.</span></span><br><span class="line">                        <span class="keyword">int</span> j = (((a.length - <span class="number">1</span>) &amp; s) &lt;&lt; ASHIFT) + ABASE;</span><br><span class="line">                        <span class="comment">//向top放入task.</span></span><br><span class="line">                        U.putOrderedObject(a, j, task);</span><br><span class="line">                        <span class="comment">//给top加1.</span></span><br><span class="line">                        U.putOrderedInt(q, QTOP, s + <span class="number">1</span>);</span><br><span class="line">                        <span class="comment">//标记为已提交.</span></span><br><span class="line">                        submitted = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">//释放qlock.</span></span><br><span class="line">                    U.compareAndSwapInt(q, QLOCK, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (submitted) &#123;</span><br><span class="line">                    <span class="comment">//如果提交成功,则尝试唤醒top或创建一个worker(如果太少).并返回.</span></span><br><span class="line">                    signalWork(ws, q);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//竞态失败,标记move</span></span><br><span class="line">            move = <span class="keyword">true</span>;                   <span class="comment">// move on failure</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.2计算出的位置没有queue,且runState未锁,创建一个新的.</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (((rs = runState) &amp; RSLOCK) == <span class="number">0</span>) &#123; <span class="comment">// create new queue</span></span><br><span class="line">            <span class="comment">//共享队列没有owner.</span></span><br><span class="line">            q = <span class="keyword">new</span> WorkQueue(<span class="keyword">this</span>, <span class="keyword">null</span>);</span><br><span class="line">            <span class="comment">//随机数就用线程的随机数r.</span></span><br><span class="line">            q.hint = r;</span><br><span class="line">            <span class="comment">//config的第32位置1表示共享队列</span></span><br><span class="line">            q.config = k | SHARED_QUEUE;</span><br><span class="line">            <span class="comment">//队列的scanState直接置为INACTIVE,很明显,参考前面的描述,</span></span><br><span class="line">            <span class="comment">//它没有工作线程,也不会参与活化和scan阻塞的过程,也不会将自己的scanState压入ctl后32位做栈元素.</span></span><br><span class="line">            q.scanState = INACTIVE;</span><br><span class="line">            <span class="comment">//加锁.</span></span><br><span class="line">            rs = lockRunState();         </span><br><span class="line">            <span class="keyword">if</span> (rs &gt; <span class="number">0</span> &amp;&amp;  (ws = workQueues) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                k &lt; ws.length &amp;&amp; ws[k] == <span class="keyword">null</span>)</span><br><span class="line">                <span class="comment">//仍旧符合添加条件,池未终结,将q赋给ws[k],否则的话,可能在下一轮循环进入1帮助终止,</span></span><br><span class="line">                <span class="comment">//也可能进入2用现成的队列内的任务数组添加元素到top.也可能在4处发现竞态,并最终导致5处重初始化r并重新循环找索引.</span></span><br><span class="line">                ws[k] = q;                 <span class="comment">// else terminated</span></span><br><span class="line">            unlockRunState(rs, rs &amp; ~RSLOCK);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4.标记繁忙.</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            move = <span class="keyword">true</span>;                   <span class="comment">// move if busy</span></span><br><span class="line">        <span class="comment">//5.本轮循环经历2的竞态失败或4的繁忙,重新初始化一个r供下轮循环使用.</span></span><br><span class="line">        <span class="keyword">if</span> (move)</span><br><span class="line">            r = ThreadLocalRandom.advanceProbe(r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="externalPush"><a href="#externalPush" class="headerlink" title="externalPush"></a>externalPush</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//尝试将给定的task添加到一个提交者当前的队列中,如果还需要额外的初始化操作等,使用上面的externalSubmit.</span></span><br><span class="line"><span class="comment">//我们知道,绝大多数的情况下,不需要初始化线程池的任务数组(整个线程池就一次),不需要初始化一个工作队列(每个ws一个位置只一次).</span></span><br><span class="line"><span class="comment">//因此它相当于先尝试用最简单直接的办法将任务压入队列,如果ws存在而队列需要初始化,或者池本身就没有完成初始化,再使用externalSubmit.</span></span><br><span class="line"><span class="comment">//参数task是要提交的任务,调用者本身必须保证它非空.</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">externalPush</span><span class="params">(ForkJoinTask&lt;?&gt; task)</span> </span>&#123;</span><br><span class="line">    WorkQueue[] ws; WorkQueue q; <span class="keyword">int</span> m;</span><br><span class="line">    <span class="comment">//老办法,初始的随机数.运行状态.</span></span><br><span class="line">    <span class="keyword">int</span> r = ThreadLocalRandom.getProbe();</span><br><span class="line">    <span class="keyword">int</span> rs = runState;</span><br><span class="line">    <span class="comment">//快速压入的代码分支,条件是队列数组ws已分配,非空,且根据r计算出来索引位取出的队列</span></span><br><span class="line">    <span class="comment">//存在且已完成初始化,线程池未进入SHUTDOWN,并且能够对队列进行加锁.</span></span><br><span class="line">    <span class="keyword">if</span> ((ws = workQueues) != <span class="keyword">null</span> &amp;&amp; (m = (ws.length - <span class="number">1</span>)) &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (q = ws[m &amp; r &amp; SQMASK]) != <span class="keyword">null</span> &amp;&amp; r != <span class="number">0</span> &amp;&amp; rs &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        U.compareAndSwapInt(q, QLOCK, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="comment">//快速入队.</span></span><br><span class="line">        ForkJoinTask&lt;?&gt;[] a; <span class="keyword">int</span> am, n, s;</span><br><span class="line">        <span class="keyword">if</span> ((a = q.array) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">            <span class="comment">//第二个条件是没有到扩容条件.</span></span><br><span class="line">            (am = a.length - <span class="number">1</span>) &gt; (n = (s = q.top) - q.base)) &#123;</span><br><span class="line">            <span class="comment">//计算出top的索引j,并将当前任务放入,将top加1</span></span><br><span class="line">            <span class="keyword">int</span> j = ((am &amp; s) &lt;&lt; ASHIFT) + ABASE;</span><br><span class="line">            U.putOrderedObject(a, j, task);</span><br><span class="line">            U.putOrderedInt(q, QTOP, s + <span class="number">1</span>);</span><br><span class="line">            U.putIntVolatile(q, QLOCK, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (n &lt;= <span class="number">1</span>)</span><br><span class="line">                <span class="comment">//发现原来的队列长度很短,有可能有worker正在scan,尝试唤醒一个worker或添加一个worker</span></span><br><span class="line">                signalWork(ws, q);</span><br><span class="line">            <span class="comment">//只要成功压入,返回.</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后解锁.</span></span><br><span class="line">        U.compareAndSwapInt(q, QLOCK, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//未能成功压栈,原因可能是线程池未初始化,工作队列未初始化,队列达到扩容阈值等.使用externalSubmit进行.</span></span><br><span class="line">    externalSubmit(task);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="tryExternalUnpush"><a href="#tryExternalUnpush" class="headerlink" title="tryExternalUnpush"></a>tryExternalUnpush</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//尝试弹出外部提交者的任务,找到队列,非空时加锁,最后调整top,每次进行都会检查失败,尽管很少失败.</span></span><br><span class="line"><span class="comment">//在前面ForkJoinTask和CountedCompleter等文章中曾引用过相关方法,此方法可以令等待任务的线程</span></span><br><span class="line"><span class="comment">//自行将任务出队并执行,而不是在池内线程还忙碌的情况下干等.但是该队列可能被其他外部线程放置了新的栈顶</span></span><br><span class="line"><span class="comment">//且看内部方法实现,当且仅当task是栈顶才有用.</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryExternalUnpush</span><span class="params">(ForkJoinTask&lt;?&gt; task)</span> </span>&#123;</span><br><span class="line">    WorkQueue[] ws; WorkQueue w; ForkJoinTask&lt;?&gt;[] a; <span class="keyword">int</span> m, s;</span><br><span class="line">    <span class="comment">//当前线程生成随机数r.</span></span><br><span class="line">    <span class="keyword">int</span> r = ThreadLocalRandom.getProbe();</span><br><span class="line">    <span class="keyword">if</span> ((ws = workQueues) != <span class="keyword">null</span> &amp;&amp; (m = ws.length - <span class="number">1</span>) &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (w = ws[m &amp; r &amp; SQMASK]) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">        (a = w.array) != <span class="keyword">null</span> &amp;&amp; (s = w.top) != w.base) &#123;</span><br><span class="line">        <span class="comment">//进入if的条件.线程池已初始化,ws存在,w存在且w非空队列.注意,仍旧取的偶数索引.</span></span><br><span class="line">        <span class="comment">//计算当前最顶部元素的索引j</span></span><br><span class="line">        <span class="keyword">long</span> j = (((a.length - <span class="number">1</span>) &amp; (s - <span class="number">1</span>)) &lt;&lt; ASHIFT) + ABASE;</span><br><span class="line">        <span class="comment">//尝试加锁qlock,加锁成功进入.</span></span><br><span class="line">        <span class="keyword">if</span> (U.compareAndSwapInt(w, QLOCK, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="comment">//进一步check队列w的top和w的array未变.</span></span><br><span class="line">            <span class="keyword">if</span> (w.top == s &amp;&amp; w.array == a &amp;&amp;</span><br><span class="line">                <span class="comment">//队列w的顶部元素就是参数task</span></span><br><span class="line">                U.getObject(a, j) == task &amp;&amp;</span><br><span class="line">                <span class="comment">//成功将task出队</span></span><br><span class="line">                U.compareAndSwapObject(a, j, task, <span class="keyword">null</span>)) &#123;</span><br><span class="line">                <span class="comment">//将top减1并释放锁,返回true.</span></span><br><span class="line">                U.putOrderedInt(w, QTOP, s - <span class="number">1</span>);</span><br><span class="line">                U.putOrderedInt(w, QLOCK, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//加锁前已有更改或者task本身就不是顶部任务,直接解锁.返回false.</span></span><br><span class="line">            U.compareAndSwapInt(w, QLOCK, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//默认返回fasle</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="externalHelpComplete"><a href="#externalHelpComplete" class="headerlink" title="externalHelpComplete"></a>externalHelpComplete</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//外部提交者helpComplete.介绍CountedCompleter提过此方法.</span></span><br><span class="line"><span class="comment">//当目标任务task是CountedCompleter类型时可以手动调用CountedCompleter::helpComplete,它会调用此处,ForkJoinTask::get也有调用.</span></span><br><span class="line"><span class="comment">//此方法可以令外部线程在等待task时帮助completer栈链上它的子孙任务完成,从而加速task的完成.</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">externalHelpComplete</span><span class="params">(CountedCompleter&lt;?&gt; task, <span class="keyword">int</span> maxTasks)</span> </span>&#123;</span><br><span class="line">    WorkQueue[] ws; <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> r = ThreadLocalRandom.getProbe();</span><br><span class="line">    <span class="keyword">return</span> ((ws = workQueues) == <span class="keyword">null</span> || (n = ws.length) == <span class="number">0</span>) ? <span class="number">0</span> :</span><br><span class="line">        <span class="comment">//ws未初始化,返回0,否则返回helpComplete的结果,取w的方式不变.</span></span><br><span class="line">        helpComplete(ws[(n - <span class="number">1</span>) &amp; r &amp; SQMASK], task, maxTasks);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="invoke-2"><a href="#invoke-2" class="headerlink" title="invoke"></a>invoke</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//invoke方法会尝试将task压入池,但也会立即join等待,压入池的方法即前面介绍过的externalPush,同样join方法也可能会</span></span><br><span class="line"><span class="comment">//导致当前线程自身完成了任务(池中工作线程忙碌而当前线程立即从队列中获取了该任务).</span></span><br><span class="line"><span class="comment">//执行结束后返回该任务的执行结果,当出现异常时,直接重新抛出.但也可能抛出拒绝异常(拒绝入队).</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">invoke</span><span class="params">(ForkJoinTask&lt;T&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    externalPush(task);</span><br><span class="line">    <span class="keyword">return</span> task.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="execute-1"><a href="#execute-1" class="headerlink" title="execute"></a>execute</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//安排给定任务的执行,异步进行.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(ForkJoinTask&lt;?&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    externalPush(task);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="execute-2"><a href="#execute-2" class="headerlink" title="execute"></a>execute</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//继承自AbstractExecutorService的方法列表</span></span><br><span class="line"><span class="comment">//execute方法,传入runnable,使用前面文章介绍的ForkJoinTask.RunnableExecuteAction适配器.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    ForkJoinTask&lt;?&gt; job;</span><br><span class="line">    <span class="keyword">if</span> (task <span class="keyword">instanceof</span> ForkJoinTask&lt;?&gt;) <span class="comment">// avoid re-wrap</span></span><br><span class="line">        job = (ForkJoinTask&lt;?&gt;) task;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        job = <span class="keyword">new</span> ForkJoinTask.RunnableExecuteAction(task);</span><br><span class="line">    externalPush(job);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="submit-1"><a href="#submit-1" class="headerlink" title="submit"></a>submit</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对callable的适配,前面也提过.</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">ForkJoinTask&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span> </span>&#123;</span><br><span class="line">    ForkJoinTask&lt;T&gt; job = <span class="keyword">new</span> ForkJoinTask.AdaptedCallable&lt;T&gt;(task);</span><br><span class="line">    externalPush(job);</span><br><span class="line">    <span class="keyword">return</span> job;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对task和result的适配.</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">ForkJoinTask&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span> </span>&#123;</span><br><span class="line">    ForkJoinTask&lt;T&gt; job = <span class="keyword">new</span> ForkJoinTask.AdaptedRunnable&lt;T&gt;(task, result);</span><br><span class="line">    externalPush(job);</span><br><span class="line">    <span class="keyword">return</span> job;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对submit一个Runnable的适配.避免重复包装.因为ForkJoinTask也可以实现runnable.</span></span><br><span class="line"><span class="comment">//典型的场景,先submit一个runnable,得到返回的job,再将job给submit进去.</span></span><br><span class="line"><span class="keyword">public</span> ForkJoinTask&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    ForkJoinTask&lt;?&gt; job;</span><br><span class="line">    <span class="keyword">if</span> (task <span class="keyword">instanceof</span> ForkJoinTask&lt;?&gt;) <span class="comment">// avoid re-wrap</span></span><br><span class="line">        job = (ForkJoinTask&lt;?&gt;) task;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        job = <span class="keyword">new</span> ForkJoinTask.AdaptedRunnableAction(task);</span><br><span class="line">    externalPush(job);</span><br><span class="line">    <span class="keyword">return</span> job;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="invokeAll-1"><a href="#invokeAll-1" class="headerlink" title="invokeAll"></a>invokeAll</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行所有任务.一样先入队再执行,可能出现本外部线程又偷回来执行的情况.</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks) &#123;</span><br><span class="line"></span><br><span class="line">    ArrayList&lt;Future&lt;T&gt;&gt; futures = <span class="keyword">new</span> ArrayList&lt;&gt;(tasks.size());</span><br><span class="line">    <span class="comment">//标记是否有异常.</span></span><br><span class="line">    <span class="keyword">boolean</span> done = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Callable&lt;T&gt; t : tasks) &#123;</span><br><span class="line">            ForkJoinTask&lt;T&gt; f = <span class="keyword">new</span> ForkJoinTask.AdaptedCallable&lt;T&gt;(t);</span><br><span class="line">            <span class="comment">//把所有任务包成适配器并加入futures列表.</span></span><br><span class="line">            futures.add(f);</span><br><span class="line">            <span class="comment">//压入池.</span></span><br><span class="line">            externalPush(f);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = futures.size(); i &lt; size; i++)</span><br><span class="line">            <span class="comment">//对每一个任务进行静默等待.</span></span><br><span class="line">            ((ForkJoinTask&lt;?&gt;)futures.get(i)).quietlyJoin();</span><br><span class="line">        <span class="comment">//上面的循环成功退出,置true返回.</span></span><br><span class="line">        done = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> futures;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!done)</span><br><span class="line">            <span class="comment">//发现是异常退出,则依次取消任务.</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = futures.size(); i &lt; size; i++)</span><br><span class="line">                futures.get(i).cancel(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="getRunningThreadCount"><a href="#getRunningThreadCount" class="headerlink" title="getRunningThreadCount"></a>getRunningThreadCount</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//估计当前线程池中正在运行(偷任务或运行任务)的线程,也就是未阻塞等待任务的线程.它会过度估计正在运行的线程数.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRunningThreadCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rc = <span class="number">0</span>;</span><br><span class="line">    WorkQueue[] ws; WorkQueue w;</span><br><span class="line">    <span class="keyword">if</span> ((ws = workQueues) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; ws.length; i += <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((w = ws[i]) != <span class="keyword">null</span> &amp;&amp; w.isApparentlyUnblocked())</span><br><span class="line">                <span class="comment">//只取ws奇数索引的worker,只要它isApparentlyUnblocked,即未进入waiting,blocking,wating_timed.</span></span><br><span class="line">                ++rc;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="getActiveThreadCount"><a href="#getActiveThreadCount" class="headerlink" title="getActiveThreadCount"></a>getActiveThreadCount</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//估计当前正在进行偷取或执行任务的线程(未阻塞等待任务),此方法也会过度估计.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getActiveThreadCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//很明显,根据前面我们研究了好久的逻辑,每release/signal的worker都会增加一个活跃数单元,</span></span><br><span class="line">    <span class="comment">//初始添加的worker也会增加一个活跃数单元和总数,显然只要有active的,那么r必然是一个溢出的正数.</span></span><br><span class="line">    <span class="keyword">int</span> r = (config &amp; SMASK) + (<span class="keyword">int</span>)(ctl &gt;&gt; AC_SHIFT);</span><br><span class="line">    <span class="keyword">return</span> (r &lt;= <span class="number">0</span>) ? <span class="number">0</span> : r; <span class="comment">//忽略负值.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="isQuiescent"><a href="#isQuiescent" class="headerlink" title="isQuiescent"></a>isQuiescent</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断线程池此刻是否已经进入静寂态,所谓的静寂态是指当前线程池中所有worker都已经阻塞在等待任务了,</span></span><br><span class="line"><span class="comment">//因为没有任何任务可供他们偷取或执行,也没有任何挂起的提交入池的任务.此方法相对保守,并不是所有线程都空闲的情况下</span></span><br><span class="line"><span class="comment">//立即会返回true,只有在他们减少了活跃数之后.(也就是保持空闲一段时间)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isQuiescent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//前面分析过,显然这个表达式不大于0即为不溢出的情况,回忆前面关于scan时,终止时等的降低活跃数.</span></span><br><span class="line">    <span class="keyword">return</span> (config &amp; SMASK) + (<span class="keyword">int</span>)(ctl &gt;&gt; AC_SHIFT) &lt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown"></a>shutdown</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此方法的执行参数,注意,now传false,enable传true.</span></span><br><span class="line"><span class="comment">//它的执行结果很简单(可以参考前面的tryTerminate).</span></span><br><span class="line"><span class="comment">//1.此前已经调用过tryTerminate并enable,或者调过shutdown,那会导致一次终结.</span></span><br><span class="line"><span class="comment">//2.初次调用,前面提交过的任务继续执行,但不会接受新的任务(因为runState首位置1了).</span></span><br><span class="line"><span class="comment">//3.commonPool不许关.</span></span><br><span class="line"><span class="comment">//4.已关的,调用了也没什么效果.但第二次调用时,已经在过程中的任务可能受此影响取消.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    checkPermission();</span><br><span class="line">    tryTerminate(<span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="shutdownNow"><a href="#shutdownNow" class="headerlink" title="shutdownNow"></a>shutdownNow</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//它会尝试立即取消和停止所有的任务,拒绝后续提交的任务.如果是common池则无效果.</span></span><br><span class="line"><span class="comment">//如果已经关闭,再调用无影响.正在被提交入池或正在执行的任务(在调用此方法执行时)可能会被取消,也可能不会(取决于时机,可能早于取消过程而完成执行).</span></span><br><span class="line"><span class="comment">//它会取消掉已存在的任务或未执行的任务.方法总会返回一个空的list.(与其他executor不同)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    checkPermission();</span><br><span class="line">    tryTerminate(<span class="keyword">true</span>, <span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="isTerminated"><a href="#isTerminated" class="headerlink" title="isTerminated"></a>isTerminated</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//很好理解,runState的31位是1,而仅有在shutdown方法中所有worker都已闲置或ws为空才会加上此位.显然此时所有任务都已完成.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isTerminated</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (runState &amp; TERMINATED) != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="isTerminating"><a href="#isTerminating" class="headerlink" title="isTerminating"></a>isTerminating</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isTerminating</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rs = runState;</span><br><span class="line">    <span class="keyword">return</span> (rs &amp; STOP) != <span class="number">0</span> &amp;&amp; (rs &amp; TERMINATED) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="isShutdown"><a href="#isShutdown" class="headerlink" title="isShutdown"></a>isShutdown</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//已SHUTDOWN,首位标记,显然只要shutdown方法调用并传enable为true一定会有此结果.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isShutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (runState &amp; SHUTDOWN) != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="awaitTermination"><a href="#awaitTermination" class="headerlink" title="awaitTermination"></a>awaitTermination</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//等待一个shutdown请求后所有的任务完成或者发生超时,或者当前线程被扰动(第一优先级).</span></span><br><span class="line"><span class="comment">//因为common池永远不会随程序调用shutdown而终止,因此使用commonPool调用此方法时,</span></span><br><span class="line"><span class="comment">//会直接等效于awaitQuiescence,而且永远会返回false.</span></span><br><span class="line"><span class="comment">//返回true,代表当前线程池终止了,false代表超时了.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">awaitTermination</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="comment">//1.当前线程中断,抛出异常.</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == common) &#123;</span><br><span class="line">        <span class="comment">//2.common池等效于awaitQuiescence并返回false.</span></span><br><span class="line">        awaitQuiescence(timeout, unit);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">    <span class="keyword">if</span> (isTerminated())</span><br><span class="line">        <span class="comment">//3.发现所有任务已完成返回true.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>)</span><br><span class="line">        <span class="comment">//4.已超时返回false.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//5.计算deadline并进入循环等待逻辑.</span></span><br><span class="line">    <span class="keyword">long</span> deadline = System.nanoTime() + nanos;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isTerminated())</span><br><span class="line">                <span class="comment">//5.1循环中发现已达到完成态,返回true.</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>)</span><br><span class="line">                <span class="comment">//5.2循环时发现超时,false.</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//5.3循环时减少时间并等待.</span></span><br><span class="line">            <span class="keyword">long</span> millis = TimeUnit.NANOSECONDS.toMillis(nanos);</span><br><span class="line">            wait(millis &gt; <span class="number">0L</span> ? millis : <span class="number">1L</span>);</span><br><span class="line">            nanos = deadline - System.nanoTime();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="awaitQuiescence"><a href="#awaitQuiescence" class="headerlink" title="awaitQuiescence"></a>awaitQuiescence</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//等待静寂.如果当前线程是池内线程,等效于ForkJoinTask::helpQuiesce方法,否则只是等待.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">awaitQuiescence</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">    ForkJoinWorkerThread wt;</span><br><span class="line">    Thread thread = Thread.currentThread();</span><br><span class="line">    <span class="keyword">if</span> ((thread <span class="keyword">instanceof</span> ForkJoinWorkerThread) &amp;&amp;</span><br><span class="line">        (wt = (ForkJoinWorkerThread)thread).pool == <span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">//1.线程是ForkJoinWorkerThread,帮助静寂.返回true.</span></span><br><span class="line">        helpQuiescePool(wt.workQueue);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.不是池内线程,准备计时,初始化若干变量.</span></span><br><span class="line">    <span class="keyword">long</span> startTime = System.nanoTime();</span><br><span class="line">    WorkQueue[] ws;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">0</span>, m;</span><br><span class="line">    <span class="keyword">boolean</span> found = <span class="keyword">true</span>;<span class="comment">//代表发现任务.</span></span><br><span class="line">    <span class="comment">//3.循环等待静寂或超时.</span></span><br><span class="line">    <span class="keyword">while</span> (!isQuiescent() &amp;&amp; (ws = workQueues) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">           (m = ws.length - <span class="number">1</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//3.1有趣的地方,只有本轮没找到任务才会进行超时判断.</span></span><br><span class="line">        <span class="keyword">if</span> (!found) &#123;</span><br><span class="line">            <span class="comment">//3.1.1判断超时了,返回false.</span></span><br><span class="line">            <span class="keyword">if</span> ((System.nanoTime() - startTime) &gt; nanos)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//3.1.2没超时,放弃执行权一段时间,不能阻塞在此.</span></span><br><span class="line">            Thread.yield(); <span class="comment">// cannot block</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//改为false.</span></span><br><span class="line">        found = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//4.内循环从数组中间开始,一直递减到0.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = (m + <span class="number">1</span>) &lt;&lt; <span class="number">2</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">            ForkJoinTask&lt;?&gt; t; WorkQueue q; <span class="keyword">int</span> b, k;</span><br><span class="line">            <span class="comment">//4.1取队列从0开始,只要取出了ws的非空队列成员,进入逻辑.</span></span><br><span class="line">            <span class="keyword">if</span> ((k = r++ &amp; m) &lt;= m &amp;&amp; k &gt;= <span class="number">0</span> &amp;&amp; (q = ws[k]) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                (b = q.base) - q.top &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//4.2 found标记true</span></span><br><span class="line">                found = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">if</span> ((t = q.pollAt(b)) != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="comment">//4.3尝试从底部取出任务并执行.相当于帮助静寂</span></span><br><span class="line">                    t.doExec();</span><br><span class="line">                <span class="comment">//进入4.1,即break掉内循环,可能凑巧,执行完一个任务就静寂了.</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//能从while循环break出来或者循环条件为假退出,说明达到静寂.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ManagedBlocker"><a href="#ManagedBlocker" class="headerlink" title="ManagedBlocker"></a>ManagedBlocker</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MangedBlocker接口.它是一个为运行在ForkJoinPool中的任务维护并行度的接口</span></span><br><span class="line"><span class="comment">//我们可以通过拓展它来实现在ForkJoinPool中运行的任务的并行度管理.它只有两个方法.</span></span><br><span class="line"><span class="comment">//isReleasable方法会在没有必要阻塞时一定返回true,block方法会在必要时阻塞当前线程,</span></span><br><span class="line"><span class="comment">//它内部可以调用isReleasable.而这个调度需要使用ForkJoinPool#managedBlock(ManagedBlocker)</span></span><br><span class="line"><span class="comment">//它会尝试去调度,避免长期的阻塞,它允许更灵活的内部处理.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">interface</span> <span class="title">ManagedBlocker</span> </span>&#123;</span><br><span class="line">    <span class="comment">//可能会阻塞一个线程,比如等待监视器,当返回true时表示认为当前没有必要继续block.</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">block</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回true表示认为没有必要block.</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isReleasable</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//运行给定的阻塞任务,当在ForkJoinPool运行ForkJoinTask时,此方法在当前线程阻塞的情况下(调用blocker.block),</span></span><br><span class="line"><span class="comment">//认为需要保持必要并行度时安排一个备用线程,方法内重复调用blocker.isReleasable和blocker.block.且前者必在后者前,</span></span><br><span class="line"><span class="comment">//它返回false时才会有后者.如果没运行在ForkJoinPool内,那么方法的行为等效于下面这段代码:</span></span><br><span class="line"><span class="comment">//while(!blocker.isReleasable())&#123;if(blocker.block() break;&#125;</span></span><br><span class="line"><span class="comment">//参数blocker是上面的接口的实现类,在前面的文章CompletableFuture和响应式编程中曾见到一个实现类.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">managedBlock</span><span class="params">(ManagedBlocker blocker)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    ForkJoinPool p;</span><br><span class="line">    ForkJoinWorkerThread wt;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">//1.当前是ForkJoinPool池内线程时的逻辑.</span></span><br><span class="line">    <span class="keyword">if</span> ((t <span class="keyword">instanceof</span> ForkJoinWorkerThread) &amp;&amp;</span><br><span class="line">        (p = (wt = (ForkJoinWorkerThread)t).pool) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        WorkQueue w = wt.workQueue;</span><br><span class="line">        <span class="comment">//1.1取出工作队列,进行循环,blocker.isReleasable判断当前并非没有必要加锁时进入.</span></span><br><span class="line">        <span class="keyword">while</span> (!blocker.isReleasable()) &#123;</span><br><span class="line">            <span class="comment">//1.2要加锁,尝试补偿,它会在此时唤醒一个空闲的线程或创建一个新的线程来补偿当前线程的阻塞.</span></span><br><span class="line">            <span class="keyword">if</span> (p.tryCompensate(w)) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//1.3当前线程阻塞等待.</span></span><br><span class="line">                    <span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (!blocker.isReleasable() &amp;&amp;</span><br><span class="line">                                 !blocker.block());</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    U.getAndAddLong(p, CTL, AC_UNIT);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.非池内线程的逻辑.同上面的阻塞逻辑.</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (!blocker.isReleasable() &amp;&amp;</span><br><span class="line">                     !blocker.block());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">sanmeng</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://blog.huhdcc.top/2020/07/19/47803/hub/">https://blog.huhdcc.top/2020/07/19/47803/hub/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://blog.huhdcc.top" target="_blank">Here will be a new beginning</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JAVA/">JAVA</a><a class="post-meta__tags" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a><a class="post-meta__tags" href="/tags/%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5/">源码深入</a></div><div class="post_share"><div class="social-share" data-image="https://blog.huhdcc.top/image/hexo/image-20211022133817250.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/07/25/56893/hub/"><img class="prev_cover" src="https://blog.huhdcc.top/image/hexo/image-20200725140252917.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">多线程高阶-53-Phaser详解</div></div></a></div><div class="next-post pull_right"><a href="/2020/07/18/50320/hub/"><img class="next_cover" src="https://blog.huhdcc.top/image/hexo/image-20200718131809394.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">多线程高阶-51-StampedLock详解</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2020/07/05/52828/hub/" title="多线程高阶-27-AtomicBoolean详解"><img class="relatedPosts_cover" src="https://blog.huhdcc.top/image/hexo/image-20200706175723523.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-07-05</div><div class="relatedPosts_title">多线程高阶-27-AtomicBoolean详解</div></div></a></div><div class="relatedPosts_item"><a href="/2020/07/05/51967/hub/" title="多线程高阶-28-AtomicLong详解"><img class="relatedPosts_cover" src="https://blog.huhdcc.top/image/hexo/image-20200706175658410.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-07-05</div><div class="relatedPosts_title">多线程高阶-28-AtomicLong详解</div></div></a></div><div class="relatedPosts_item"><a href="/2020/07/06/7979/hub/" title="多线程高阶-32-AtomicLongArray详解"><img class="relatedPosts_cover" src="https://blog.huhdcc.top/image/hexo/image-20200706175601440.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-07-06</div><div class="relatedPosts_title">多线程高阶-32-AtomicLongArray详解</div></div></a></div><div class="relatedPosts_item"><a href="/2020/07/05/38835/hub/" title="多线程高阶-29-AtomicReference详解"><img class="relatedPosts_cover" src="https://blog.huhdcc.top/image/hexo/image-20200706175754808.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-07-05</div><div class="relatedPosts_title">多线程高阶-29-AtomicReference详解</div></div></a></div><div class="relatedPosts_item"><a href="/2020/07/06/50648/hub/" title="多线程高阶-30-AtomicStampReference详解"><img class="relatedPosts_cover" src="https://blog.huhdcc.top/image/hexo/image-20200706175842082.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-07-06</div><div class="relatedPosts_title">多线程高阶-30-AtomicStampReference详解</div></div></a></div><div class="relatedPosts_item"><a href="/2020/07/06/56990/hub/" title="多线程高阶-35-AtomicLongFieldUpdater详解"><img class="relatedPosts_cover" src="https://blog.huhdcc.top/image/hexo/image-20200706191044266.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-07-06</div><div class="relatedPosts_title">多线程高阶-35-AtomicLongFieldUpdater详解</div></div></a></div></div><div class="clear_both"></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By sanmeng</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div><div class="footer_custom_text">Hi, welcome to my <a href="https://blog.huhdcc.top/">blog</a>!</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="/js/third-party/fireworks.js"></script><script id="ribbon_piao" mobile="false" src="/js/third-party/piao.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@3/instantpage.min.js" type="module"></script><script src="/js/third-party/click_heart.js"></script><script src="/js/third-party/ClickShowText.js"></script><script src="/js/search/local-search.js"></script><script src="https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@master/Hexo/js/hideCategory.min.js"></script></body></html>