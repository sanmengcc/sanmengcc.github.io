<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>多线程高阶-51-StampedLock详解 | Here will be a new beginning</title><meta name="description" content="StampedLock相关API&amp;emsp;&amp;emsp;StampedLock是在JDK8新增的，主要针对读写锁进行了一些增强，并且支持读写锁之间的转换，更细粒度的控制并发，它的内部也不是基于AQS实现的。支持三种模式：写模式、读模式、乐观读模式（适合读多写少的业务场景）。 类声明1public class StampedLock implements java.io.Serializable"><meta name="keywords" content="JAVA,多线程,源码深入"><meta name="author" content="sanmeng"><meta name="copyright" content="sanmeng"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="dns-prefetch" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://hm.baidu.com"/><link rel="dns-prefetch" href="https://hm.baidu.com"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="dns-prefetch" href="https://fonts.googleapis.com"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="多线程高阶-51-StampedLock详解"><meta name="twitter:description" content="StampedLock相关API&amp;emsp;&amp;emsp;StampedLock是在JDK8新增的，主要针对读写锁进行了一些增强，并且支持读写锁之间的转换，更细粒度的控制并发，它的内部也不是基于AQS实现的。支持三种模式：写模式、读模式、乐观读模式（适合读多写少的业务场景）。 类声明1public class StampedLock implements java.io.Serializable"><meta name="twitter:image" content="https://blog.huhdcc.top/image/hexo/image-20200718131809394.png"><meta property="og:type" content="article"><meta property="og:title" content="多线程高阶-51-StampedLock详解"><meta property="og:url" content="https://blog.huhdcc.top/2020/07/18/50320/hub/"><meta property="og:site_name" content="Here will be a new beginning"><meta property="og:description" content="StampedLock相关API&amp;emsp;&amp;emsp;StampedLock是在JDK8新增的，主要针对读写锁进行了一些增强，并且支持读写锁之间的转换，更细粒度的控制并发，它的内部也不是基于AQS实现的。支持三种模式：写模式、读模式、乐观读模式（适合读多写少的业务场景）。 类声明1public class StampedLock implements java.io.Serializable"><meta property="og:image" content="https://blog.huhdcc.top/image/hexo/image-20200718131809394.png"><meta property="article:published_time" content="2020-07-18T05:16:43.000Z"><meta property="article:modified_time" content="2020-07-18T13:16:24.009Z"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="https://blog.huhdcc.top/2020/07/18/50320/hub/"><link rel="prev" title="多线程高阶-52-ForkJoin详解" href="https://blog.huhdcc.top/2020/07/19/47803/hub/"><link rel="next" title="多线程高阶-50-Condition详解" href="https://blog.huhdcc.top/2020/07/17/39136/hub/"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?5896b35ca19338a74f13168d02db0318";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: {"text":"富强,民主,文明,和谐,自由,平等,公正,法治,爱国,敬业,诚信,友善","fontSize":"15px"},
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@master/Hexo/css/custom.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@master/Hexo/css/hideCategory.min.css"><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="Here will be a new beginning" type="application/atom+xml">
</head><body><canvas class="fireworks"></canvas><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/head.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">77</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">28</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">28</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#StampedLock相关API"><span class="toc-number">1.</span> <span class="toc-text">StampedLock相关API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#类声明"><span class="toc-number">1.1.</span> <span class="toc-text">类声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#构造函数"><span class="toc-number">1.2.</span> <span class="toc-text">构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#方法"><span class="toc-number">1.3.</span> <span class="toc-text">方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#writeLock"><span class="toc-number">1.3.1.</span> <span class="toc-text">writeLock</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#tryWriteLock"><span class="toc-number">1.3.2.</span> <span class="toc-text">tryWriteLock</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#writeLockInterruptibly"><span class="toc-number">1.3.3.</span> <span class="toc-text">writeLockInterruptibly</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#readLock"><span class="toc-number">1.3.4.</span> <span class="toc-text">readLock</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#tryReadLock"><span class="toc-number">1.3.5.</span> <span class="toc-text">tryReadLock</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#tryOptimisticRead"><span class="toc-number">1.3.6.</span> <span class="toc-text">tryOptimisticRead</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#validate"><span class="toc-number">1.3.7.</span> <span class="toc-text">validate</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#unlockWrite"><span class="toc-number">1.3.8.</span> <span class="toc-text">unlockWrite</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#unlockRead"><span class="toc-number">1.3.9.</span> <span class="toc-text">unlockRead</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#unlock"><span class="toc-number">1.3.10.</span> <span class="toc-text">unlock</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#tryConvertToWriteLock"><span class="toc-number">1.3.11.</span> <span class="toc-text">tryConvertToWriteLock</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#tryConvertToReadLock"><span class="toc-number">1.3.12.</span> <span class="toc-text">tryConvertToReadLock</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#tryConvertToOptimisticRead"><span class="toc-number">1.3.13.</span> <span class="toc-text">tryConvertToOptimisticRead</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#tryUnlockWrite"><span class="toc-number">1.3.14.</span> <span class="toc-text">tryUnlockWrite</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#tryUnlockRead"><span class="toc-number">1.3.15.</span> <span class="toc-text">tryUnlockRead</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#isWriteLocked"><span class="toc-number">1.3.16.</span> <span class="toc-text">isWriteLocked</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#isReadLocked"><span class="toc-number">1.3.17.</span> <span class="toc-text">isReadLocked</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#getReadLockCount"><span class="toc-number">1.3.18.</span> <span class="toc-text">getReadLockCount</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#asWriteLock"><span class="toc-number">1.3.19.</span> <span class="toc-text">asWriteLock</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#asReadLock"><span class="toc-number">1.3.20.</span> <span class="toc-text">asReadLock</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#asReadWriteLock"><span class="toc-number">1.3.21.</span> <span class="toc-text">asReadWriteLock</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#案例"><span class="toc-number">2.</span> <span class="toc-text">案例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#悲观读取"><span class="toc-number">2.1.</span> <span class="toc-text">悲观读取</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#乐观读取"><span class="toc-number">2.2.</span> <span class="toc-text">乐观读取</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#部分源码解析"><span class="toc-number">3.</span> <span class="toc-text">部分源码解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#常量"><span class="toc-number">3.1.</span> <span class="toc-text">常量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#成员变量"><span class="toc-number">3.2.</span> <span class="toc-text">成员变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#writeLock-1"><span class="toc-number">3.3.</span> <span class="toc-text">writeLock</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#unlockWrite-1"><span class="toc-number">3.4.</span> <span class="toc-text">unlockWrite</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#readLock-1"><span class="toc-number">3.5.</span> <span class="toc-text">readLock</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#unlockRead-1"><span class="toc-number">3.6.</span> <span class="toc-text">unlockRead</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tryOptimisticRead-1"><span class="toc-number">3.7.</span> <span class="toc-text">tryOptimisticRead</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#validate-1"><span class="toc-number">3.8.</span> <span class="toc-text">validate</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#变异的CLH队列"><span class="toc-number">3.9.</span> <span class="toc-text">变异的CLH队列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#运行示例分析"><span class="toc-number">4.</span> <span class="toc-text">运行示例分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Thread-A-writeLock"><span class="toc-number">4.1.</span> <span class="toc-text">Thread_A(writeLock)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Thread-B-readLock"><span class="toc-number">4.2.</span> <span class="toc-text">Thread_B(readLock)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Thread-C-readLock"><span class="toc-number">4.3.</span> <span class="toc-text">Thread_C(readLock)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Thread-D-writeLock"><span class="toc-number">4.4.</span> <span class="toc-text">Thread_D(writeLock)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Thead-E-readLock"><span class="toc-number">4.5.</span> <span class="toc-text">Thead_E(readLock)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Thread-A-unlockWrite"><span class="toc-number">4.6.</span> <span class="toc-text">Thread_A(unlockWrite)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Thread-B-unlockRead-gt-next"><span class="toc-number">4.7.</span> <span class="toc-text">Thread_B(unlockRead-&gt;next)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Thread-C-unlockRead-gt-next"><span class="toc-number">4.8.</span> <span class="toc-text">Thread_C(unlockRead-&gt;next)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Thread-B和Thread-C释放读锁"><span class="toc-number">4.9.</span> <span class="toc-text">Thread_B和Thread_C释放读锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Thread-D被唤醒后继续向下执行"><span class="toc-number">4.10.</span> <span class="toc-text">Thread_D被唤醒后继续向下执行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Thread-D调用unlockWrite释放写锁"><span class="toc-number">4.11.</span> <span class="toc-text">Thread_D调用unlockWrite释放写锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#总结"><span class="toc-number">4.12.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(https://blog.huhdcc.top/image/hexo/image-20200718131809394.png)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Here will be a new beginning</a></span><span class="pull_right menus"><div id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">多线程高阶-51-StampedLock详解</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-07-18 13:16:43"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-07-18</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-07-18 21:16:24"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-07-18</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/JAVA/">JAVA</a><i class="fa fa-angle-right post-meta__separator" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/JAVA/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a></span></div><div class="meta-secondline"> <span class="post-meta-wordcount"><i class="post-meta__icon fa fa-file-word-o" aria-hidden="true"></i><span>字数总计:</span><span class="word-count">6.2k</span><span class="post-meta__separator">|</span><i class="post-meta__icon fa fa-clock-o" aria-hidden="true"></i><span>阅读时长: 26 分钟</span></span></div><div class="meta-thirdline"><span class="post-meta-pv-cv"></span><span class="post-meta-commentcount"></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><p><img src="/image/hexo/image-20200718131809394.png" alt="image-20200718131809394"></p>
<h2 id="StampedLock相关API"><a href="#StampedLock相关API" class="headerlink" title="StampedLock相关API"></a>StampedLock相关API</h2><p>&emsp;&emsp;<strong>StampedLock</strong>是在JDK8新增的，主要针对<code>读写锁</code>进行了一些增强，并且支持读写锁之间的转换，更细粒度的控制并发，它的内部也不是基于<code>AQS</code>实现的。支持三种模式：<code>写模式</code>、<code>读模式</code>、<code>乐观读模式</code>（适合读多写少的业务场景）。</p>
<h3 id="类声明"><a href="#类声明" class="headerlink" title="类声明"></a>类声明</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StampedLock</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure>

<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造函数</span></span><br><span class="line">StampedLock stampedLock = <span class="keyword">new</span> StampedLock();</span><br></pre></td></tr></table></figure>

<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h4 id="writeLock"><a href="#writeLock" class="headerlink" title="writeLock"></a>writeLock</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//writeLock</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1.获取写入锁</span></span><br><span class="line"><span class="comment"> * 2.获取失败则回阻塞当前线程、直到成功获取锁</span></span><br><span class="line"><span class="comment"> * 3.返回值：可以用来解锁或转换模式的戳记</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">stampedLock.writeLock();</span><br></pre></td></tr></table></figure>

<h4 id="tryWriteLock"><a href="#tryWriteLock" class="headerlink" title="tryWriteLock"></a>tryWriteLock</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//tryWriteLock</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1.没有锁存在的情况下获取写入锁</span></span><br><span class="line"><span class="comment"> * 2.否则返回0</span></span><br><span class="line"><span class="comment"> * 3.可以设置等待超时时间</span></span><br><span class="line"><span class="comment"> * 4.返回值：可以用来解锁或转换模式的戳记</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">stampedLock.tryWriteLock();</span><br><span class="line">stampedLock.tryWriteLock(<span class="number">1</span>, TimeUnit.MILLISECONDS);</span><br></pre></td></tr></table></figure>

<h4 id="writeLockInterruptibly"><a href="#writeLockInterruptibly" class="headerlink" title="writeLockInterruptibly"></a>writeLockInterruptibly</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//writeLockInterruptibly</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1.获取写锁</span></span><br><span class="line"><span class="comment"> * 2.成功返回状态值，失败返回0，或抛出InterruptedException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">stampedLock.writeLockInterruptibly();</span><br></pre></td></tr></table></figure>

<h4 id="readLock"><a href="#readLock" class="headerlink" title="readLock"></a>readLock</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//readLock</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1.获取读取锁（悲观、非独占）</span></span><br><span class="line"><span class="comment"> * 2.获取不到则会陷入阻塞直到成功获取到读取锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">stampedLock.readLock();</span><br></pre></td></tr></table></figure>

<h4 id="tryReadLock"><a href="#tryReadLock" class="headerlink" title="tryReadLock"></a>tryReadLock</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//tryReadLock</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1.立即获得读取锁</span></span><br><span class="line"><span class="comment"> * 2.否则返回0</span></span><br><span class="line"><span class="comment"> * 3.可以设置等待超时时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">stampedLock.tryReadLock();</span><br><span class="line">stampedLock.tryReadLock(<span class="number">1</span>, TimeUnit.MILLISECONDS);</span><br></pre></td></tr></table></figure>

<h4 id="tryOptimisticRead"><a href="#tryOptimisticRead" class="headerlink" title="tryOptimisticRead"></a>tryOptimisticRead</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//tryOptimisticRead</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1.获取乐观读取锁</span></span><br><span class="line"><span class="comment"> * 2.返回邮戳stamp</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">stampedLock.tryOptimisticRead();</span><br></pre></td></tr></table></figure>

<h4 id="validate"><a href="#validate" class="headerlink" title="validate"></a>validate</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//validate</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1.验证邮戳（tryOptimisticRead方法调用前后）有没有写锁占用锁资源</span></span><br><span class="line"><span class="comment"> * 2.占用：返回false</span></span><br><span class="line"><span class="comment"> * 3.未占用：返回true</span></span><br><span class="line"><span class="comment"> * 4.stamp == 0:返回false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">stampedLock.validate(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<h4 id="unlockWrite"><a href="#unlockWrite" class="headerlink" title="unlockWrite"></a>unlockWrite</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//unlockWrite</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1.state和stamp匹配释放写入锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">stampedLock.unlockWrite(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<h4 id="unlockRead"><a href="#unlockRead" class="headerlink" title="unlockRead"></a>unlockRead</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//unlockRead</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1.state和stamp匹配释放读取锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">stampedLock.unlockRead(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<h4 id="unlock"><a href="#unlock" class="headerlink" title="unlock"></a>unlock</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//unlock</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1.state匹配stamp时,释放一个读锁或写锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">stampedLock.unlock(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<h4 id="tryConvertToWriteLock"><a href="#tryConvertToWriteLock" class="headerlink" title="tryConvertToWriteLock"></a>tryConvertToWriteLock</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//tryConvertToWriteLock</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1.进行state匹配stamp</span></span><br><span class="line"><span class="comment"> * 2.stamp如果已经持有写锁，直接返回</span></span><br><span class="line"><span class="comment"> * 3.读模式，但是没有更多的读取者，并返回一个写锁stamp</span></span><br><span class="line"><span class="comment"> * 4.有一个乐观读锁，只在即时可用的前提下返回一个写锁stamp</span></span><br><span class="line"><span class="comment"> * 5.其他情况都返回0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">stampedLock.tryConvertToWriteLock(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<h4 id="tryConvertToReadLock"><a href="#tryConvertToReadLock" class="headerlink" title="tryConvertToReadLock"></a>tryConvertToReadLock</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//tryConvertToReadLock</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1.进行state匹配stamp</span></span><br><span class="line"><span class="comment"> * 2.stamp如果持有写锁，释放写锁，并持有读锁</span></span><br><span class="line"><span class="comment"> * 3.stamp如果表示持有读锁 ，返回该读锁</span></span><br><span class="line"><span class="comment"> * 4.有一个乐观读锁，只在即时可用的前提下返回一个读锁stamp</span></span><br><span class="line"><span class="comment"> * 5.其他情况都返回0，表示失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">stampedLock.tryConvertToReadLock(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<h4 id="tryConvertToOptimisticRead"><a href="#tryConvertToOptimisticRead" class="headerlink" title="tryConvertToOptimisticRead"></a>tryConvertToOptimisticRead</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//tryConvertToOptimisticRead</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1.将其他锁转换为乐观锁</span></span><br><span class="line"><span class="comment"> * 2.stamp如果持有读或写锁，则直接释放读写锁</span></span><br><span class="line"><span class="comment"> * 3.stamp如果持有乐观锁，若乐观锁stamp有效，则返回观察者stamp</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">stampedLock.tryConvertToOptimisticRead(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<h4 id="tryUnlockWrite"><a href="#tryUnlockWrite" class="headerlink" title="tryUnlockWrite"></a>tryUnlockWrite</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//tryUnlockWrite</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1.如果持有写锁，释放写锁</span></span><br><span class="line"><span class="comment"> * 2.可以用于发生错误后的恢复</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">stampedLock.tryUnlockWrite();</span><br></pre></td></tr></table></figure>

<h4 id="tryUnlockRead"><a href="#tryUnlockRead" class="headerlink" title="tryUnlockRead"></a>tryUnlockRead</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//tryUnlockRead</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1.如果持有读锁，释放读锁</span></span><br><span class="line"><span class="comment"> * 2.可以用于发生错误后的恢复</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">stampedLock.tryUnlockRead();</span><br></pre></td></tr></table></figure>

<h4 id="isWriteLocked"><a href="#isWriteLocked" class="headerlink" title="isWriteLocked"></a>isWriteLocked</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//isWriteLocked</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1.持有写锁返回true</span></span><br><span class="line"><span class="comment"> * 2.不持有返回false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">System.out.println(stampedLock.isWriteLocked());</span><br></pre></td></tr></table></figure>

<h4 id="isReadLocked"><a href="#isReadLocked" class="headerlink" title="isReadLocked"></a>isReadLocked</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//isReadLocked</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1.持有读锁返回true</span></span><br><span class="line"><span class="comment"> * 2.不持有返回false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">System.out.println(stampedLock.isReadLocked());</span><br></pre></td></tr></table></figure>

<h4 id="getReadLockCount"><a href="#getReadLockCount" class="headerlink" title="getReadLockCount"></a>getReadLockCount</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//getReadLockCount</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1.返回持有读锁的线程数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">System.out.println(stampedLock.getReadLockCount());</span><br></pre></td></tr></table></figure>

<h4 id="asWriteLock"><a href="#asWriteLock" class="headerlink" title="asWriteLock"></a>asWriteLock</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//asWriteLock</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1.返回一个WriteLock视图</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">stampedLock.asWriteLock();</span><br></pre></td></tr></table></figure>

<h4 id="asReadLock"><a href="#asReadLock" class="headerlink" title="asReadLock"></a>asReadLock</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//asReadLock</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1.返回一个ReadLock视图</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">stampedLock.asReadLock();</span><br></pre></td></tr></table></figure>

<h4 id="asReadWriteLock"><a href="#asReadWriteLock" class="headerlink" title="asReadWriteLock"></a>asReadWriteLock</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//asReadWriteLock</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1.返回一个ReadWriteLock视图</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">stampedLock.asReadWriteLock();</span><br></pre></td></tr></table></figure>



<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><h3 id="悲观读取"><a href="#悲观读取" class="headerlink" title="悲观读取"></a>悲观读取</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StampedLockTest1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> StampedLock stampedLock = <span class="keyword">new</span> StampedLock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> List&lt;Long&gt; DATA = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ExecutorService executor = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        Runnable read = () -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (; ; ) &#123;read();&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Runnable write = () -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (; ; ) &#123;write();&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        executor.submit(read);</span><br><span class="line">        executor.submit(read);</span><br><span class="line">        executor.submit(read);</span><br><span class="line">        executor.submit(read);</span><br><span class="line">        executor.submit(read);</span><br><span class="line">        executor.submit(read);</span><br><span class="line">        executor.submit(read);</span><br><span class="line">        executor.submit(read);</span><br><span class="line">        executor.submit(read);</span><br><span class="line"></span><br><span class="line">        executor.submit(write);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> stamped = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            stamped = stampedLock.writeLock();</span><br><span class="line">            <span class="keyword">long</span> value = System.currentTimeMillis();</span><br><span class="line">            System.out.println(<span class="string">"The Thread:"</span> + Thread.currentThread().getName() + <span class="string">" write value:"</span> + value);</span><br><span class="line">            DATA.add(value);</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            stampedLock.unlockWrite(stamped);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> stamped = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            stamped = stampedLock.readLock();</span><br><span class="line">            Optional.of(DATA.stream()</span><br><span class="line">                    .map(String::valueOf)</span><br><span class="line">                    .collect(Collectors.joining(<span class="string">"#"</span>, <span class="string">"R-"</span>, <span class="string">""</span>)))</span><br><span class="line">                    .ifPresent(System.out::println);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            stampedLock.unlockRead(stamped);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="乐观读取"><a href="#乐观读取" class="headerlink" title="乐观读取"></a>乐观读取</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StampedLockTest2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> StampedLock stampedLock = <span class="keyword">new</span> StampedLock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> List&lt;Long&gt; DATA = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Runnable read = () -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">                read();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Runnable write = () -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">                write();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        IntStream.range(<span class="number">0</span>, <span class="number">1</span>).boxed().forEach(i -&gt; <span class="keyword">new</span> Thread(write).start());</span><br><span class="line">        IntStream.range(<span class="number">0</span>, <span class="number">200</span>).boxed().forEach(i -&gt; <span class="keyword">new</span> Thread(read).start());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> stamped = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            stamped = stampedLock.writeLock();</span><br><span class="line">            <span class="keyword">long</span> value = System.currentTimeMillis();</span><br><span class="line">            System.out.println(<span class="string">"The Thread:"</span> + Thread.currentThread().getName() + <span class="string">" write value:"</span> + value);</span><br><span class="line">            DATA.add(value);</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            stampedLock.unlockWrite(stamped);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> stamp = stampedLock.tryOptimisticRead();</span><br><span class="line">        <span class="keyword">if</span> (stampedLock.validate(stamp)) &#123;</span><br><span class="line">            <span class="keyword">long</span> stamped = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                stamped = stampedLock.readLock();</span><br><span class="line">                System.out.println(<span class="string">"stamped："</span> + stamped);</span><br><span class="line">                Optional.of(DATA.stream()</span><br><span class="line">                        .map(String::valueOf)</span><br><span class="line">                        .collect(Collectors.joining(<span class="string">"#"</span>, <span class="string">"R-"</span>, <span class="string">""</span>)))</span><br><span class="line">                        .ifPresent(System.out::println);</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                stampedLock.unlock(stamped);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="部分源码解析"><a href="#部分源码解析" class="headerlink" title="部分源码解析"></a>部分源码解析</h2><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取服务器CPU核数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NCPU = Runtime.getRuntime().availableProcessors();</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程入队列前自旋次数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SPINS = (NCPU &gt; <span class="number">1</span>) ? <span class="number">1</span> &lt;&lt; <span class="number">6</span> : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//队列头结点自旋获取锁最大失败次数后再次进入队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HEAD_SPINS = (NCPU &gt; <span class="number">1</span>) ? <span class="number">1</span> &lt;&lt; <span class="number">10</span> : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Maximum number of retries before re-blocking */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_HEAD_SPINS = (NCPU &gt; <span class="number">1</span>) ? <span class="number">1</span> &lt;&lt; <span class="number">16</span> : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** The period for yielding when waiting for overflow spinlock */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OVERFLOW_YIELD_RATE = <span class="number">7</span>; <span class="comment">// must be power 2 - 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** The number of bits to use for reader count before overflowing */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LG_READERS = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Values for lock state and stamp operations</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> RUNIT = <span class="number">1L</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> WBIT  = <span class="number">1L</span> &lt;&lt; LG_READERS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> RBITS = WBIT - <span class="number">1L</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> RFULL = RBITS - <span class="number">1L</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> ABITS = RBITS | WBIT;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> SBITS = ~RBITS; <span class="comment">// note overlap with ABITS</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//锁state初始值，第9位为1，避免算术时和0冲突</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> ORIGIN = WBIT &lt;&lt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Special value from cancelled acquire methods so caller can throw IE</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> INTERRUPTED = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Values for node status; order matters</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WAITING   = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Modes for nodes (int not boolean to allow arithmetic)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RMODE = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WMODE = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//标识状态的含义</span></span><br><span class="line">RUNIT: == <span class="number">1</span>，更新读锁状态会用到的常量，<span class="string">"next = s + RUNIT"</span>一个新线程获取获取到了读锁那么state将增加<span class="number">1</span>.</span><br><span class="line"></span><br><span class="line">ABITS:== <span class="number">255</span>，计算写锁状态时会用到的常量，位运算<span class="string">"((s = state) &amp; ABITS)"</span>来取state的低<span class="number">8</span>位。</span><br><span class="line"></span><br><span class="line">WBIT:== <span class="number">123</span>，更新写锁状态会用到的常量，<span class="string">"next = s + WBIT"</span>一个线程获取到写锁就将state属性加<span class="number">128</span>。</span><br><span class="line"></span><br><span class="line">RBITS:== <span class="number">127</span>，计算读锁状态会到的常量，<span class="string">"s &amp; RBITS"</span>用来取state的低<span class="number">7</span>位。</span><br><span class="line"></span><br><span class="line">RFULL:== <span class="number">126</span>，获取到读锁的最大线程数，<span class="string">"(readers = s &amp; RBITS) &gt;= RFULL"</span>。</span><br><span class="line"></span><br><span class="line">SBITS:计算写锁变化量会用到的常量，<span class="string">"(s &amp; SBITS)"</span>将s的低<span class="number">7</span>位全部置<span class="number">0</span>，只关注s的高<span class="number">25</span>位。</span><br><span class="line"></span><br><span class="line">ORIGIN:state的初始值，二进制形式只有第<span class="number">9</span>位为<span class="number">1</span>，其他位全为<span class="number">0</span>。主要是不让statet等于<span class="number">0</span>，只有尝试获取锁失败时，state才能为<span class="number">0</span>.</span><br><span class="line">state:<span class="number">1</span>表示持有写锁，<span class="number">0</span>表示没持有写锁</span><br></pre></td></tr></table></figure>

<h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//等待队列头节点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> WNode whead; </span><br><span class="line"><span class="comment">//等待队列尾节点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> WNode wtail; </span><br><span class="line"></span><br><span class="line"><span class="comment">//读锁视图</span></span><br><span class="line"><span class="keyword">transient</span> ReadLockView readLockView; </span><br><span class="line"><span class="comment">//写锁视图</span></span><br><span class="line"><span class="keyword">transient</span> WriteLockView writeLockView;</span><br><span class="line"><span class="comment">//读写锁视图</span></span><br><span class="line"><span class="keyword">transient</span> ReadWriteLockView readWriteLockView;</span><br><span class="line"></span><br><span class="line"><span class="comment">//锁状态</span></span><br><span class="line"><span class="comment">//高24位存储版本号、低7位存储读锁被获取的次数、第8位存储写锁被获取的次数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">long</span> state; </span><br><span class="line"><span class="comment">//读锁线程数超过RFULL时，额外记录超出的的线程数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> readerOverflow;</span><br></pre></td></tr></table></figure>

<h3 id="writeLock-1"><a href="#writeLock-1" class="headerlink" title="writeLock"></a>writeLock</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取写入锁、失败会陷入阻塞、直到获取锁成功</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">writeLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> s, next;</span><br><span class="line">    <span class="comment">// ABITS = 255 = 1111 1111</span></span><br><span class="line">    <span class="comment">// WBITS = 128 = 1000 0000</span></span><br><span class="line">    <span class="comment">//如果stat和ABITS==0，进行cas更新state=state+WBIT</span></span><br><span class="line">    <span class="comment">//更新成功则返回更新后的值</span></span><br><span class="line">    <span class="comment">//更新失败进入acquireWrite</span></span><br><span class="line">    <span class="keyword">return</span> ((((s = state) &amp; ABITS) == <span class="number">0L</span> &amp;&amp;</span><br><span class="line">             U.compareAndSwapLong(<span class="keyword">this</span>, STATE, s, next = s + WBIT)) ?</span><br><span class="line">            next : acquireWrite(<span class="keyword">false</span>, <span class="number">0L</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">acquireWrite</span><span class="params">(<span class="keyword">boolean</span> interruptible, <span class="keyword">long</span> deadline)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//node新增节点、p尾节点</span></span><br><span class="line">    WNode node = <span class="keyword">null</span>, p;</span><br><span class="line">    <span class="comment">//开始进行第一次自旋</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> spins = -<span class="number">1</span>;;) </span><br><span class="line">        <span class="keyword">long</span> m, s, ns;</span><br><span class="line">    	<span class="comment">//尝试获取锁</span></span><br><span class="line">        <span class="keyword">if</span> ((m = (s = state) &amp; ABITS) == <span class="number">0L</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapLong(<span class="keyword">this</span>, STATE, s, ns = s + WBIT))</span><br><span class="line">                <span class="keyword">return</span> ns;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (spins &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//1.自旋次数&lt;0 计算自旋次数</span></span><br><span class="line">            <span class="comment">//2.有写锁并且队列中没有元素，那么代表快轮到自己了，接着自旋</span></span><br><span class="line">            <span class="comment">//3.自旋完了还没轮到则入队操作</span></span><br><span class="line">            <span class="comment">//4.自旋次数尾SPINS常量、否则为0</span></span><br><span class="line">            spins = (m == WBIT &amp;&amp; wtail == whead) ? SPINS : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (spins &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//若是自旋次数&gt;0，当前自旋次数-1</span></span><br><span class="line">            <span class="keyword">if</span> (LockSupport.nextSecondarySeed() &gt;= <span class="number">0</span>)</span><br><span class="line">                --spins;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((p = wtail) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果队列未进行初始化操作</span></span><br><span class="line">            <span class="comment">//新建一个Node节点</span></span><br><span class="line">            WNode hd = <span class="keyword">new</span> WNode(WMODE, <span class="keyword">null</span>);</span><br><span class="line">            <span class="comment">//初始化头部和尾部节点</span></span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapObject(<span class="keyword">this</span>, WHEAD, <span class="keyword">null</span>, hd))</span><br><span class="line">                wtail = hd;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">//如果新增节点没有初始化、构建一个新增节点并且它的前置节点是尾节点</span></span><br><span class="line">            node = <span class="keyword">new</span> WNode(WMODE, p);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (node.prev != p)</span><br><span class="line">            <span class="comment">//如果尾节点发生变化、则需要更新新增节点的前置节点尾新的尾节点</span></span><br><span class="line">            node.prev = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapObject(<span class="keyword">this</span>, WTAIL, p, node)) &#123;</span><br><span class="line">            <span class="comment">//CAS尝试更新新的尾节点、并且退出循环</span></span><br><span class="line">            p.next = node;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//进入第二次自旋操作</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> spins = -<span class="number">1</span>;;) &#123;</span><br><span class="line">        <span class="comment">//h:头部节点</span></span><br><span class="line">        <span class="comment">//np:新增节点的前置节点</span></span><br><span class="line">        <span class="comment">//pp:前前置节点</span></span><br><span class="line">        <span class="comment">//ps:前置节点的状态</span></span><br><span class="line">        WNode h, np, pp; <span class="keyword">int</span> ps;</span><br><span class="line">        <span class="comment">//如果头部节点 == 前置节点（快轮到自己了）</span></span><br><span class="line">        <span class="keyword">if</span> ((h = whead) == p) &#123;</span><br><span class="line">            <span class="keyword">if</span> (spins &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="comment">//自旋次数&lt;0，初始化自旋次数</span></span><br><span class="line">                spins = HEAD_SPINS;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (spins &lt; MAX_HEAD_SPINS)</span><br><span class="line">                <span class="comment">//增加自旋次数（自旋次数&lt;最大自旋次数）</span></span><br><span class="line">                spins &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//开始第三次自旋、不断尝试获取锁</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = spins;;) &#123;</span><br><span class="line">                <span class="keyword">long</span> s, ns;</span><br><span class="line">                <span class="keyword">if</span> (((s = state) &amp; ABITS) == <span class="number">0L</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (U.compareAndSwapLong(<span class="keyword">this</span>, STATE, s,</span><br><span class="line">                                             ns = s + WBIT)) &#123;</span><br><span class="line">                        <span class="comment">//获取锁成功，设置node为新头部节点</span></span><br><span class="line">                        whead = node;</span><br><span class="line">                        <span class="comment">//清除前置节点gc</span></span><br><span class="line">                        node.prev = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">return</span> ns;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//随机立减自旋次数、如果自旋次数减为0跳出循环再次重试</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (LockSupport.nextSecondarySeed() &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">                         --k &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (h != <span class="keyword">null</span>) &#123; </span><br><span class="line">            <span class="comment">//一般情况很少会触发该逻辑</span></span><br><span class="line">            <span class="comment">//主要用于协助唤醒读节点</span></span><br><span class="line">            WNode c; Thread w;</span><br><span class="line">            <span class="comment">//如果头节点的cowait不为空、则唤醒里面的所有节点</span></span><br><span class="line">            <span class="keyword">while</span> ((c = h.cowait) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapObject(h, WCOWAIT, c, c.cowait) &amp;&amp;</span><br><span class="line">                    (w = c.thread) != <span class="keyword">null</span>)</span><br><span class="line">                    U.unpark(w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果头部节点没有发生变化</span></span><br><span class="line">        <span class="keyword">if</span> (whead == h) &#123;</span><br><span class="line">            <span class="comment">//尾部节点发生变化、进行更新操作</span></span><br><span class="line">            <span class="keyword">if</span> ((np = node.prev) != p) &#123;</span><br><span class="line">                <span class="keyword">if</span> (np != <span class="keyword">null</span>)</span><br><span class="line">                    (p = np).next = node;   <span class="comment">// stale</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((ps = p.status) == <span class="number">0</span>)</span><br><span class="line">                <span class="comment">//如果尾部节点的状态为0，更新为WAITING</span></span><br><span class="line">                U.compareAndSwapInt(p, WSTATUS, <span class="number">0</span>, WAITING);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ps == CANCELLED) &#123;</span><br><span class="line">                <span class="comment">//如果尾部节点的状态为CANCELLED，则从链表中删除</span></span><br><span class="line">                <span class="keyword">if</span> ((pp = p.prev) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    node.prev = pp;</span><br><span class="line">                    pp.next = node;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//超时时间处理</span></span><br><span class="line">                <span class="keyword">long</span> time; </span><br><span class="line">                <span class="keyword">if</span> (deadline == <span class="number">0L</span>)</span><br><span class="line">                    time = <span class="number">0L</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((time = deadline - System.nanoTime()) &lt;= <span class="number">0L</span>)</span><br><span class="line">                    <span class="comment">//超时、剔除当前节点</span></span><br><span class="line">                    <span class="keyword">return</span> cancelWaiter(node, node, <span class="keyword">false</span>);</span><br><span class="line">                <span class="comment">//获取当前线程</span></span><br><span class="line">                Thread wt = Thread.currentThread();</span><br><span class="line">                U.putObject(wt, PARKBLOCKER, <span class="keyword">this</span>);</span><br><span class="line">                <span class="comment">//将node的线程指向了当前的线程</span></span><br><span class="line">                node.thread = wt;</span><br><span class="line">                <span class="keyword">if</span> (p.status &lt; <span class="number">0</span> &amp;&amp; (p != h || (state &amp; ABITS) != <span class="number">0L</span>) &amp;&amp;</span><br><span class="line">                    whead == h &amp;&amp; node.prev == p)</span><br><span class="line">                    <span class="comment">//阻塞当前线程</span></span><br><span class="line">                    U.park(<span class="keyword">false</span>, time);  <span class="comment">// emulate LockSupport.park</span></span><br><span class="line">                <span class="comment">//节点唤醒后、清除线程</span></span><br><span class="line">                node.thread = <span class="keyword">null</span>;</span><br><span class="line">                U.putObject(wt, PARKBLOCKER, <span class="keyword">null</span>);</span><br><span class="line">                <span class="comment">//如果线程被中断、则取消当前节点</span></span><br><span class="line">                <span class="keyword">if</span> (interruptible &amp;&amp; Thread.interrupted())</span><br><span class="line">                    <span class="keyword">return</span> cancelWaiter(node, node, <span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;1.第一次自旋操作：(入队操作)</p>
<p>&emsp;&emsp;&emsp;&emsp;(1)头节点 == 尾节点，说明此时没有其他的线程进行排队，那么进行自旋、尝试性的获取锁。</p>
<p>&emsp;&emsp;&emsp;&emsp;(2)否则：自旋次数 == 0，直接进行入队操作。</p>
<p>&emsp;&emsp;2.第二、三次自旋操作：（阻塞并且等待被唤醒、第三次自旋目的在于不断尝试获取锁）</p>
<p>&emsp;&emsp;&emsp;&emsp;(1)头节点 == 前置节点，进入第三次自旋（处于第二次自旋的内部），尝试获取锁。</p>
<p>&emsp;&emsp;&emsp;&emsp;(2)否则：尝试唤醒头节点中等待的读线程</p>
<p>&emsp;&emsp;&emsp;&emsp;(3)如果线程一直不能获取到锁、则阻塞当前线程。</p>
<h3 id="unlockWrite-1"><a href="#unlockWrite-1" class="headerlink" title="unlockWrite"></a>unlockWrite</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlockWrite</span><span class="params">(<span class="keyword">long</span> stamp)</span> </span>&#123;</span><br><span class="line">    WNode h;</span><br><span class="line">    <span class="comment">//检测版本号</span></span><br><span class="line">    <span class="keyword">if</span> (state != stamp || (stamp &amp; WBIT) == <span class="number">0L</span>)</span><br><span class="line">        <span class="comment">//抛出异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="comment">//1.更新版本号</span></span><br><span class="line">    <span class="comment">//2.释放写入锁</span></span><br><span class="line">    state = (stamp += WBIT) == <span class="number">0L</span> ? ORIGIN : stamp;</span><br><span class="line">    <span class="comment">//如果头节点不为空并且状态不为0、release唤醒下一个节点</span></span><br><span class="line">    <span class="keyword">if</span> ((h = whead) != <span class="keyword">null</span> &amp;&amp; h.status != <span class="number">0</span>)</span><br><span class="line">        release(h);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">(WNode h)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (h != <span class="keyword">null</span>) &#123;</span><br><span class="line">        WNode q; Thread w;</span><br><span class="line">        <span class="comment">//设置状态为0</span></span><br><span class="line">        U.compareAndSwapInt(h, WSTATUS, WAITING, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">//如果头节点的下一个节点为空或其状态为CANCELLED</span></span><br><span class="line">        <span class="keyword">if</span> ((q = h.next) == <span class="keyword">null</span> || q.status == CANCELLED) &#123;</span><br><span class="line">            <span class="comment">//从尾部往前进行遍历寻找一个可用的节点</span></span><br><span class="line">            <span class="keyword">for</span> (WNode t = wtail; t != <span class="keyword">null</span> &amp;&amp; t != h; t = t.prev)</span><br><span class="line">                <span class="keyword">if</span> (t.status &lt;= <span class="number">0</span>)</span><br><span class="line">                    q = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//唤醒q处节点的线程</span></span><br><span class="line">        <span class="keyword">if</span> (q != <span class="keyword">null</span> &amp;&amp; (w = q.thread) != <span class="keyword">null</span>)</span><br><span class="line">            U.unpark(w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;1.更新<code>state</code>的值、释放写入锁</p>
<p>&emsp;&emsp;2.版本号+1</p>
<p>&emsp;&emsp;3.唤醒下一个等待的节点</p>
<h3 id="readLock-1"><a href="#readLock-1" class="headerlink" title="readLock"></a>readLock</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">readLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> s = state, next;</span><br><span class="line">    <span class="comment">//1.如果写入锁被占用、并且读取所得获取次数并没有达到最大值</span></span><br><span class="line">    <span class="comment">//2.cas尝试更新读取锁被获取的次数+1</span></span><br><span class="line">    <span class="comment">//3.如果更新成功则返回、否则进入acquireRead方法</span></span><br><span class="line">    <span class="keyword">return</span> ((whead == wtail &amp;&amp; (s &amp; ABITS) &lt; RFULL &amp;&amp;</span><br><span class="line">             U.compareAndSwapLong(<span class="keyword">this</span>, STATE, s, next = s + RUNIT)) ?</span><br><span class="line">            next : acquireRead(<span class="keyword">false</span>, <span class="number">0L</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">acquireRead</span><span class="params">(<span class="keyword">boolean</span> interruptible, <span class="keyword">long</span> deadline)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//node:为新增节点</span></span><br><span class="line">    <span class="comment">//p:尾节点</span></span><br><span class="line">    WNode node = <span class="keyword">null</span>, p;</span><br><span class="line">    <span class="comment">//第一次自旋</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> spins = -<span class="number">1</span>;;) &#123;</span><br><span class="line">        <span class="comment">//头节点</span></span><br><span class="line">        WNode h;</span><br><span class="line">        <span class="comment">//如果头节点 == 尾节点、没有排队的线程、尝试自旋获取锁</span></span><br><span class="line">        <span class="keyword">if</span> ((h = whead) == (p = wtail)) &#123;</span><br><span class="line">            <span class="comment">//第二次自旋操作</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">long</span> m, s, ns;;) &#123;</span><br><span class="line">                <span class="comment">//尝试获取锁、成功则返回版本号ns</span></span><br><span class="line">                <span class="keyword">if</span> ((m = (s = state) &amp; ABITS) &lt; RFULL ?</span><br><span class="line">                    U.compareAndSwapLong(<span class="keyword">this</span>, STATE, s, ns = s + RUNIT) :</span><br><span class="line">                    (m &lt; WBIT &amp;&amp; (ns = tryIncReaderOverflow(s)) != <span class="number">0L</span>))</span><br><span class="line">                    <span class="comment">//如果读线程个数达到了最大值、会造成溢出返回0</span></span><br><span class="line">                    <span class="keyword">return</span> ns;</span><br><span class="line">                <span class="comment">//表示有其他的线程先行一步获取到了写入锁</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (m &gt;= WBIT) &#123;</span><br><span class="line">                    <span class="comment">//自旋数&gt;0则进行自旋数-1</span></span><br><span class="line">                    <span class="keyword">if</span> (spins &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (LockSupport.nextSecondarySeed() &gt;= <span class="number">0</span>)</span><br><span class="line">                            --spins;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">//如果自旋数 == 0 、检验是否退出循环</span></span><br><span class="line">                        <span class="keyword">if</span> (spins == <span class="number">0</span>) &#123;</span><br><span class="line">                            WNode nh = whead, np = wtail;</span><br><span class="line">                            <span class="keyword">if</span> ((nh == h &amp;&amp; np == p) || (h = nh) != (p = np))</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//更新自旋数</span></span><br><span class="line">                        spins = SPINS;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果尾节点为空、进行初始化头部和尾部节点操作</span></span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span>) &#123; <span class="comment">// initialize queue</span></span><br><span class="line">            WNode hd = <span class="keyword">new</span> WNode(WMODE, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapObject(<span class="keyword">this</span>, WHEAD, <span class="keyword">null</span>, hd))</span><br><span class="line">                wtail = hd;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">//如果新增新增节点为空、进行初始化操作</span></span><br><span class="line">            node = <span class="keyword">new</span> WNode(RMODE, p);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (h == p || p.mode != RMODE) &#123;</span><br><span class="line">            <span class="comment">//如果头节点 == 尾节点 或者 尾节点不是读取模式</span></span><br><span class="line">            <span class="comment">//当前节点入队</span></span><br><span class="line">            <span class="keyword">if</span> (node.prev != p)</span><br><span class="line">                node.prev = p;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapObject(<span class="keyword">this</span>, WTAIL, p, node)) &#123;</span><br><span class="line">                p.next = node;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!U.compareAndSwapObject(p, WCOWAIT,</span><br><span class="line">                                         node.cowait = p.cowait, node))</span><br><span class="line">            <span class="comment">//尾节点尾读模式当前节点加入尾节点的cowait</span></span><br><span class="line">            node.cowait = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//开始第三段自旋</span></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                WNode pp, c; Thread w;</span><br><span class="line">                <span class="comment">//头节点不为空并且cowait不为空、唤醒其中等待的读线程</span></span><br><span class="line">                <span class="keyword">if</span> ((h = whead) != <span class="keyword">null</span> &amp;&amp; (c = h.cowait) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                    U.compareAndSwapObject(h, WCOWAIT, c, c.cowait) &amp;&amp;</span><br><span class="line">                    (w = c.thread) != <span class="keyword">null</span>) <span class="comment">// help release</span></span><br><span class="line">                    U.unpark(w);</span><br><span class="line">                <span class="comment">//头部节点的前置节点或者前置节点或者前置节点为空</span></span><br><span class="line">                <span class="keyword">if</span> (h == (pp = p.prev) || h == p || pp == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">long</span> m, s, ns;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        <span class="comment">//开启第四段自旋</span></span><br><span class="line">                        <span class="keyword">if</span> ((m = (s = state) &amp; ABITS) &lt; RFULL ?</span><br><span class="line">                            U.compareAndSwapLong(<span class="keyword">this</span>, STATE, s,</span><br><span class="line">                                                 ns = s + RUNIT) :</span><br><span class="line">                            (m &lt; WBIT &amp;&amp;</span><br><span class="line">                             (ns = tryIncReaderOverflow(s)) != <span class="number">0L</span>))</span><br><span class="line">                            <span class="keyword">return</span> ns;</span><br><span class="line">                        <span class="comment">//只有当前时刻没有其他线程占有写入锁就不断尝试</span></span><br><span class="line">                    &#125; <span class="keyword">while</span> (m &lt; WBIT);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果头部节点未曾改变且前前置节点为没发生改变、阻塞当前线程</span></span><br><span class="line">                <span class="keyword">if</span> (whead == h &amp;&amp; p.prev == pp) &#123;</span><br><span class="line">                    <span class="keyword">long</span> time;</span><br><span class="line">                    <span class="comment">//如果前前置节点为空、或者头节点 == 前置节点、或者前置节点已经取消</span></span><br><span class="line">                    <span class="comment">//进入第一个for开始重试</span></span><br><span class="line">                    <span class="keyword">if</span> (pp == <span class="keyword">null</span> || h == p || p.status &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        node = <span class="keyword">null</span>; <span class="comment">// throw away</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//超时检测机制</span></span><br><span class="line">                    <span class="keyword">if</span> (deadline == <span class="number">0L</span>)</span><br><span class="line">                        time = <span class="number">0L</span>;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> ((time = deadline - System.nanoTime()) &lt;= <span class="number">0L</span>)</span><br><span class="line">                        <span class="comment">//超时：取消当前节点</span></span><br><span class="line">                        <span class="keyword">return</span> cancelWaiter(node, p, <span class="keyword">false</span>);</span><br><span class="line">                    <span class="comment">//获取当前节点</span></span><br><span class="line">                    Thread wt = Thread.currentThread();</span><br><span class="line">                    U.putObject(wt, PARKBLOCKER, <span class="keyword">this</span>);</span><br><span class="line">                    <span class="comment">//将nede的线程指向当前线程</span></span><br><span class="line">                    node.thread = wt;</span><br><span class="line">                    <span class="comment">//检测之前的条件没有发生改变</span></span><br><span class="line">                    <span class="keyword">if</span> ((h != pp || (state &amp; ABITS) == WBIT) &amp;&amp;</span><br><span class="line">                        whead == h &amp;&amp; p.prev == pp)</span><br><span class="line">                        <span class="comment">//阻塞当前线程</span></span><br><span class="line">                        U.park(<span class="keyword">false</span>, time);</span><br><span class="line">                    <span class="comment">//唤醒线程并清除线程</span></span><br><span class="line">                    node.thread = <span class="keyword">null</span>;</span><br><span class="line">        			U.putObject(wt, PARKBLOCKER, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">//线程中断取消当前节点</span></span><br><span class="line">                    <span class="keyword">if</span> (interruptible &amp;&amp; Thread.interrupted())</span><br><span class="line">                        <span class="keyword">return</span> cancelWaiter(node, p, <span class="keyword">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//开启第五次自旋（只有第一个读线程才会走到这里）单独有一个自旋针对第一个读的线程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> spins = -<span class="number">1</span>;;) &#123;</span><br><span class="line">        WNode h, np, pp; <span class="keyword">int</span> ps;</span><br><span class="line">        <span class="comment">//如果头节点 == 尾节点（快轮到自己了）</span></span><br><span class="line">        <span class="keyword">if</span> ((h = whead) == p) &#123;</span><br><span class="line">            <span class="keyword">if</span> (spins &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="comment">//自旋次数&lt;0,设置自旋次数</span></span><br><span class="line">                spins = HEAD_SPINS;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (spins &lt; MAX_HEAD_SPINS)</span><br><span class="line">                <span class="comment">//自旋次数初始化完成后-1</span></span><br><span class="line">                spins &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//开始第六次自旋</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = spins;;) &#123; <span class="comment">// spin at head</span></span><br><span class="line">                <span class="keyword">long</span> m, s, ns;</span><br><span class="line">                <span class="comment">//不断的尝试获取锁</span></span><br><span class="line">                <span class="keyword">if</span> ((m = (s = state) &amp; ABITS) &lt; RFULL ?</span><br><span class="line">                    U.compareAndSwapLong(<span class="keyword">this</span>, STATE, s, ns = s + RUNIT) :</span><br><span class="line">                    (m &lt; WBIT &amp;&amp; (ns = tryIncReaderOverflow(s)) != <span class="number">0L</span>)) &#123;</span><br><span class="line">                    <span class="comment">//获取到了读取锁</span></span><br><span class="line">                    WNode c; Thread w;</span><br><span class="line">                    whead = node;</span><br><span class="line">                    node.prev = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="comment">//唤醒当前节点中所有的等待的读线程</span></span><br><span class="line">                    <span class="comment">//当前节点是第一个读的节点、其他的读节点都是挂在当前节点的cowait中</span></span><br><span class="line">                    <span class="keyword">while</span> ((c = node.cowait) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (U.compareAndSwapObject(node, WCOWAIT,</span><br><span class="line">                                                   c, c.cowait) &amp;&amp;</span><br><span class="line">                            (w = c.thread) != <span class="keyword">null</span>)</span><br><span class="line">                            U.unpark(w);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//返回版本号</span></span><br><span class="line">                    <span class="keyword">return</span> ns;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果当前有其他线程占有了写入锁、并且没有自旋次数、跳出循环</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (m &gt;= WBIT &amp;&amp;</span><br><span class="line">                         LockSupport.nextSecondarySeed() &gt;= <span class="number">0</span> &amp;&amp; --k &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (h != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">//如果头节点不等于尾部节点不为空并且其为读取模式、唤醒里面的读线程</span></span><br><span class="line">            WNode c; Thread w;</span><br><span class="line">            <span class="keyword">while</span> ((c = h.cowait) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapObject(h, WCOWAIT, c, c.cowait) &amp;&amp;</span><br><span class="line">                    (w = c.thread) != <span class="keyword">null</span>)</span><br><span class="line">                    U.unpark(w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//头节点没有发生变化</span></span><br><span class="line">        <span class="keyword">if</span> (whead == h) &#123;</span><br><span class="line">            <span class="comment">//更新前置节点以及状态</span></span><br><span class="line">            <span class="keyword">if</span> ((np = node.prev) != p) &#123;</span><br><span class="line">                <span class="keyword">if</span> (np != <span class="keyword">null</span>)</span><br><span class="line">                    (p = np).next = node;   <span class="comment">// stale</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((ps = p.status) == <span class="number">0</span>)</span><br><span class="line">                U.compareAndSwapInt(p, WSTATUS, <span class="number">0</span>, WAITING);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ps == CANCELLED) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((pp = p.prev) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    node.prev = pp;</span><br><span class="line">                    pp.next = node;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//第一个节点即将开始进入阻塞</span></span><br><span class="line">                <span class="keyword">long</span> time;</span><br><span class="line">                <span class="comment">//设置超时</span></span><br><span class="line">                <span class="keyword">if</span> (deadline == <span class="number">0L</span>)</span><br><span class="line">                    time = <span class="number">0L</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((time = deadline - System.nanoTime()) &lt;= <span class="number">0L</span>)</span><br><span class="line">                    <span class="comment">//超时则取消当前节点</span></span><br><span class="line">                    <span class="keyword">return</span> cancelWaiter(node, node, <span class="keyword">false</span>);</span><br><span class="line">                Thread wt = Thread.currentThread();</span><br><span class="line">                U.putObject(wt, PARKBLOCKER, <span class="keyword">this</span>);</span><br><span class="line">                node.thread = wt;</span><br><span class="line">                <span class="keyword">if</span> (p.status &lt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">                    (p != h || (state &amp; ABITS) == WBIT) &amp;&amp;</span><br><span class="line">                    whead == h &amp;&amp; node.prev == p)</span><br><span class="line">                    <span class="comment">//阻塞第一个线程并等待被唤醒</span></span><br><span class="line">                    U.park(<span class="keyword">false</span>, time);</span><br><span class="line">                node.thread = <span class="keyword">null</span>;</span><br><span class="line">                U.putObject(wt, PARKBLOCKER, <span class="keyword">null</span>);</span><br><span class="line">                <span class="keyword">if</span> (interruptible &amp;&amp; Thread.interrupted())</span><br><span class="line">                    <span class="keyword">return</span> cancelWaiter(node, node, <span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;1.头节点 == 尾节点，表示已经快轮到自己了、尝试获取锁、成功则返回</p>
<p>&emsp;&emsp;2.头节点 != 尾节点，当前节点入队</p>
<p>&emsp;&emsp;3.首个读节点入队：排队到整个队尾的尾部、跳出第一次自旋、进入第五次自旋</p>
<p>&emsp;&emsp;4.非首个读节点入队：进入首个读节点的cowait栈中</p>
<p>&emsp;&emsp;5.检测头节点是否等于尾节点：相等则会不断的尝试获取锁，不相等：当前线程进入阻塞等待被唤醒</p>
<p>&emsp;&emsp;6.首个读节点表示连续的读线程中的首个、若是两个读线程之间存在了一个写人线程，那么也会进行排队</p>
<h3 id="unlockRead-1"><a href="#unlockRead-1" class="headerlink" title="unlockRead"></a>unlockRead</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlockRead</span><span class="params">(<span class="keyword">long</span> stamp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> s, m; WNode h;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//检测版本号</span></span><br><span class="line">        <span class="keyword">if</span> (((s = state) &amp; SBITS) != (stamp &amp; SBITS) ||</span><br><span class="line">            (stamp &amp; ABITS) == <span class="number">0L</span> || (m = s &amp; ABITS) == <span class="number">0L</span> || m == WBIT)</span><br><span class="line">            <span class="comment">//抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">        <span class="comment">//判断读线程的个数</span></span><br><span class="line">        <span class="keyword">if</span> (m &lt; RFULL) &#123;</span><br><span class="line">            <span class="comment">//释放一次读取锁</span></span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapLong(<span class="keyword">this</span>, STATE, s, s - RUNIT)) &#123;</span><br><span class="line">                <span class="comment">//如果线程全部已经被释放了、头节点不为空并且状态不为0、release方法唤醒下一个节点</span></span><br><span class="line">                <span class="keyword">if</span> (m == RUNIT &amp;&amp; (h = whead) != <span class="keyword">null</span> &amp;&amp; h.status != <span class="number">0</span>)</span><br><span class="line">                    release(h);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (tryDecReaderOverflow(s) != <span class="number">0L</span>)</span><br><span class="line">            <span class="comment">//读取线程个数溢出</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">(WNode h)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (h != <span class="keyword">null</span>) &#123;</span><br><span class="line">        WNode q; Thread w;</span><br><span class="line">        <span class="comment">//设置状态为0</span></span><br><span class="line">        U.compareAndSwapInt(h, WSTATUS, WAITING, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">//如果头节点的下一个节点为空或其状态为CANCELLED</span></span><br><span class="line">        <span class="keyword">if</span> ((q = h.next) == <span class="keyword">null</span> || q.status == CANCELLED) &#123;</span><br><span class="line">            <span class="comment">//从尾部往前进行遍历寻找一个可用的节点</span></span><br><span class="line">            <span class="keyword">for</span> (WNode t = wtail; t != <span class="keyword">null</span> &amp;&amp; t != h; t = t.prev)</span><br><span class="line">                <span class="keyword">if</span> (t.status &lt;= <span class="number">0</span>)</span><br><span class="line">                    q = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//唤醒q处节点的线程</span></span><br><span class="line">        <span class="keyword">if</span> (q != <span class="keyword">null</span> &amp;&amp; (w = q.thread) != <span class="keyword">null</span>)</span><br><span class="line">            U.unpark(w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="tryOptimisticRead-1"><a href="#tryOptimisticRead-1" class="headerlink" title="tryOptimisticRead"></a>tryOptimisticRead</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果没有写锁，就返回state的高25位</span></span><br><span class="line"><span class="comment">//写所在位置一起返回,为了后面检测数据有没有被写过</span></span><br><span class="line"><span class="comment">//乐观读</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">tryOptimisticRead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> s;</span><br><span class="line">    <span class="keyword">return</span> (((s = state) &amp; WBIT) == <span class="number">0L</span>) ? (s &amp; SBITS) : <span class="number">0L</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="validate-1"><a href="#validate-1" class="headerlink" title="validate"></a>validate</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//检测乐观读版本号是否变化</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validate</span><span class="params">(<span class="keyword">long</span> stamp)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 强制加入内存屏障，刷新数据</span></span><br><span class="line">    U.loadFence();</span><br><span class="line">    <span class="keyword">return</span> (stamp &amp; SBITS) == (state &amp; SBITS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="变异的CLH队列"><a href="#变异的CLH队列" class="headerlink" title="变异的CLH队列"></a>变异的CLH队列</h3><p><img src="/image/hexo/image-20200718204935119.png" alt="image-20200718204935119"></p>
<h2 id="运行示例分析"><a href="#运行示例分析" class="headerlink" title="运行示例分析"></a>运行示例分析</h2><p><a href="https://segmentfault.com/a/1190000015808032" target="_blank" rel="noopener">来源</a></p>
<blockquote>
<p><code>//Thread_A 获取写锁</code><br><code>//Thread_B 获取读锁</code><br><code>//Thread_C 获取读锁</code><br><code>//Thread_D 获取写锁</code><br><code>//Thread_E 获取读锁</code></p>
</blockquote>
<h3 id="Thread-A-writeLock"><a href="#Thread-A-writeLock" class="headerlink" title="Thread_A(writeLock)"></a>Thread_A(writeLock)</h3><p><img src="/image/hexo/image-20200718205455857.png" alt="image-20200718205455857"></p>
<p>StampedLock中大量运用了位运算，这里<code>(s = state) &amp; ABITS == 0L</code> 表示读锁和写锁都未被使用，这里写锁可以立即获取成功，然后CAS操作更新同步状态值State。</p>
<p>操作完成后，等待队列的结构如下：</p>
<p><img src="/image/hexo/image-20200718205419032.png" alt="image-20200718205419032"></p>
<blockquote>
<p>注意：StampedLock中，等待队列的结点要比AQS中简单些，仅仅三种状态。<br>0：初始状态<br>-1：等待中<br>1：取消</p>
</blockquote>
<p>另外，结点的定义中有个<code>cowait</code>字段，该字段指向一个栈，用于保存读线程。</p>
<h3 id="Thread-B-readLock"><a href="#Thread-B-readLock" class="headerlink" title="Thread_B(readLock)"></a>Thread_B(readLock)</h3><p><img src="/image/hexo/image-20200718205552104.png" alt="image-20200718205552104"></p>
<p>由于<code>Thread_A</code>线程持有了写锁、那么此时获取锁失败，进入<code>acquireRead</code>方法。</p>
<p><img src="/image/hexo/image-20200718205703751.png" alt="image-20200718205703751"></p>
<p><img src="/image/hexo/image-20200718205724877.png" alt="image-20200718205724877"></p>
<p><img src="/image/hexo/image-20200718205731522.png" alt="image-20200718205731522"></p>
<h3 id="Thread-C-readLock"><a href="#Thread-C-readLock" class="headerlink" title="Thread_C(readLock)"></a>Thread_C(readLock)</h3><p>这个过程和<code>Thread_B</code>获取读锁一样，区别在于<code>Thread_C</code>被包装成结点加入等待队列后，是链接到<code>Thread_B</code>结点的栈指针中的。调用完下面这段代码后，<code>Thread_C</code>会链接到以<code>Thread_B</code>为栈顶指针的栈中：</p>
<p><img src="/image/hexo/image-20200718205839240.png" alt="image-20200718205839240"></p>
<p><img src="/image/hexo/image-20200718205856220.png" alt="image-20200718205856220"></p>
<p>可以看到，此时<code>Thread_C</code>结点并没有把它的前驱的等待状态置为-1，因为<code>Thread_C</code>是链接到栈中的，当写锁释放的时候，会从栈底元素开始，唤醒栈中所有读结点。</p>
<h3 id="Thread-D-writeLock"><a href="#Thread-D-writeLock" class="headerlink" title="Thread_D(writeLock)"></a>Thread_D(writeLock)</h3><p><code>Thread_D</code>调用<strong>writeLock</strong>方法获取写锁失败后（<code>Thread_A</code>依然占用着写锁），会调用<strong>acquireWrite</strong>方法，该方法整体逻辑和<strong>acquireRead</strong>差不多，首先自旋的尝试获取写锁，获取成功后，就直接返回；否则，会将当前线程包装成一个写结点，插入到等待队列。</p>
<p><img src="/image/hexo/image-20200718205934160.png" alt="image-20200718205934160"></p>
<p><img src="/image/hexo/image-20200718210007566.png" alt="image-20200718210007566"></p>
<p><img src="/image/hexo/image-20200718210018123.png" alt="image-20200718210018123"></p>
<h3 id="Thead-E-readLock"><a href="#Thead-E-readLock" class="headerlink" title="Thead_E(readLock)"></a>Thead_E(readLock)</h3><p>同样，由于写锁被<code>Thread_A</code>占用着，所以最终会调用<strong>acquireRead</strong>方法，在该方法的第一个自旋中，会将<code>Thread_E</code>加入等待队列:</p>
<p><img src="/image/hexo/image-20200718210103657.png" alt="image-20200718210103657"></p>
<p><img src="/image/hexo/image-20200718210116706.png" alt="image-20200718210116706"></p>
<h3 id="Thread-A-unlockWrite"><a href="#Thread-A-unlockWrite" class="headerlink" title="Thread_A(unlockWrite)"></a>Thread_A(unlockWrite)</h3><p>通过CAS操作，修改State成功后，会调用<strong>release</strong>方法唤醒等待队列的队首结点：</p>
<p><img src="/image/hexo/image-20200718210206473.png" alt="image-20200718210206473"></p>
<p><strong>release</strong>方法非常简单，先将头结点的等待状态置为0，表示即将唤醒后继结点，然后立即唤醒队首结点：</p>
<p><img src="/image/hexo/image-20200718210221536.png" alt="image-20200718210221536"></p>
<p><img src="/image/hexo/image-20200718210229864.png" alt="image-20200718210229864"></p>
<h3 id="Thread-B-unlockRead-gt-next"><a href="#Thread-B-unlockRead-gt-next" class="headerlink" title="Thread_B(unlockRead-&gt;next)"></a>Thread_B(unlockRead-&gt;next)</h3><p><img src="/image/hexo/image-20200718210309090.png" alt="image-20200718210309090"></p>
<p>第二次自旋时，<code>Thread_B</code>发现写锁未被占用，则成功获取到读锁，然后从栈顶（<code>Thread_B</code>的cowait指针指向的结点）开始唤醒栈中所有线程，<br>最后返回：</p>
<p><img src="/image/hexo/image-20200718210321715.png" alt="image-20200718210321715"></p>
<p><img src="/image/hexo/image-20200718210328781.png" alt="image-20200718210328781"></p>
<h3 id="Thread-C-unlockRead-gt-next"><a href="#Thread-C-unlockRead-gt-next" class="headerlink" title="Thread_C(unlockRead-&gt;next)"></a>Thread_C(unlockRead-&gt;next)</h3><p><code>Thread_C</code>被唤醒后，继续执行，并进入下一次自旋，下一次自旋时，会成功获取到读锁。</p>
<p><img src="/image/hexo/69274006-5b5de694a90ad_articlex.png" alt="69274006-5b5de694a90ad_articlex"></p>
<p>注意，此时<code>Thread_B</code>和<code>Thread_C</code>已经拿到了读锁，<code>Thread_D</code>（写线程）和<code>Thread_E</code>（读线程）依然阻塞中，原来<code>Thread_C</code>对应的结点是个孤立结点，会被GC回收。</p>
<p><img src="/image/hexo/image-20200718210625568.png" alt="image-20200718210625568"></p>
<h3 id="Thread-B和Thread-C释放读锁"><a href="#Thread-B和Thread-C释放读锁" class="headerlink" title="Thread_B和Thread_C释放读锁"></a>Thread_B和Thread_C释放读锁</h3><p><code>Thread_B</code>和<code>Thread_C</code>调用<strong>unlockRead</strong>方法释放读锁，CAS操作State将读锁数量减1：</p>
<p><img src="/image/hexo/image-20200718210714617.png" alt="image-20200718210714617"></p>
<p>注意，当读锁的数量变为0时才会调用<strong>release</strong>方法，唤醒队首结点：</p>
<p><img src="/image/hexo/image-20200718210728941.png" alt="image-20200718210728941"></p>
<p><img src="/image/hexo/image-20200718210735960.png" alt="image-20200718210735960"></p>
<h3 id="Thread-D被唤醒后继续向下执行"><a href="#Thread-D被唤醒后继续向下执行" class="headerlink" title="Thread_D被唤醒后继续向下执行"></a>Thread_D被唤醒后继续向下执行</h3><p><code>Thread_D</code>会从原阻塞处继续向下执行，并在下一次自旋中获取到写锁，然后返回:</p>
<p><img src="/image/hexo/4207167806-5b5de717b34bc_articlex.png" alt="4207167806-5b5de717b34bc_articlex"></p>
<p><img src="/image/hexo/image-20200718210843887.png" alt="image-20200718210843887"></p>
<h3 id="Thread-D调用unlockWrite释放写锁"><a href="#Thread-D调用unlockWrite释放写锁" class="headerlink" title="Thread_D调用unlockWrite释放写锁"></a>Thread_D调用unlockWrite释放写锁</h3><p><code>Thread_D</code>释放写锁，会调用<strong>unlockWrite</strong>唤醒队首结点（<code>Thread_E</code>）。</p>
<p><img src="/image/hexo/image-20200718210935053.png" alt="image-20200718210935053"></p>
<p><code>Thread_E</code>被唤醒后会从原阻塞处继续向下执行，但由于<code>Thread_E</code>是个读结点，所以同时会唤醒cowait栈中的所有读结点。最终，等待队列的结构如下：</p>
<p><img src="/image/hexo/image-20200718211018901.png" alt="image-20200718211018901"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>StampedLock</strong>的等待队列与<strong>RRW</strong>的<strong>CLH</strong>队列相比，有以下特点：</p>
<ol>
<li>当入队一个线程时，如果队尾是读结点，不会直接链接到队尾，而是链接到该读结点的cowait链中，cowait链本质是一个栈；</li>
<li>当入队一个线程时，如果队尾是写结点，则直接链接到队尾；</li>
<li>唤醒线程的规则和<strong>AQS</strong>类似，都是首先唤醒队首结点。区别是<strong>StampedLock</strong>中，当唤醒的结点是读结点时，会唤醒该读结点的cowait链中的所有读结点（顺序和入栈顺序相反，也就是后进先出）。</li>
</ol>
<p>另外，<strong>StampedLock</strong>使用时要特别小心，避免锁重入的操作，在使用乐观读锁时也需要遵循相应的调用模板，防止出现数据不一致的问题。</p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">sanmeng</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://blog.huhdcc.top/2020/07/18/50320/hub/">https://blog.huhdcc.top/2020/07/18/50320/hub/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://blog.huhdcc.top" target="_blank">Here will be a new beginning</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JAVA/">JAVA</a><a class="post-meta__tags" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a><a class="post-meta__tags" href="/tags/%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5/">源码深入</a></div><div class="post_share"><div class="social-share" data-image="https://blog.huhdcc.top/image/hexo/image-20211122090644997.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/07/19/47803/hub/"><img class="prev_cover" src="https://blog.huhdcc.top/image/hexo/image-20200719101018337.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">多线程高阶-52-ForkJoin详解</div></div></a></div><div class="next-post pull_right"><a href="/2020/07/17/39136/hub/"><img class="next_cover" src="https://blog.huhdcc.top/image/hexo/image-20200717222143183.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">多线程高阶-50-Condition详解</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2020/07/05/52828/hub/" title="多线程高阶-27-AtomicBoolean详解"><img class="relatedPosts_cover" src="https://blog.huhdcc.top/image/hexo/image-20200706175723523.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-07-05</div><div class="relatedPosts_title">多线程高阶-27-AtomicBoolean详解</div></div></a></div><div class="relatedPosts_item"><a href="/2020/07/05/51967/hub/" title="多线程高阶-28-AtomicLong详解"><img class="relatedPosts_cover" src="https://blog.huhdcc.top/image/hexo/image-20200706175658410.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-07-05</div><div class="relatedPosts_title">多线程高阶-28-AtomicLong详解</div></div></a></div><div class="relatedPosts_item"><a href="/2020/07/06/7979/hub/" title="多线程高阶-32-AtomicLongArray详解"><img class="relatedPosts_cover" src="https://blog.huhdcc.top/image/hexo/image-20200706175601440.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-07-06</div><div class="relatedPosts_title">多线程高阶-32-AtomicLongArray详解</div></div></a></div><div class="relatedPosts_item"><a href="/2020/07/05/38835/hub/" title="多线程高阶-29-AtomicReference详解"><img class="relatedPosts_cover" src="https://blog.huhdcc.top/image/hexo/image-20200706175754808.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-07-05</div><div class="relatedPosts_title">多线程高阶-29-AtomicReference详解</div></div></a></div><div class="relatedPosts_item"><a href="/2020/07/06/50648/hub/" title="多线程高阶-30-AtomicStampReference详解"><img class="relatedPosts_cover" src="https://blog.huhdcc.top/image/hexo/image-20200706175842082.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-07-06</div><div class="relatedPosts_title">多线程高阶-30-AtomicStampReference详解</div></div></a></div><div class="relatedPosts_item"><a href="/2020/07/06/56990/hub/" title="多线程高阶-35-AtomicLongFieldUpdater详解"><img class="relatedPosts_cover" src="https://blog.huhdcc.top/image/hexo/image-20200706191044266.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-07-06</div><div class="relatedPosts_title">多线程高阶-35-AtomicLongFieldUpdater详解</div></div></a></div></div><div class="clear_both"></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By sanmeng</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div><div class="footer_custom_text">Hi, welcome to my <a href="https://blog.huhdcc.top/">blog</a>!</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="/js/third-party/fireworks.js"></script><script id="ribbon_piao" mobile="false" src="/js/third-party/piao.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@3/instantpage.min.js" type="module"></script><script src="/js/third-party/click_heart.js"></script><script src="/js/third-party/ClickShowText.js"></script><script src="/js/search/local-search.js"></script><script src="https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@master/Hexo/js/hideCategory.min.js"></script></body></html>